    class Ce extends Yt {
        constructor(t, e) {
            super();
            for (let i = 0; i < p.pitchesPerOctave; i++)
                t.song.scaleCustom[i] = e[i];
            t.notifier.changed(),
            this.Nt()
        }
    }
    class Ae extends Yt {
        constructor(t, e, i, n) {
            if (super(),
            t.song.pitchChannelCount != e || t.song.noiseChannelCount != i || t.song.modChannelCount != n) {
                const s = [];
                function o(e, i, n, o, a, r, h) {
                    for (let l = 0; l < e; l++) {
                        const e = l + n
                          , c = l + o;
                        if (l < i)
                            s[e] = t.song.channels[c];
                        else {
                            s[e] = new _t,
                            s[e].octave = a;
                            for (let i = 0; i < p.instrumentCountMin; i++) {
                                const n = new Ht(r,h);
                                if (h)
                                    n.setTypeAndReset(10, r, h);
                                else {
                                    const e = on(r)
                                      , i = N.valueToPreset(e);
                                    n.fromJsonObject(i.settings, r, h, 0 == t.song.rhythm || 2 == t.song.rhythm, t.song.rhythm >= 2),
                                    n.preset = e,
                                    n.effects |= 4
                                }
                                s[e].instruments[i] = n
                            }
                            for (let i = 0; i < t.song.patternsPerChannel; i++)
                                s[e].patterns[i] = new Pt;
                            for (let i = 0; i < t.song.barCount; i++)
                                s[e].bars[i] = 0
                        }
                    }
                }
                o(e, t.song.pitchChannelCount, 0, 0, 3, !1, !1),
                o(i, t.song.noiseChannelCount, e, t.song.pitchChannelCount, 0, !0, !1),
                o(n, t.song.modChannelCount, i + e, t.song.pitchChannelCount + t.song.noiseChannelCount, 0, !1, !0);
                let a = t.song.pitchChannelCount;
                t.song.pitchChannelCount = e,
                t.song.noiseChannelCount = i,
                t.song.modChannelCount = n;
                for (let r = 0; r < t.song.getChannelCount(); r++)
                    t.song.channels[r] = s[r];
                t.song.channels.length = t.song.getChannelCount(),
                t.channel = Math.min(t.channel, e + i + n - 1);
                for (let h = t.song.pitchChannelCount + t.song.noiseChannelCount; h < t.song.getChannelCount(); h++)
                    for (let l = 0; l < t.song.channels[h].instruments.length; l++)
                        for (let c = 0; c < p.modCount; c++) {
                            let d = t.song.channels[h].instruments[l]
                              , m = d.modChannels[c];
                            (m >= t.song.pitchChannelCount && m < a || m >= t.song.pitchChannelCount + t.song.noiseChannelCount) && (d.modulators[c] = p.modulators.dictionary.none.index),
                            m >= a && a < e && (d.modChannels[c] += e - a)
                        }
                t.notifier.changed(),
                nt.resetColors(),
                this.Nt()
            }
        }
    }
    class Ee extends Zt {
        constructor(t, e, i, n) {
            super();
            const s = t.song.pitchChannelCount + (i || n ? 0 : 1)
              , o = t.song.noiseChannelCount + (!i || n ? 0 : 1)
              , a = t.song.modChannelCount + (i || !n ? 0 : 1);
            if (s <= p.pitchChannelCountMax && o <= p.noiseChannelCountMax && a <= p.modChannelCountMax) {
                const r = n ? t.song.pitchChannelCount + t.song.noiseChannelCount + t.song.modChannelCount : i ? t.song.pitchChannelCount + t.song.noiseChannelCount : t.song.pitchChannelCount;
                this.append(new Ae(t,s,o,a)),
                r - 1 >= e && this.append(new Fe(t,e,r - 1,1)),
                t.synth.computeLatestModValues(),
                t.recalcChannelNames = !0
            }
        }
    }
    class Te extends Zt {
        constructor(t, e, i) {
            super();
            const n = i;
            for (let i = t.song.pitchChannelCount + t.song.noiseChannelCount; i < t.song.channels.length; i++)
                for (let s = 0; s < t.song.channels[i].instruments.length; s++) {
                    const o = t.song.channels[i].instruments[s];
                    for (let i = 0; i < p.modCount; i++)
                        o.modChannels[i] >= e && o.modChannels[i] <= n ? this.append(new Gi(t,i,0,o)) : o.modChannels[i] > n && this.append(new Gi(t,i,o.modChannels[i] - (n - e + 1) + 2,o))
                }
            for (; i >= e; ) {
                const e = t.song.getChannelIsNoise(i)
                  , n = t.song.getChannelIsMod(i);
                t.song.channels.splice(i, 1),
                e ? t.song.noiseChannelCount-- : n ? t.song.modChannelCount-- : t.song.pitchChannelCount--,
                i--
            }
            t.song.pitchChannelCount < p.pitchChannelCountMin && this.append(new Ae(t,p.pitchChannelCountMin,t.song.noiseChannelCount,t.song.modChannelCount)),
            nt.resetColors(),
            t.recalcChannelNames = !0,
            this.append(new Pe(t,Math.max(0, e - 1),t.bar)),
            t.synth.computeLatestModValues(),
            this.Nt(),
            t.notifier.changed()
        }
    }
    class Pe extends Yt {
        constructor(t, e, i, n=!1) {
            super();
            const s = t.channel
              , o = t.bar;
            if (t.channel = e,
            t.bar = i,
            n || t.selection.scrollToSelectedPattern(),
            t.song.getChannelIsMod(t.channel)) {
                const e = t.song.getPattern(t.channel, t.bar);
                null != e && (t.viewedInstrument[t.channel] = e.instruments[0])
            }
            t.notifier.changed(),
            s == e && o == i || this.Nt()
        }
    }
    class Be extends Yt {
        constructor(t, e) {
            super();
            const i = t.song.channels[t.channel].instruments[t.getCurrentInstrument()];
            i.unison != e && (i.unison = e,
            i.unisonVoices = p.unisons[i.unison].voices,
            i.unisonSpread = p.unisons[i.unison].spread,
            i.unisonOffset = p.unisons[i.unison].offset,
            i.unisonExpression = p.unisons[i.unison].expression,
            i.unisonSign = p.unisons[i.unison].sign,
            i.preset = i.type,
            t.notifier.changed(),
            this.Nt())
        }
    }
    class Ie extends Yt {
        constructor(t, e, i) {
            super();
            const n = t.song.channels[t.channel].instruments[t.getCurrentInstrument()];
            let s = n.unison;
            e == i && s == p.unisons.length || (n.unisonVoices = i,
            n.unison = p.unisons.length,
            n.preset = n.type,
            t.notifier.changed(),
            this.Nt())
        }
    }
    class Le extends Yt {
        constructor(t, e, i) {
            super();
            const n = t.song.channels[t.channel].instruments[t.getCurrentInstrument()];
            let s = n.unison;
            e == i && s == p.unisons.length || (n.unisonSpread = i,
            n.unison = p.unisons.length,
            n.preset = n.type,
            t.notifier.changed(),
            this.Nt())
        }
    }
    class De extends Yt {
        constructor(t, e, i) {
            super();
            const n = t.song.channels[t.channel].instruments[t.getCurrentInstrument()];
            let s = n.unison;
            e == i && s == p.unisons.length || (n.unisonOffset = i,
            n.unison = p.unisons.length,
            n.preset = n.type,
            t.notifier.changed(),
            this.Nt())
        }
    }
    class ze extends Yt {
        constructor(t, e, i) {
            super();
            const n = t.song.channels[t.channel].instruments[t.getCurrentInstrument()];
            let s = n.unison;
            e == i && s == p.unisons.length || (n.unisonExpression = i,
            n.unison = p.unisons.length,
            n.preset = n.type,
            t.notifier.changed(),
            this.Nt())
        }
    }
    class qe extends Yt {
        constructor(t, e, i) {
            super();
            const n = t.song.channels[t.channel].instruments[t.getCurrentInstrument()];
            let s = n.unison;
            e == i && s == p.unisons.length || (n.unisonSign = i,
            n.unison = p.unisons.length,
            n.preset = n.type,
            t.notifier.changed(),
            this.Nt())
        }
    }
    class Ne extends Yt {
        constructor(t, e) {
            super();
            const i = t.song.channels[t.channel].instruments[t.getCurrentInstrument()];
            i.chord != e && (this.Nt(),
            i.chord = e,
            i.preset = i.type,
            t.notifier.changed())
        }
    }
    class Oe extends Yt {
        constructor(t, e) {
            super();
            const i = t.song.channels[t.channel].instruments[t.getCurrentInstrument()];
            i.vibrato != e && (i.vibrato = e,
            i.vibratoDepth = p.vibratos[i.vibrato].amplitude,
            i.vibratoDelay = p.vibratos[i.vibrato].delayTicks / 2,
            i.vibratoSpeed = 10,
            i.vibratoType = p.vibratos[i.vibrato].type,
            i.preset = i.type,
            t.notifier.changed(),
            this.Nt())
        }
    }
    class Re extends Yt {
        constructor(t, e, i) {
            super();
            const n = t.song.channels[t.channel].instruments[t.getCurrentInstrument()];
            let s = n.vibrato;
            t.synth.unsetMod(p.modulators.dictionary["vibrato depth"].index, t.channel, t.getCurrentInstrument()),
            t.notifier.changed(),
            e == i && s == p.vibratos.length || (n.vibratoDepth = i / 25,
            n.vibrato = p.vibratos.length,
            n.preset = n.type,
            t.notifier.changed(),
            this.Nt())
        }
    }
    class $e extends Yt {
        constructor(t, e, i) {
            super();
            const n = t.song.channels[t.channel].instruments[t.getCurrentInstrument()];
            t.synth.unsetMod(p.modulators.dictionary["envelope speed"].index, t.channel, t.getCurrentInstrument()),
            t.notifier.changed(),
            e != i && (n.envelopeSpeed = i,
            n.preset = n.type,
            t.notifier.changed(),
            this.Nt())
        }
    }
    class He extends Yt {
        constructor(t, e, i) {
            super();
            const n = t.song.channels[t.channel].instruments[t.getCurrentInstrument()];
            let s = n.vibrato;
            t.synth.unsetMod(p.modulators.dictionary["vibrato speed"].index, t.channel, t.getCurrentInstrument()),
            t.notifier.changed(),
            e == i && s == p.vibratos.length || (n.vibratoSpeed = i,
            n.vibrato = p.vibratos.length,
            n.preset = n.type,
            t.notifier.changed(),
            this.Nt())
        }
    }
    class _e extends Yt {
        constructor(t, e, i) {
            super();
            const n = t.song.channels[t.channel].instruments[t.getCurrentInstrument()];
            let s = n.vibrato;
            t.synth.unsetMod(p.modulators.dictionary["vibrato delay"].index, t.channel, t.getCurrentInstrument()),
            t.notifier.changed(),
            e == i && s == p.vibratos.length || (n.vibratoDelay = i,
            n.vibrato = p.vibratos.length,
            n.preset = n.type,
            t.notifier.changed(),
            this.Nt())
        }
    }
    class Ve extends Yt {
        constructor(t, e) {
            super();
            const i = t.song.channels[t.channel].instruments[t.getCurrentInstrument()]
              , n = i.vibratoType;
            let s = i.vibrato;
            t.notifier.changed(),
            n == e && s == p.vibratos.length || (i.vibratoType = e,
            i.vibrato = p.vibratos.length,
            i.preset = i.type,
            t.notifier.changed(),
            this.Nt())
        }
    }
    class Ge extends Yt {
        constructor(t, e, i) {
            super();
            const n = t.song.channels[t.channel].instruments[t.getCurrentInstrument()];
            n.arpeggioSpeed = i,
            t.synth.unsetMod(p.modulators.dictionary["arp speed"].index, t.channel, t.getCurrentInstrument()),
            t.notifier.changed(),
            e != i && (n.preset = n.type,
            this.Nt())
        }
    }
    class We extends Yt {
        constructor(t, e) {
            super();
            const i = t.song.channels[t.channel].instruments[t.getCurrentInstrument()]
              , n = i.fastTwoNoteArp;
            t.notifier.changed(),
            n != e && (i.fastTwoNoteArp = e,
            i.preset = i.type,
            this.Nt())
        }
    }
    class je extends Yt {
        constructor(t, e) {
            super();
            const i = t.song.channels[t.channel].instruments[t.getCurrentInstrument()]
              , n = i.clicklessTransition;
            t.notifier.changed(),
            n != e && (i.clicklessTransition = e,
            i.preset = i.type,
            this.Nt())
        }
    }
    class Ue extends Yt {
        constructor(t, e) {
            super();
            const i = t.song.channels[t.channel].instruments[t.getCurrentInstrument()]
              , n = i.aliases;
            t.notifier.changed(),
            n != e && (i.aliases = e,
            i.preset = i.type,
            this.Nt())
        }
    }
    class Ke extends Yt {
        constructor(t, e) {
            super();
            const i = t.song.channels[t.channel].instruments[t.getCurrentInstrument()]
              , n = i.discreteEnvelope;
            t.notifier.changed(),
            n != e && (i.discreteEnvelope = e,
            i.preset = i.type,
            this.Nt())
        }
    }
    class Je extends Yt {
        constructor(t, e, i) {
            super(),
            i.markCustomWaveDirty(),
            e.preset = e.type,
            t.notifier.changed(),
            this.Nt()
        }
    }
    class Ye extends Yt {
        constructor(t, e, i) {
            super(),
            i.markCustomWaveDirty(),
            e.preset = e.type,
            t.notifier.changed(),
            this.Nt()
        }
    }
    class Qe extends Yt {
        constructor(t, e, i) {
            super();
            const n = t.song.channels[t.channel].instruments[t.getCurrentInstrument()];
            n.drumsetEnvelopes[e] != i && (n.drumsetEnvelopes[e] = i,
            n.preset = n.type,
            t.notifier.changed(),
            this.Nt())
        }
    }
    class Ze extends Yt {
        constructor(t) {
            super(),
            this.m = t,
            this.ne = this.m.song.channels[this.m.channel].instruments[this.m.getCurrentInstrument()]
        }
        commit() {
            this.isNoop() || (this.ne.preset = this.ne.type,
            this.m.notifier.changed())
        }
    }
    class Xe extends Ze {
        constructor(t, e, i) {
            super(t),
            this.ne.pulseWidth = i,
            t.synth.unsetMod(p.modulators.dictionary["pulse width"].index, t.channel, t.getCurrentInstrument()),
            t.notifier.changed(),
            e != i && this.Nt()
        }
    }
    class ti extends Ze {
        constructor(t, e, i) {
            super(t),
            this.ne.decimalOffset = i,
            t.notifier.changed(),
            e != i && this.Nt()
        }
    }
    class ei extends Ze {
        constructor(t, e, i) {
            super(t),
            this.ne.supersawDynamism = i,
            t.synth.unsetMod(p.modulators.dictionary.dynamism.index, t.channel, t.getCurrentInstrument()),
            t.notifier.changed(),
            e != i && this.Nt()
        }
    }
    class ii extends Ze {
        constructor(t, e, i) {
            super(t),
            this.ne.supersawSpread = i,
            t.synth.unsetMod(p.modulators.dictionary.spread.index, t.channel, t.getCurrentInstrument()),
            t.notifier.changed(),
            e != i && this.Nt()
        }
    }
    class ni extends Ze {
        constructor(t, e, i) {
            super(t),
            this.ne.supersawShape = i,
            t.synth.unsetMod(p.modulators.dictionary["saw shape"].index, t.channel, t.getCurrentInstrument()),
            t.notifier.changed(),
            e != i && this.Nt()
        }
    }
    class si extends Ze {
        constructor(t, e, i) {
            super(t),
            this.ne.pitchShift = i,
            t.notifier.changed(),
            e != i && this.Nt()
        }
    }
    class oi extends Ze {
        constructor(t, e, i) {
            super(t),
            this.ne.detune = i + p.detuneCenter,
            t.notifier.changed(),
            t.synth.unsetMod(p.modulators.dictionary.detune.index, t.channel, t.getCurrentInstrument()),
            e != i && this.Nt()
        }
    }
    class ai extends Ze {
        constructor(t, e, i) {
            super(t),
            this.ne.distortion = i,
            t.notifier.changed(),
            t.synth.unsetMod(p.modulators.dictionary.distortion.index, t.channel, t.getCurrentInstrument()),
            e != i && this.Nt()
        }
    }
    class ri extends Ze {
        constructor(t, e, i) {
            super(t),
            this.ne.bitcrusherFreq = i,
            t.notifier.changed(),
            e != i && this.Nt()
        }
    }
    class hi extends Ze {
        constructor(t, e, i) {
            super(t),
            this.ne.bitcrusherQuantization = i,
            t.notifier.changed(),
            e != i && this.Nt()
        }
    }
    class li extends Ze {
        constructor(t, e, i) {
            super(t),
            this.ne.stringSustain = i,
            t.synth.unsetMod(p.modulators.dictionary.sustain.index, t.channel, t.getCurrentInstrument()),
            t.notifier.changed(),
            e != i && this.Nt()
        }
    }
    class ci extends Yt {
        constructor(t, e) {
            super();
            const i = t.song.channels[t.channel].instruments[t.getCurrentInstrument()];
            i.stringSustainType != e && (i.stringSustainType = e,
            i.preset = i.type,
            t.notifier.changed(),
            this.Nt())
        }
    }
    class di extends Yt {
        constructor(t, e, i) {
            super(),
            e.eqFilterType = i,
            1 == i ? (e.eqFilter.reset(),
            e.tmpEqFilterStart = e.eqFilter,
            e.tmpEqFilterEnd = null) : (e.eqFilter.convertLegacySettings(e.eqFilterSimpleCut, e.eqFilterSimplePeak, p.envelopes.dictionary.none),
            e.tmpEqFilterStart = e.eqFilter,
            e.tmpEqFilterEnd = null),
            e.clearInvalidEnvelopeTargets(),
            e.preset = e.type,
            t.notifier.changed(),
            this.Nt()
        }
    }
    class pi extends Yt {
        constructor(t, e, i) {
            super(),
            e.noteFilterType = i,
            1 == i ? (e.noteFilter.reset(),
            e.tmpNoteFilterStart = e.noteFilter,
            e.tmpNoteFilterEnd = null) : (e.noteFilter.convertLegacySettings(e.noteFilterSimpleCut, e.noteFilterSimplePeak, p.envelopes.dictionary.none),
            e.tmpNoteFilterStart = e.noteFilter,
            e.tmpNoteFilterEnd = null),
            e.clearInvalidEnvelopeTargets(),
            e.preset = e.type,
            t.notifier.changed(),
            this.Nt()
        }
    }
    class mi extends Ze {
        constructor(t, e, i) {
            super(t),
            this.ne.eqFilterSimpleCut = i,
            t.synth.unsetMod(p.modulators.dictionary["eq filt cut"].index, t.channel, t.getCurrentInstrument()),
            t.notifier.changed(),
            e != i && this.Nt()
        }
    }
    class ui extends Ze {
        constructor(t, e, i) {
            super(t),
            this.ne.eqFilterSimplePeak = i,
            t.synth.unsetMod(p.modulators.dictionary["eq filt peak"].index, t.channel, t.getCurrentInstrument()),
            t.notifier.changed(),
            e != i && this.Nt()
        }
    }
    class fi extends Ze {
        constructor(t, e, i) {
            super(t),
            this.ne.noteFilterSimpleCut = i,
            t.synth.unsetMod(p.modulators.dictionary["note filt cut"].index, t.channel, t.getCurrentInstrument()),
            t.notifier.changed(),
            e != i && this.Nt()
        }
    }
    class yi extends Ze {
        constructor(t, e, i) {
            super(t),
            this.ne.noteFilterSimplePeak = i,
            t.synth.unsetMod(p.modulators.dictionary["note filt peak"].index, t.channel, t.getCurrentInstrument()),
            t.notifier.changed(),
            e != i && this.Nt()
        }
    }
    class bi extends Qt {
        constructor(t, e, i, n, s, o=!1) {
            super(o),
            this.se = [],
            this.oe = [],
            this.ae = [],
            this.re = [],
            this.m = t,
            this.ne = this.m.song.channels[this.m.channel].instruments[this.m.getCurrentInstrument()],
            this.he = o ? this.ne.preset : this.ne.type,
            this.le = o ? this.ne.type : this.ne.preset,
            this.ce = e,
            this.de = i,
            this.dt = n;
            for (let t = 0; t < this.ne.envelopeCount; t++) {
                let i = this.ne.envelopes[t].target
                  , a = this.ne.envelopes[t].index;
                if (this.se.push(i),
                this.oe.push(a),
                o) {
                    const t = p.instrumentAutomationTargets[i];
                    t.isFilter && 5 == t.effect == s && (t.maxCount == p.filterMaxPoints ? a == n ? (i = p.instrumentAutomationTargets.dictionary.none.index,
                    a = 0) : a > n && a-- : e.controlPointCount <= 1 && (i = p.instrumentAutomationTargets.dictionary.none.index,
                    a = 0))
                }
                this.ae.push(i),
                this.re.push(a)
            }
            this.Nt(),
            this.redo()
        }
        $t() {
            this.ce.controlPoints.splice(this.dt, 0, this.de),
            this.ce.controlPointCount++,
            this.ce.controlPoints.length = this.ce.controlPointCount,
            this.ne.preset = this.he;
            for (let t = 0; t < this.ne.envelopeCount; t++)
                this.ne.envelopes[t].target = this.se[t],
                this.ne.envelopes[t].index = this.oe[t];
            this.ne.tmpEqFilterStart = this.ne.eqFilter,
            this.ne.tmpEqFilterEnd = null,
            this.ne.tmpNoteFilterStart = this.ne.noteFilter,
            this.ne.tmpNoteFilterEnd = null,
            this.m.notifier.changed()
        }
        Ht() {
            this.ce.controlPoints.splice(this.dt, 1),
            this.ce.controlPointCount--,
            this.ce.controlPoints.length = this.ce.controlPointCount,
            this.ne.preset = this.le;
            for (let t = 0; t < this.ne.envelopeCount; t++)
                this.ne.envelopes[t].target = this.ae[t],
                this.ne.envelopes[t].index = this.re[t];
            this.ne.tmpEqFilterStart = this.ne.eqFilter,
            this.ne.tmpEqFilterEnd = null,
            this.ne.tmpNoteFilterStart = this.ne.noteFilter,
            this.ne.tmpNoteFilterEnd = null,
            this.m.notifier.changed()
        }
    }
    class gi {
        constructor(t, e, i) {
            this.point = t,
            this.freq = e,
            this.gain = i
        }
    }
    class wi extends Qt {
        constructor(t, e, i, n, s, o, a, r) {
            super(!1),
            this.m = t,
            this.ne = this.m.song.channels[this.m.channel].instruments[this.m.getCurrentInstrument()],
            this.he = this.ne.type,
            this.le = this.ne.preset,
            this.de = e,
            this.pe = i,
            this.me = n,
            this.ue = s,
            this.fe = o,
            this.useNoteFilter = a,
            this.pointIndex = r,
            this.pointType = e.type,
            this.Nt(),
            this.redo()
        }
        getMoveData(t) {
            return t ? new gi(this.de,this.pe,this.ue) : new gi(this.de,this.me,this.fe)
        }
        $t() {
            this.de.freq = this.me,
            this.de.gain = this.fe,
            this.ne.preset = this.he,
            this.m.notifier.changed()
        }
        Ht() {
            this.de.freq = this.pe,
            this.de.gain = this.ue,
            this.ne.preset = this.le,
            this.m.notifier.changed()
        }
    }
    class vi extends Qt {
        constructor(t, e, i, n, s=null, o=null) {
            super(!1),
            this.m = t,
            this.ne = this.m.song.channels[this.m.channel].instruments[this.m.getCurrentInstrument()],
            this.he = this.ne.type,
            this.le = this.ne.preset,
            this.ye = i,
            this.be = n,
            this.ce = e,
            null != s && null != o && (this.ge = s,
            this.we = o),
            this.ne.clearInvalidEnvelopeTargets(),
            this.Nt(),
            this.redo()
        }
        $t() {
            this.be ? (this.ne.noteFilter = this.ce,
            null != this.ge && (this.ne.noteSubFilters = this.ge),
            this.ne.tmpNoteFilterStart = this.ne.noteFilter,
            this.ne.tmpNoteFilterEnd = null) : (this.ne.eqFilter = this.ce,
            null != this.ge && (this.ne.eqSubFilters = this.ge),
            this.ne.tmpEqFilterStart = this.ne.eqFilter,
            this.ne.tmpEqFilterEnd = null),
            this.ne.preset = this.he,
            this.ne.clearInvalidEnvelopeTargets(),
            this.m.notifier.changed()
        }
        Ht() {
            this.be ? (this.ne.noteFilter = this.ye,
            null != this.we && (this.ne.noteSubFilters = this.we),
            this.ne.tmpNoteFilterStart = this.ne.noteFilter,
            this.ne.tmpNoteFilterEnd = null) : (this.ne.eqFilter = this.ye,
            null != this.we && (this.ne.eqSubFilters = this.we),
            this.ne.tmpEqFilterStart = this.ne.eqFilter,
            this.ne.tmpEqFilterEnd = null),
            this.ne.preset = this.le,
            this.ne.clearInvalidEnvelopeTargets(),
            this.m.notifier.changed()
        }
    }
    class xi extends Qt {
        constructor(t, e, i) {
            super(!1),
            this.m = t,
            this.ne = this.m.song.channels[this.m.channel].instruments[this.m.getCurrentInstrument()],
            this.he = this.ne.type,
            this.le = this.ne.preset,
            this.ve = this.ne.fadeIn,
            this.xe = this.ne.fadeOut,
            this.ke = e,
            this.Me = i,
            this.Nt(),
            this.redo()
        }
        $t() {
            this.ne.fadeIn = this.ke,
            this.ne.fadeOut = this.Me,
            this.ne.preset = this.he,
            this.m.notifier.changed()
        }
        Ht() {
            this.ne.fadeIn = this.ve,
            this.ne.fadeOut = this.xe,
            this.ne.preset = this.le,
            this.m.notifier.changed()
        }
    }
    class ki extends Yt {
        constructor(t, e) {
            super();
            const i = t.song.channels[t.channel].instruments[t.getCurrentInstrument()];
            i.algorithm != e && (i.algorithm = e,
            i.preset = i.type,
            t.notifier.changed(),
            this.Nt())
        }
    }
    class Mi extends Yt {
        constructor(t, e) {
            super();
            const i = t.song.channels[t.channel].instruments[t.getCurrentInstrument()];
            i.feedbackType != e && (i.feedbackType = e,
            i.preset = i.type,
            t.notifier.changed(),
            this.Nt())
        }
    }
    class Si extends Yt {
        constructor(t, e) {
            super();
            const i = t.song.channels[t.channel].instruments[t.getCurrentInstrument()];
            i.algorithm6Op != e && (i.algorithm6Op = e,
            0 != e && i.customAlgorithm.fromPreset(e),
            i.preset = i.type,
            t.notifier.changed(),
            this.Nt())
        }
    }
    class Fi extends Yt {
        constructor(t, e) {
            super();
            const i = t.song.channels[t.channel].instruments[t.getCurrentInstrument()];
            i.feedbackType6Op != e && (i.feedbackType6Op = e,
            0 != e && i.customFeedbackType.fromPreset(e),
            i.preset = i.type,
            t.notifier.changed(),
            this.Nt())
        }
    }
    class Ci extends Yt {
        constructor(t, e, i) {
            super();
            const n = t.song.channels[t.channel].instruments[t.getCurrentInstrument()];
            n.operators[e].waveform != i && (n.operators[e].waveform = i,
            n.preset = n.type,
            t.notifier.changed(),
            this.Nt())
        }
    }
    class Ai extends Yt {
        constructor(t, e, i, n) {
            super();
            const s = t.song.channels[t.channel].instruments[t.getCurrentInstrument()];
            s.operators[e].pulseWidth = n,
            t.notifier.changed(),
            i != n && (s.preset = s.type,
            this.Nt())
        }
    }
    class Ei extends Yt {
        constructor(t, e, i) {
            super();
            const n = t.song.channels[t.channel].instruments[t.getCurrentInstrument()];
            n.operators[e].frequency != i && (n.operators[e].frequency = i,
            n.preset = n.type,
            t.notifier.changed(),
            this.Nt())
        }
    }
    class Ti extends Ze {
        constructor(t, e, i, n) {
            super(t),
            this.operatorIndex = 0,
            this.operatorIndex = e,
            this.ne.operators[e].amplitude = n,
            t.notifier.changed(),
            i != n && this.Nt()
        }
    }
    class Pi extends Ze {
        constructor(t, e, i) {
            super(t),
            this.ne.feedbackAmplitude = i,
            t.notifier.changed(),
            e != i && this.Nt()
        }
    }
    class Bi extends Yt {
        constructor(t) {
            super();
            const e = t.song.channels[t.channel]
              , i = t.song.getChannelIsNoise(t.channel)
              , n = t.song.getChannelIsMod(t.channel)
              , s = t.song.getMaxInstrumentsPerChannel();
            if (e.instruments.length >= s)
                return;
            const o = on(i)
              , a = N.valueToPreset(o)
              , r = new Ht(i,n);
            r.fromJsonObject(a.settings, i, n, !1, !1, 1),
            r.preset = o,
            r.effects |= 4,
            r.volume = 0,
            e.instruments.push(r),
            n || (t.viewedInstrument[t.channel] = e.instruments.length - 1);
            for (let e = t.song.pitchChannelCount + t.song.noiseChannelCount; e < t.song.getChannelCount(); e++)
                for (let i = 0; i < t.song.channels[e].instruments.length; i++)
                    for (let n = 0; n < p.modCount; n++) {
                        let s = t.song.channels[e].instruments[i]
                          , o = s.modInstruments[n]
                          , a = s.modChannels[n];
                        a == t.channel && o >= t.song.channels[a].instruments.length - 1 && s.modInstruments[n]++
                    }
            t.synth.computeLatestModValues(),
            t.notifier.changed(),
            this.Nt()
        }
    }
    class Ii extends Yt {
        constructor(t) {
            super();
            const e = t.song.channels[t.channel];
            if (e.instruments.length <= p.instrumentCountMin)
                return;
            const i = t.viewedInstrument[t.channel];
            if (e.instruments.splice(i, 1),
            t.song.patternInstruments)
                for (const t of e.patterns) {
                    for (let e = 0; e < t.instruments.length; e++)
                        t.instruments[e] == i ? (t.instruments.splice(e, 1),
                        e--) : t.instruments[e] > i && t.instruments[e]--;
                    t.instruments.length <= 0 && (t.instruments[0] = 0)
                }
            for (let e = t.song.pitchChannelCount + t.song.noiseChannelCount; e < t.song.getChannelCount(); e++)
                for (let n = 0; n < t.song.channels[e].instruments.length; n++)
                    for (let s = 0; s < p.modCount; s++) {
                        let o = t.song.channels[e].instruments[n]
                          , a = o.modInstruments[s];
                        o.modChannels[s] == t.channel && (a > i ? o.modInstruments[s]-- : a == i && (o.modInstruments[s] = 0,
                        o.modulators[s] = 0))
                    }
            t.notifier.changed(),
            this.Nt()
        }
    }
    class Li extends Yt {
        constructor(t, e) {
            super(),
            t.viewedInstrument[t.channel] != e && (t.viewedInstrument[t.channel] = e,
            t.channel >= t.song.pitchChannelCount + t.song.noiseChannelCount && (t.recentPatternInstruments[t.channel] = [e]),
            t.notifier.changed(),
            this.Nt())
        }
    }
    class Di extends Yt {
        constructor(t, e, i) {
            super();
            const n = t.song.layeredInstruments
              , s = t.song.patternInstruments;
            if (n != e || s != i) {
                t.song.layeredInstruments = e,
                t.song.patternInstruments = i;
                for (let e = 0; e < t.song.getChannelCount(); e++) {
                    const n = t.song.channels[e];
                    n.instruments.length > t.song.getMaxInstrumentsPerChannel() && (n.instruments.length = t.song.getMaxInstrumentsPerChannel());
                    for (let o = 0; o < t.song.patternsPerChannel; o++) {
                        const a = n.patterns[o];
                        if (!s && i) {
                            for (let t = 0; t < n.instruments.length; t++)
                                a.instruments[t] = t;
                            a.instruments.length = n.instruments.length
                        }
                        ee(a.instruments, t.song, e)
                    }
                }
                t.notifier.changed(),
                this.Nt()
            }
        }
    }
    class zi extends Yt {
        constructor(t, e) {
            super(),
            t.song.key != e && (t.song.key = e,
            t.notifier.changed(),
            this.Nt())
        }
    }
    class qi extends Yt {
        constructor(t, e, i, n, s) {
            super(),
            this.m = t,
            this.oldStart = e,
            this.oldLength = i,
            this.newStart = n,
            this.newLength = s,
            this.m.song.loopStart = this.newStart,
            this.m.song.loopLength = this.newLength,
            this.m.notifier.changed(),
            this.oldStart == this.newStart && this.oldLength == this.newLength || this.Nt()
        }
    }
    class Ni extends Qt {
        constructor(t, e, i, n, s=!1) {
            super(s),
            this.m = t,
            this.Wt = e,
            this.Se = i,
            this.dt = n,
            this.Nt(),
            this.redo()
        }
        $t() {
            this.Wt.pitches.splice(this.dt, 0, this.Se),
            this.m.notifier.changed()
        }
        Ht() {
            this.Wt.pitches.splice(this.dt, 1),
            this.m.notifier.changed()
        }
    }
    class Oi extends Yt {
        constructor(t, e, i) {
            super(),
            this.oldValue = e,
            t.song.channels[t.channel].octave = i,
            t.notifier.changed(),
            e != i && this.Nt()
        }
    }
    class Ri extends Zt {
        constructor(t, e) {
            super(),
            t.song.rhythm != e && (t.song.rhythm = e,
            t.notifier.changed(),
            this.Nt())
        }
    }
    class $i extends Zt {
        constructor(t, e, i, n, s, o) {
            super(),
            this.append(new vn(t,e,n,s,null,!0));
            let a = 0;
            if (t.song.getChannelIsMod(t.channel))
                a = e.notes.length;
            else
                for (let t = 0; t < e.notes.length; t++)
                    if (e.notes[t].start < n) {
                        if (e.notes[t].end > n)
                            throw new Error;
                        a = t + 1
                    } else if (e.notes[t].start < s)
                        throw new Error;
            for (; n < s; ) {
                for (const o of i) {
                    const i = o.start + n
                      , r = o.end + n;
                    if (i >= s)
                        break;
                    const h = new Tt(o.pitches[0],i,r,o.pins[0].size,!1);
                    h.pitches.length = 0;
                    for (const t of o.pitches)
                        h.pitches.push(t);
                    h.pins.length = 0;
                    for (const t of o.pins)
                        h.pins.push(Et(t.interval, t.time, t.size));
                    h.continuesLastPattern = !0 === o.continuesLastPattern && 0 == h.start,
                    e.notes.splice(a++, 0, h),
                    h.end > s && this.append(new wn(t,h,h.start,s))
                }
                n += o
            }
            null != e && t.song.getChannelIsMod(t.channel) && e.notes.sort((function(t, e) {
                return t.start == e.start ? t.pitches[0] - e.pitches[0] : t.start - e.start
            }
            )),
            t.notifier.changed(),
            this.Nt()
        }
    }
    class Hi extends Zt {
        constructor(t, e, i) {
            super(),
            e.fromJsonObject(i, i.isDrum, i.isMod, !1, !1),
            t.notifier.changed(),
            this.Nt()
        }
    }
    class _i extends Zt {
        constructor(t, e, i) {
            super();
            let n = new Ht(i.isDrum,i.isMod);
            n.fromJsonObject(i, i.isDrum, i.isMod, !1, !1),
            e.instruments.push(n),
            this.Nt(),
            t.notifier.changed()
        }
    }
    class Vi extends Yt {
        constructor(t, e, i, n) {
            super(),
            te(i, n.instruments) || (n.instruments.length = 0,
            n.instruments.push(...i),
            ee(n.instruments, t.song, e),
            this.Nt(),
            t.notifier.changed())
        }
    }
    class Gi extends Yt {
        constructor(t, e, i, n) {
            super();
            let s = t.song.channels[t.channel].instruments[t.getCurrentInstrument()];
            null != n && (s = n),
            (0 == i || p.modulators[s.modulators[e]].forSong && i >= 2 || !p.modulators[s.modulators[e]].forSong && i < 2) && (s.modulators[e] = p.modulators.dictionary.none.index),
            s.modChannels[e] = i - 2,
            t.notifier.changed(),
            this.Nt()
        }
    }
    class Wi extends Yt {
        constructor(t, e, i) {
            super();
            let n = t.song.channels[t.channel].instruments[t.getCurrentInstrument()];
            n.modInstruments[e] != i && (n.modInstruments[e] = i,
            t.notifier.changed(),
            this.Nt())
        }
    }
    class ji extends Yt {
        constructor(t, e, i) {
            super();
            let n = t.song.channels[t.channel].instruments[t.getCurrentInstrument()]
              , s = n.modChannels[e]
              , o = [];
            if (s >= 0)
                if (n.modInstruments[e] == t.song.channels[s].instruments.length)
                    o = o.concat(t.song.channels[s].instruments);
                else if (n.modInstruments[e] > t.song.channels[s].instruments.length) {
                    let e = t.song.getPattern(s, t.bar);
                    if (null != e)
                        for (let i = 0; i < e.instruments.length; i++)
                            o.push(t.song.channels[s].instruments[e.instruments[i]])
                } else
                    o.push(t.song.channels[s].instruments[n.modInstruments[e]]);
            if (i.startsWith("+ ")) {
                i = i.substr(2);
                for (let e = 0; e < o.length; e++) {
                    const n = o[e];
                    n.effects & 1 << p.modulators.dictionary[i].associatedEffect || t.record(new we(t,p.modulators.dictionary[i].associatedEffect,n))
                }
            }
            let a = p.modulators.dictionary[i].index;
            if (n.modulators[e] != a) {
                n.modulators[e] = a;
                let i = p.modulators[a].maxRawVol;
                for (let n = 0; n < t.song.patternsPerChannel; n++) {
                    const s = t.song.channels[t.channel].patterns[n];
                    if (s.instruments[0] == t.getCurrentInstrument())
                        for (let t = 0; t < s.notes.length; t++) {
                            const n = s.notes[t];
                            if (n.pitches[0] == p.modCount - e - 1)
                                for (let t = 0; t < n.pins.length; t++) {
                                    const e = n.pins[t];
                                    e.size > i && (e.size = i)
                                }
                        }
                }
                t.notifier.changed(),
                this.Nt()
            }
        }
    }
    class Ui extends Yt {
        constructor(t, e, i) {
            super();
            let n = t.song.channels[t.channel].instruments[t.getCurrentInstrument()];
            if (n.modFilterTypes[e] != i) {
                n.modFilterTypes[e] = i;
                let s = t.song.getVolumeCapForSetting(!0, n.modulators[e], n.modFilterTypes[e]);
                for (let i = 0; i < t.song.patternsPerChannel; i++) {
                    const n = t.song.channels[t.channel].patterns[i];
                    if (n.instruments[0] == t.getCurrentInstrument())
                        for (let t = 0; t < n.notes.length; t++) {
                            const i = n.notes[t];
                            if (i.pitches[0] == p.modCount - e - 1)
                                for (let t = 0; t < i.pins.length; t++) {
                                    const e = i.pins[t];
                                    e.size > s && (e.size = s)
                                }
                        }
                }
                t.notifier.changed(),
                this.Nt()
            }
        }
    }
    class Ki extends Yt {
        constructor(t, e) {
            if (super(),
            t.song.patternsPerChannel != e) {
                for (let i = 0; i < t.song.getChannelCount(); i++) {
                    const n = t.song.channels[i].bars
                      , s = t.song.channels[i].patterns;
                    for (let t = 0; t < n.length; t++)
                        n[t] > e && (n[t] = 0);
                    for (let t = s.length; t < e; t++)
                        s[t] = new Pt;
                    s.length = e
                }
                t.song.patternsPerChannel = e,
                t.notifier.changed(),
                this.Nt()
            }
        }
    }
    class Ji extends Qt {
        constructor(t, e, i) {
            super(!1),
            this.Fe = null,
            this.Ce = null;
            const n = t.song;
            if (0 != n.channels[e].bars[i])
                return;
            this.m = t,
            this.Ae = i,
            this.Ee = e,
            this.Te = n.patternsPerChannel,
            this.Pe = n.patternsPerChannel,
            e < t.song.pitchChannelCount + t.song.noiseChannelCount ? this.Be = t.recentPatternInstruments[e].concat() : this.Be = [t.viewedInstrument[e]];
            let s = null
              , o = null;
            for (let t = 1; t <= n.patternsPerChannel; t++) {
                let i = !1;
                for (let s = 0; s < n.barCount; s++)
                    if (n.channels[e].bars[s] == t) {
                        i = !0;
                        break
                    }
                if (i)
                    continue;
                null == o && (o = t);
                if (0 == n.channels[e].patterns[t - 1].notes.length) {
                    s = t;
                    break
                }
            }
            if (null != s)
                this.Ie = s,
                this.Ce = n.channels[e].patterns[s - 1].instruments.concat();
            else if (n.patternsPerChannel < n.barCount)
                this.Pe = n.patternsPerChannel + 1,
                this.Ie = n.patternsPerChannel + 1;
            else {
                if (null == o)
                    throw new Error;
                this.Ie = o,
                this.Fe = n.channels[e].patterns[o - 1].notes,
                this.Ce = n.channels[e].patterns[o - 1].instruments.concat()
            }
            this.Nt(),
            this.$t()
        }
        $t() {
            const t = this.m.song;
            for (let e = t.patternsPerChannel; e < this.Pe; e++)
                for (let i = 0; i < t.getChannelCount(); i++)
                    t.channels[i].patterns[e] = new Pt;
            t.patternsPerChannel = this.Pe;
            const e = t.channels[this.Ee].patterns[this.Ie - 1];
            e.notes = [],
            e.instruments.length = 0,
            e.instruments.push(...this.Be),
            t.channels[this.Ee].bars[this.Ae] = this.Ie,
            this.m.notifier.changed()
        }
        Ht() {
            const t = this.m.song
              , e = t.channels[this.Ee].patterns[this.Ie - 1];
            null != this.Fe && (e.notes = this.Fe),
            null != this.Ce && (e.instruments.length = 0,
            e.instruments.push(...this.Ce)),
            t.channels[this.Ee].bars[this.Ae] = 0;
            for (let e = 0; e < t.getChannelCount(); e++)
                t.channels[e].patterns.length = this.Te;
            t.patternsPerChannel = this.Te,
            this.m.notifier.changed()
        }
    }
    class Yi extends me {
        constructor(t, e, i, n, s) {
            super(t, e),
            n -= this.jt;
            const o = this.Yt[i].time
              , a = Math.min(o, n)
              , r = Math.max(o, n);
            let h = !1;
            for (let t = 0; t < this.Yt.length; t++) {
                const o = e.pins[t]
                  , l = o.time;
                l < a ? this.Qt.push(Et(o.interval, l, o.size)) : l > r && (h || (this.Qt.length > 0 && (s = e.continuesLastPattern),
                this.Qt.push(Et(this.Yt[i].interval, n, this.Yt[i].size)),
                h = !0),
                this.Qt.push(Et(o.interval, l, o.size)))
            }
            h || (s = e.continuesLastPattern,
            this.Qt.push(Et(this.Yt[i].interval, n, this.Yt[i].size))),
            this.ie(s)
        }
    }
    class Qi extends me {
        constructor(t, e, i, n, s, o) {
            super(t, e),
            i -= this.jt,
            n -= this.jt,
            s -= e.pitches[o];
            let a, r, h, l, c = !1, d = !1, m = 0, u = p.noteSizeMax, f = !0;
            for (n > i ? (a = 0,
            r = 1,
            h = e.pins.length,
            l = t => {
                this.Qt.push(t)
            }
            ) : (a = e.pins.length - 1,
            r = -1,
            h = -1,
            l = t => {
                this.Qt.unshift(t)
            }
            ); a != h; a += r) {
                const t = e.pins[a]
                  , o = t.time;
                for (; ; )
                    if (c) {
                        if (d) {
                            if (o * r == n * r)
                                break;
                            t.interval != m && (f = !1),
                            l(Et(f ? s : t.interval, o, t.size));
                            break
                        }
                        if (o * r <= n * r && (m = t.interval,
                        u = t.size),
                        o * r < n * r)
                            break;
                        l(Et(s, n, u)),
                        d = !0
                    } else {
                        if (o * r <= i * r && (m = t.interval,
                        u = t.size),
                        o * r < i * r) {
                            l(Et(t.interval, o, t.size));
                            break
                        }
                        l(Et(m, i, u)),
                        c = !0
                    }
            }
            d || l(Et(s, n, u)),
            this.ie()
        }
    }
    class Zi extends Xt {
        constructor(t, e) {
            super();
            const i = p.partsPerBeat / p.rhythms[t.song.rhythm].stepsPerBeat
              , n = function(e) {
                let n = p.rhythms[t.song.rhythm].roundUpThresholds;
                if (null != n) {
                    const t = Math.floor(e / p.partsPerBeat) * p.partsPerBeat
                      , s = e - t;
                    let o = t;
                    for (const t of n) {
                        if (!(s >= t))
                            break;
                        o += i
                    }
                    return o
                }
                return Math.round(e / i) * i
            };
            let s = 0;
            for (; s < e.notes.length; ) {
                const i = e.notes[s];
                n(i.start) >= n(i.end) ? this.append(new gn(t,e,i,s,!0)) : (this.append(new Xi(t,i,n)),
                s++)
            }
        }
    }
    class Xi extends me {
        constructor(t, e, i) {
            super(t, e);
            for (const t of this.Yt)
                this.Qt.push(Et(t.interval, i(t.time + this.jt) - this.jt, t.size));
            this.ie()
        }
    }
    class tn extends Zt {
        constructor(t, e, i) {
            super();
            let n = Math.round(e % t.song.beatsPerBar * p.partsPerBeat);
            if (n < 0 && (n += t.song.beatsPerBar * p.partsPerBeat),
            0 != n) {
                switch (i) {
                case "wrapAround":
                    {
                        const e = p.partsPerBeat * t.song.beatsPerBar;
                        for (const i of t.song.channels)
                            for (const t of i.patterns) {
                                const i = [];
                                for (let s = 1; s >= 0; s--) {
                                    const o = s * e;
                                    for (const s of t.notes) {
                                        const t = s.start + n
                                          , a = s.end + n
                                          , r = Math.max(0, t - o)
                                          , h = Math.min(e, a - o);
                                        r < h && se(s, t - o - r, r, h, i)
                                    }
                                }
                                t.notes = i
                            }
                    }
                    break;
                case "overflow":
                    {
                        let i = t.song.barCount
                          , s = t.song.loopStart
                          , o = t.song.loopLength;
                        if (this.append(new pe(t,t.song.beatsPerBar,n)),
                        e < 0) {
                            let e = !0;
                            for (const i of t.song.channels)
                                0 != i.bars[0] && (e = !1);
                            if (e) {
                                for (const e of t.song.channels)
                                    e.bars.shift();
                                t.song.barCount--
                            } else
                                i++,
                                s++,
                                t.bar++
                        }
                        for (; t.song.barCount < i; ) {
                            for (const e of t.song.channels)
                                e.bars.push(0);
                            t.song.barCount++
                        }
                        t.song.loopStart = s,
                        t.song.loopLength = o
                    }
                    break;
                default:
                    throw new Error("Unrecognized beats-per-bar conversion strategy.")
                }
                t.notifier.changed(),
                this.Nt()
            }
        }
    }
    class en extends Zt {
        constructor(t, e, i) {
            if (super(),
            t.song.beatsPerBar != e) {
                switch (i) {
                case "splice":
                    if (t.song.beatsPerBar > e) {
                        const i = new Xt;
                        for (let n = 0; n < t.song.getChannelCount(); n++)
                            for (let s = 0; s < t.song.channels[n].patterns.length; s++)
                                i.append(new vn(t,t.song.channels[n].patterns[s],e * p.partsPerBeat,t.song.beatsPerBar * p.partsPerBeat,null,!0))
                    }
                    break;
                case "stretch":
                    {
                        const i = function(i) {
                            return Math.round(i * e / t.song.beatsPerBar)
                        };
                        for (let e = 0; e < t.song.getChannelCount(); e++)
                            for (let n = 0; n < t.song.channels[e].patterns.length; n++) {
                                const s = t.song.channels[e].patterns[n];
                                let o = 0;
                                for (; o < s.notes.length; ) {
                                    const e = s.notes[o];
                                    i(e.start) >= i(e.end) ? this.append(new gn(t,s,e,o,!0)) : (this.append(new Xi(t,e,i)),
                                    o++)
                                }
                            }
                        this.append(new mn(t,t.song.tempo,t.song.tempo * e / t.song.beatsPerBar))
                    }
                    break;
                case "overflow":
                    this.append(new pe(t,e,0)),
                    t.song.loopStart = 0,
                    t.song.loopLength = t.song.barCount;
                    break;
                default:
                    throw new Error("Unrecognized beats-per-bar conversion strategy.")
                }
                t.song.beatsPerBar = e,
                t.notifier.changed(),
                this.Nt()
            }
        }
    }
    class nn extends Zt {
        constructor(t, e) {
            super(),
            t.song.scale != e && (t.song.scale = e,
            t.notifier.changed(),
            this.Nt())
        }
    }
    class sn extends Zt {
        constructor(t) {
            super();
            const e = t.song
              , i = p.keys[e.key].basePitch
              , n = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
            for (let t = 0; t < e.pitchChannelCount; t++)
                for (let s = 0; s < e.barCount; s++) {
                    const o = e.getPattern(t, s);
                    if (null != o)
                        for (const t of o.notes) {
                            const e = t.pins[0];
                            for (let s = 1; s < t.pins.length; s++) {
                                const o = t.pins[s];
                                if (e.interval == o.interval) {
                                    let s = o.time - e.time;
                                    s += Math.max(0, Math.min(p.partsPerBeat, o.time + t.start) - (e.time + t.start)),
                                    s *= o.size + e.size;
                                    for (const o of t.pitches) {
                                        n[(i + e.interval + o) % 12] += s
                                    }
                                }
                            }
                        }
                }
            let s = 0
              , o = 0;
            for (let t = 0; t < 12; t++) {
                const e = n[t] * (3 * n[(t + 7) % 12] + n[(t + 4) % 12] + n[(t + 3) % 12]);
                o < e && (o = e,
                s = t)
            }
            if (s != e.key) {
                const i = e.key - s
                  , n = Math.abs(i);
                for (let s = 0; s < e.pitchChannelCount; s++)
                    for (const o of e.channels[s].patterns)
                        for (let e = 0; e < n; e++)
                            this.append(new Mn(t,s,o,i > 0,!0));
                e.key = s,
                t.notifier.changed(),
                this.Nt()
            }
        }
    }
    function on(t) {
        const e = [];
        for (let i = 0; i < N.presetCategories.length; i++) {
            const n = N.presetCategories[i];
            if ("Novelty Presets" != n.name)
                for (let s = 0; s < n.presets.length; s++) {
                    const o = n.presets[s];
                    null != o.settings && 1 == o.isNoise == t && e.push((i << 6) + s)
                }
        }
        return e[Math.random() * e.length | 0]
    }
    function an(t) {
        for (let e = 0; e < t.channels.length; e++)
            for (const i of t.channels[e].instruments) {
                const n = t.getChannelIsNoise(e)
                  , s = t.getChannelIsMod(e)
                  , o = e == t.pitchChannelCount ? N.nameToPresetValue(Math.random() > .5 ? "chip noise" : "standard drumset") : on(n)
                  , a = N.valueToPreset(o);
                i.fromJsonObject(a.settings, n, s, 0 == t.rhythm || 2 == t.rhythm, t.rhythm >= 2, 1),
                i.preset = o,
                i.effects |= 4
            }
    }
    class rn extends Zt {
        constructor(t, e, i="auto") {
            super();
            let n = t.song.pitchChannelCount
              , s = t.song.noiseChannelCount
              , o = t.song.modChannelCount;
            if (t.song.fromBase64String(e, i),
            n == t.song.pitchChannelCount && s == t.song.noiseChannelCount && o == t.song.modChannelCount || nt.resetColors(),
            "" == e) {
                this.append(new Fn(t,0,0)),
                t.selection.resetBoxSelection(),
                an(t.song),
                t.song.scale = t.prefs.defaultScale;
                for (let e = 0; e <= t.song.channels.length; e++)
                    t.viewedInstrument[e] = 0,
                    t.recentPatternInstruments[e] = [0];
                t.viewedInstrument.length = t.song.channels.length
            } else
                this.append(new hn(t));
            t.synth.computeLatestModValues(),
            t.notifier.changed(),
            this.Nt()
        }
    }
    class hn extends Yt {
        constructor(t) {
            super();
            const e = Math.min(t.channel, t.song.getChannelCount() - 1)
              , i = Math.max(0, Math.min(t.song.barCount - 1, t.bar));
            t.channel == e && t.bar == i || (t.bar = i,
            t.channel = e,
            this.Nt()),
            t.selection.scrollToSelectedPattern(),
            t.notifier.changed()
        }
    }
    class ln extends Zt {
        constructor(t, e, i, n) {
            super();
            const s = t.song;
            function o(t, e) {
                for (; t.length > e; ) {
                    let e = t.length - 1
                      , i = 0;
                    for (let n = 0; n < t.length - 1; n++) {
                        let s = 0;
                        for (const e of t[n].bars)
                            0 == e && s++;
                        s >= i && (e = n,
                        i = s)
                    }
                    t.splice(e, 1)
                }
            }
            for (o(e, p.pitchChannelCountMax),
            o(i, p.noiseChannelCountMax),
            o(n, p.modChannelCountMax); e.length < p.pitchChannelCountMin; )
                e.push(new _t);
            for (; i.length < p.noiseChannelCountMin; )
                i.push(new _t);
            for (; n.length < p.modChannelCountMin; )
                n.push(new _t);
            s.barCount = 1,
            s.patternsPerChannel = 8;
            const a = e.concat(i.concat(n));
            for (let t = 0; t < a.length; t++) {
                const e = a[t];
                s.barCount = Math.max(s.barCount, e.bars.length),
                s.patternsPerChannel = Math.max(s.patternsPerChannel, e.patterns.length),
                s.channels[t] = e
            }
            s.channels.length = a.length,
            s.pitchChannelCount = e.length,
            s.noiseChannelCount = i.length,
            s.modChannelCount = n.length,
            s.barCount = Math.min(p.barCountMax, s.barCount),
            s.patternsPerChannel = Math.min(p.barCountMax, s.patternsPerChannel);
            for (let t = 0; t < s.channels.length; t++) {
                const e = s.channels[t];
                for (let t = 0; t < e.bars.length; t++)
                    (e.bars[t] > s.patternsPerChannel || e.bars[t] < 0) && (e.bars[t] = 0);
                for (; e.bars.length < s.barCount; )
                    e.bars.push(0);
                e.bars.length = s.barCount,
                e.instruments.length > s.getMaxInstrumentsPerChannel() && (e.instruments.length = s.getMaxInstrumentsPerChannel());
                for (const i of e.patterns)
                    ee(i.instruments, s, t);
                for (; e.patterns.length < s.patternsPerChannel; )
                    e.patterns.push(new Pt);
                e.patterns.length = s.patternsPerChannel
            }
            s.loopStart = Math.max(0, Math.min(s.barCount - 1, s.loopStart)),
            s.loopLength = Math.min(s.barCount - s.loopStart, s.loopLength),
            this.append(new hn(t)),
            t.notifier.changed(),
            this.Nt(),
            nt.resetColors()
        }
    }
    function cn(t, e) {
        if (t.length != e.length)
            return !1;
        for (let i = 0; i < t.length; i++) {
            const n = t[i]
              , s = e[i];
            if (s.start != n.start || s.end != n.end || s.pitches.length != n.pitches.length || s.pins.length != n.pins.length)
                return !1;
            for (let t = 0; t < n.pitches.length; t++)
                if (s.pitches[t] != n.pitches[t])
                    return !1;
            for (let t = 0; t < n.pins.length; t++)
                if (s.pins[t].interval != n.pins[t].interval || s.pins[t].time != n.pins[t].time || s.pins[t].size != n.pins[t].size)
                    return !1
        }
        return !0
    }
    function dn(t) {
        for (const e of t) {
            const t = [];
            for (let i = 0; i < e.bars.length; i++) {
                if (0 == e.bars[i])
                    continue;
                const n = e.patterns[e.bars[i] - 1];
                let s = !1;
                for (let o = 0; o < t.length; o++) {
                    const a = t[o];
                    if (te(n.instruments, a.instruments) && a.notes.length == n.notes.length && cn(n.notes, a.notes)) {
                        s = !0,
                        e.bars[i] = o + 1;
                        break
                    }
                }
                s || (t.push(n),
                e.bars[i] = t.length)
            }
            for (let i = 0; i < t.length; i++)
                e.patterns[i] = t[i];
            e.patterns.length = t.length
        }
    }
    class pn extends Yt {
        constructor(t, e, i) {
            super(),
            t.song.octave = Math.max(p.octaveMin, Math.min(p.octaveMax, Math.round(i))),
            t.notifier.changed(),
            e != i && this.Nt()
        }
    }
    class mn extends Yt {
        constructor(t, e, i) {
            super(),
            t.song.tempo = Math.max(p.tempoMin, Math.min(p.tempoMax, Math.round(i))),
            t.synth.unsetMod(p.modulators.dictionary.tempo.index),
            t.notifier.changed(),
            e != i && this.Nt()
        }
    }
    class un extends Ze {
        constructor(t, e, i) {
            super(t),
            this.ne.echoDelay = i,
            t.synth.unsetMod(p.modulators.dictionary["echo delay"].index, t.channel, t.getCurrentInstrument()),
            t.notifier.changed(),
            e != i && this.Nt()
        }
    }
    class fn extends Ze {
        constructor(t, e, i) {
            super(t),
            this.ne.echoSustain = i,
            t.synth.unsetMod(p.modulators.dictionary.echo.index, t.channel, t.getCurrentInstrument()),
            t.notifier.changed(),
            e != i && this.Nt()
        }
    }
    class yn extends Ze {
        constructor(t, e, i) {
            super(t),
            this.ne.chorus = i,
            t.notifier.changed(),
            e != i && this.Nt()
        }
    }
    class bn extends Ze {
        constructor(t, e, i) {
            super(t),
            this.ne.reverb = i,
            t.synth.unsetMod(p.modulators.dictionary.reverb.index, t.channel, t.getCurrentInstrument()),
            t.notifier.changed(),
            e != i && this.Nt()
        }
    }
    class gn extends Qt {
        constructor(t, e, i, n, s=!1) {
            super(s),
            this.m = t,
            this.Le = e,
            this.Wt = i,
            this.dt = n,
            this.Nt(),
            this.redo()
        }
        $t() {
            this.Le.notes.splice(this.dt, 0, this.Wt),
            this.m.notifier.changed()
        }
        Ht() {
            this.Le.notes.splice(this.dt, 1),
            this.m.notifier.changed()
        }
    }
    class wn extends me {
        constructor(t, e, i, n) {
            super(t, e);
            const s = (this.jt < 0 || e.continuesLastPattern) && 0 == i;
            i -= this.jt,
            n -= this.jt;
            let o, a = !1, r = this.Yt[0].size, h = this.Yt[0].interval, l = !0;
            for (o = 0; o < this.Yt.length; o++) {
                const t = this.Yt[o];
                if (t.time < i)
                    r = t.size,
                    h = t.interval;
                else {
                    if (t.time > i && !a && (this.Qt.push(Et(h, i, r)),
                    a = !0),
                    !(t.time <= n))
                        break;
                    if (this.Qt.push(Et(t.interval, t.time, t.size)),
                    t.time == n) {
                        l = !1;
                        break
                    }
                }
            }
            l && this.Qt.push(Et(this.Yt[o].interval, n, this.Yt[o].size)),
            this.ie(s)
        }
    }
    class vn extends Xt {
        constructor(t, e, i, n, s=null, o=!1) {
            super();
            let a = 0;
            for (; a < e.notes.length; ) {
                const r = e.notes[a];
                if (r == s && null != s)
                    a++;
                else if (r.end <= i)
                    a++;
                else if (r.start >= n) {
                    if (!t.song.getChannelIsMod(t.channel))
                        break;
                    a++
                } else if (r.start < i && r.end > n) {
                    if (!t.song.getChannelIsMod(t.channel) || o || null != s && r.pitches[0] == s.pitches[0]) {
                        const s = r.clone();
                        this.append(new wn(t,r,r.start,i)),
                        a++,
                        this.append(new gn(t,e,s,a,!1)),
                        this.append(new wn(t,s,n,s.end))
                    }
                    a++
                } else
                    r.start < i ? ((!t.song.getChannelIsMod(t.channel) || o || null != s && r.pitches[0] == s.pitches[0]) && this.append(new wn(t,r,r.start,i)),
                    a++) : r.end > n ? ((!t.song.getChannelIsMod(t.channel) || o || null != s && r.pitches[0] == s.pitches[0]) && this.append(new wn(t,r,n,r.end)),
                    a++) : !t.song.getChannelIsMod(t.channel) || o || null != s && r.pitches[0] == s.pitches[0] ? this.append(new gn(t,e,r,a,!0)) : a++
            }
        }
    }
    class xn extends Xt {
        constructor(t, e) {
            super();
            let i = 0;
            for (; i < e.notes.length; ) {
                const n = e.notes[i];
                if (n.start < t.selection.patternSelectionStart && t.selection.patternSelectionStart < n.end) {
                    const s = n.clone();
                    this.append(new wn(t,n,n.start,t.selection.patternSelectionStart)),
                    i++,
                    this.append(new gn(t,e,s,i,!1)),
                    this.append(new wn(t,s,t.selection.patternSelectionStart,s.end))
                } else if (n.start < t.selection.patternSelectionEnd && t.selection.patternSelectionEnd < n.end) {
                    const s = n.clone();
                    this.append(new wn(t,n,n.start,t.selection.patternSelectionEnd)),
                    i++,
                    this.append(new gn(t,e,s,i,!1)),
                    this.append(new wn(t,s,t.selection.patternSelectionEnd,s.end)),
                    i++
                } else
                    i++
            }
        }
    }
    class kn extends Qt {
        constructor(t, e, i, n, s=!1, o=!1) {
            super(!1),
            this.m = t,
            this.Wt = i,
            this.Yt = i.pins,
            this.Qt = [],
            this.Zt = i.pitches,
            this.Xt = [];
            const a = t.song.getChannelIsNoise(e);
            if (a != t.song.getChannelIsNoise(t.channel))
                return;
            if (t.song.getChannelIsMod(t.channel))
                return;
            const r = a ? p.drumCount - 1 : p.maxPitch;
            for (let e = 0; e < this.Zt.length; e++) {
                let i = this.Zt[e];
                if (o && !a)
                    i = n ? Math.min(r, i + 12) : Math.max(0, i - 12);
                else {
                    let e = t.song.scale == p.scales.dictionary.Custom.index ? t.song.scaleCustom : p.scales[t.song.scale].flags;
                    if (n) {
                        for (let t = i + 1; t <= r; t++)
                            if (a || s || e[t % 12]) {
                                i = t;
                                break
                            }
                    } else
                        for (let t = i - 1; t >= 0; t--)
                            if (a || s || e[t % 12]) {
                                i = t;
                                break
                            }
                }
                let h = !1;
                for (let t = 0; t < this.Xt.length; t++)
                    if (this.Xt[t] == i) {
                        h = !0;
                        break
                    }
                h || this.Xt.push(i)
            }
            let h = 0
              , l = r;
            for (let t = 1; t < this.Xt.length; t++) {
                const e = this.Xt[0] - this.Xt[t];
                h < e && (h = e),
                l > e + r && (l = e + r)
            }
            for (const e of this.Yt) {
                let i = e.interval + this.Zt[0];
                if (i < h && (i = h),
                i > l && (i = l),
                o && !a)
                    i = n ? Math.min(l, i + 12) : Math.max(h, i - 12);
                else {
                    let e = t.song.scale == p.scales.dictionary.Custom.index ? t.song.scaleCustom : p.scales[t.song.scale].flags;
                    if (n) {
                        for (let t = i + 1; t <= l; t++)
                            if (a || s || e[t % 12]) {
                                i = t;
                                break
                            }
                    } else
                        for (let t = i - 1; t >= h; t--)
                            if (a || s || e[t % 12]) {
                                i = t;
                                break
                            }
                }
                i -= this.Xt[0],
                this.Qt.push(Et(i, e.time, e.size))
            }
            if (0 != this.Qt[0].interval)
                throw new Error("wrong pin start interval");
            for (let t = 1; t < this.Qt.length - 1; )
                this.Qt[t - 1].interval == this.Qt[t].interval && this.Qt[t].interval == this.Qt[t + 1].interval && this.Qt[t - 1].size == this.Qt[t].size && this.Qt[t].size == this.Qt[t + 1].size ? this.Qt.splice(t, 1) : t++;
            this.$t(),
            this.Nt()
        }
        $t() {
            this.Wt.pins = this.Qt,
            this.Wt.pitches = this.Xt,
            this.m.notifier.changed()
        }
        Ht() {
            this.Wt.pins = this.Yt,
            this.Wt.pitches = this.Zt,
            this.m.notifier.changed()
        }
    }
    class Mn extends Xt {
        constructor(t, e, i, n, s=!1, o=!1) {
            super(),
            t.selection.patternSelectionActive && this.append(new xn(t,i));
            for (const a of i.notes)
                t.selection.patternSelectionActive && (a.end <= t.selection.patternSelectionStart || a.start >= t.selection.patternSelectionEnd) || this.append(new kn(t,e,a,n,s,o))
        }
    }
    class Sn extends Yt {
        constructor(t, e, i, n, s) {
            super(),
            t.selection.boxSelectionX0 = e,
            t.selection.boxSelectionX1 = i,
            t.selection.boxSelectionY0 = n,
            t.selection.boxSelectionY1 = s,
            t.notifier.changed(),
            this.Nt()
        }
    }
    class Fn extends Qt {
        constructor(t, e, i) {
            super(!1),
            this.m = t,
            this.jt = t.selection.patternSelectionStart,
            this.Ut = t.selection.patternSelectionEnd,
            this.De = t.selection.patternSelectionActive,
            this.Kt = e,
            this.Jt = i,
            this.ze = e < i,
            this.$t(),
            this.Nt()
        }
        $t() {
            this.m.selection.patternSelectionStart = this.Kt,
            this.m.selection.patternSelectionEnd = this.Jt,
            this.m.selection.patternSelectionActive = this.ze,
            this.m.notifier.changed()
        }
        Ht() {
            this.m.selection.patternSelectionStart = this.jt,
            this.m.selection.patternSelectionEnd = this.Ut,
            this.m.selection.patternSelectionActive = this.De,
            this.m.notifier.changed()
        }
    }
    class Cn extends Xt {
        constructor(t, e, i, n, s) {
            if (super(),
            0 == n && 0 == s)
                return;
            t.selection.patternSelectionActive && this.append(new xn(t,i));
            const o = t.selection.patternSelectionStart
              , a = t.selection.patternSelectionEnd
              , r = Math.max(0, Math.min(t.song.beatsPerBar * p.partsPerBeat, o + n))
              , h = Math.max(0, Math.min(t.song.beatsPerBar * p.partsPerBeat, a + n));
            r == h ? this.append(new vn(t,i,o,a,null,!0)) : n < 0 ? this.append(new vn(t,i,r,Math.min(o, h),null,!0)) : this.append(new vn(t,i,Math.max(a, r),h,null,!0)),
            this.append(new Fn(t,r,h));
            const l = [];
            let c = 0
              , d = 0;
            for (; d < i.notes.length; ) {
                const e = i.notes[d];
                e.end <= o || e.start >= a ? (d++,
                e.end <= r && (c = d)) : (l.push(e.clone()),
                this.append(new gn(t,i,e,d,!0)))
            }
            for (const o of l)
                if (o.start += n,
                o.end += n,
                !(o.end <= r || o.start >= h)) {
                    this.append(new gn(t,i,o,c++,!1)),
                    this.append(new wn(t,o,Math.max(o.start, r),Math.min(h, o.end)));
                    for (let i = 0; i < Math.abs(s); i++)
                        this.append(new kn(t,e,o,s > 0,t.prefs.notesOutsideScale))
                }
        }
    }
    class An extends Yt {
        constructor(t, e, i, n) {
            super(),
            this.storedChange = e,
            this.storedValues = i,
            this.storedSlider = n,
            this.Nt()
        }
    }
    class En extends Zt {
        constructor(t, e, i, n, s) {
            super();
            for (let o = n; o < n + s; o++) {
                const n = {};
                for (let s = e; s < e + i; s++) {
                    const a = t.song.channels[o].bars[s];
                    if (0 != a) {
                        if (null == n[String(a)]) {
                            let r = !1;
                            for (let n = 0; n < t.song.barCount; n++)
                                if ((n < e || n >= e + i) && t.song.channels[o].bars[n] == a) {
                                    r = !0;
                                    break
                                }
                            if (r) {
                                const e = t.song.getPattern(o, s);
                                this.append(new ve(t,0,s,o,1,1)),
                                this.append(new Ji(t,o,s));
                                const i = t.song.getPattern(o, s);
                                if (null == i)
                                    throw new Error;
                                this.append(new $i(t,i,e.notes,0,p.partsPerBeat * t.song.beatsPerBar,p.partsPerBeat * t.song.beatsPerBar)),
                                i.instruments.length = 0,
                                i.instruments.push(...e.instruments),
                                n[String(a)] = t.song.channels[o].bars[s]
                            } else
                                n[String(a)] = a
                        }
                        this.append(new ve(t,n[String(a)],s,o,1,1))
                    }
                }
            }
        }
    }
    class Tn extends Yt {
        constructor(t, e, i) {
            super(),
            t.selection.patternSelectionActive && new xn(t,e);
            const n = p.maxPitch;
            for (const s of e.notes) {
                if (t.selection.patternSelectionActive && (s.end <= t.selection.patternSelectionStart || s.start >= t.selection.patternSelectionEnd))
                    continue;
                const e = []
                  , o = [];
                for (let t = 0; t < s.pitches.length; t++) {
                    const n = s.pitches[t]
                      , o = i[n % 12] + (n - n % 12);
                    -1 == e.indexOf(o) && e.push(o)
                }
                let a = 0
                  , r = n;
                for (let t = 1; t < e.length; t++) {
                    const i = e[0] - e[t];
                    a < i && (a = i),
                    r > i + n && (r = i + n)
                }
                for (const t of s.pins) {
                    let n = t.interval + s.pitches[0];
                    n < a && (n = a),
                    n > r && (n = r);
                    const h = i[n % 12] + (n - n % 12);
                    o.push(Et(h - e[0], t.time, t.size))
                }
                if (0 != o[0].interval)
                    throw new Error("wrong pin start interval");
                for (let t = 1; t < o.length - 1; )
                    o[t - 1].interval == o[t].interval && o[t].interval == o[t + 1].interval && o[t - 1].size == o[t].size && o[t].size == o[t + 1].size ? o.splice(t, 1) : t++;
                s.pitches = e,
                s.pins = o
            }
            this.Nt(),
            t.notifier.changed()
        }
    }
    class Pn extends Yt {
        constructor(t, e, i) {
            super(),
            t.song.channels[t.channel].instruments[t.getCurrentInstrument()].volume = i,
            t.notifier.changed(),
            e != i && this.Nt()
        }
    }
    class Bn extends Yt {
        constructor(t, e, i) {
            super(),
            i.length > 30 && (i = i.substring(0, 30)),
            t.song.title = i,
            document.title = i + " - " + N.versionDisplayName,
            t.notifier.changed(),
            e != i && this.Nt()
        }
    }
    class In extends Yt {
        constructor(t, e, i) {
            super(),
            i.length > 15 && (i = i.substring(0, 15)),
            t.song.channels[t.muteEditorChannel].name = i,
            t.recalcChannelNames = !0,
            t.notifier.changed(),
            e != i && this.Nt()
        }
    }
    class Ln extends Yt {
        constructor(t, e, i) {
            super(),
            t.song.channels[t.channel].instruments[t.getCurrentInstrument()].pan = i,
            t.synth.unsetMod(p.modulators.dictionary.pan.index, t.channel, t.getCurrentInstrument()),
            t.notifier.changed(),
            e != i && this.Nt()
        }
    }
    class Dn extends Yt {
        constructor(t, e, i) {
            super(),
            t.song.channels[t.channel].instruments[t.getCurrentInstrument()].panDelay = i,
            t.notifier.changed(),
            e != i && this.Nt()
        }
    }
    class zn extends Qt {
        constructor(t, e, i, n, s, o) {
            super(!1),
            this.m = t,
            this.Wt = e,
            this.Yt = e.pins,
            this.Qt = [];
            let a = !1;
            for (const t of e.pins)
                t.time < i ? o ? this.Qt.push(Et(t.interval, t.time, n)) : this.Qt.push(t) : t.time == i ? (this.Qt.push(Et(s, i, n)),
                a = !0) : (o || a || (this.Qt.push(Et(s, i, n)),
                a = !0),
                o ? this.Qt.push(Et(t.interval, t.time, n)) : this.Qt.push(t));
            ne(this.Qt),
            this.$t(),
            this.Nt()
        }
        $t() {
            this.Wt.pins = this.Qt,
            this.m.notifier.changed()
        }
        Ht() {
            this.Wt.pins = this.Yt,
            this.m.notifier.changed()
        }
    }
    class qn extends Yt {
        constructor(t, e) {
            super();
            const i = t.song.channels[t.channel].instruments[t.getCurrentInstrument()];
            i.chipWave != e && (i.chipWave = e,
            i.isUsingAdvancedLoopControls = !1,
            i.chipWaveLoopStart = 0,
            i.chipWaveLoopEnd = p.rawRawChipWaves[i.chipWave].samples.length - 1,
            i.chipWaveLoopMode = 0,
            i.chipWavePlayBackwards = !1,
            i.chipWaveStartOffset = 0,
            i.preset = i.type,
            t.notifier.changed(),
            this.Nt())
        }
    }
    class Nn extends Yt {
        constructor(t, e) {
            super();
            const i = t.song.channels[t.channel].instruments[t.getCurrentInstrument()];
            i.isUsingAdvancedLoopControls != e && (i.isUsingAdvancedLoopControls = e,
            i.chipWaveLoopStart = 0,
            i.chipWaveLoopEnd = p.rawRawChipWaves[i.chipWave].samples.length - 1,
            i.chipWaveLoopMode = 0,
            i.chipWavePlayBackwards = !1,
            i.chipWaveStartOffset = 0,
            i.preset = i.type,
            t.notifier.changed(),
            this.Nt())
        }
    }
    class On extends Yt {
        constructor(t, e) {
            super();
            const i = t.song.channels[t.channel].instruments[t.getCurrentInstrument()];
            i.chipWaveLoopMode != e && (i.isUsingAdvancedLoopControls = !0,
            i.chipWaveLoopMode = e,
            i.preset = i.type,
            t.notifier.changed(),
            this.Nt())
        }
    }
    class Rn extends Yt {
        constructor(t, e) {
            super();
            const i = t.song.channels[t.channel].instruments[t.getCurrentInstrument()];
            i.chipWaveLoopStart != e && (i.isUsingAdvancedLoopControls = !0,
            i.chipWaveLoopStart = e,
            i.preset = i.type,
            t.notifier.changed(),
            this.Nt())
        }
    }
    class $n extends Yt {
        constructor(t, e) {
            super();
            const i = t.song.channels[t.channel].instruments[t.getCurrentInstrument()];
            i.chipWaveLoopEnd != e && (i.isUsingAdvancedLoopControls = !0,
            i.chipWaveLoopEnd = e,
            i.chipWaveLoopStart = Math.max(0, Math.min(e - 1, i.chipWaveLoopStart)),
            i.preset = i.type,
            t.notifier.changed(),
            this.Nt())
        }
    }
    class Hn extends Yt {
        constructor(t, e) {
            super();
            const i = t.song.channels[t.channel].instruments[t.getCurrentInstrument()];
            i.chipWaveStartOffset != e && (i.isUsingAdvancedLoopControls = !0,
            i.chipWaveStartOffset = e,
            i.preset = i.type,
            t.notifier.changed(),
            this.Nt())
        }
    }
    class _n extends Yt {
        constructor(t, e) {
            super();
            const i = t.song.channels[t.channel].instruments[t.getCurrentInstrument()];
            i.chipWavePlayBackwards != e && (i.isUsingAdvancedLoopControls = !0,
            i.chipWavePlayBackwards = e,
            i.preset = i.type,
            t.notifier.changed(),
            this.Nt())
        }
    }
    class Vn extends Yt {
        constructor(t, e) {
            super();
            const i = t.song.channels[t.channel].instruments[t.getCurrentInstrument()];
            i.chipNoise != e && (i.chipNoise = e,
            i.preset = i.type,
            t.notifier.changed(),
            this.Nt())
        }
    }
    class Gn extends Yt {
        constructor(t) {
            super();
            const e = t.song.channels[t.channel].instruments[t.getCurrentInstrument()];
            e.addEnvelope(0, 0, 0),
            e.preset = e.type,
            t.notifier.changed(),
            this.Nt()
        }
    }
    class Wn extends Yt {
        constructor(t, e) {
            super();
            const i = t.song.channels[t.channel].instruments[t.getCurrentInstrument()];
            i.envelopeCount--;
            for (let t = e; t < i.envelopeCount; t++)
                i.envelopes[t].target = i.envelopes[t + 1].target,
                i.envelopes[t].index = i.envelopes[t + 1].index,
                i.envelopes[t].envelope = i.envelopes[t + 1].envelope;
            i.preset = i.type,
            t.notifier.changed(),
            this.Nt()
        }
    }
    class jn extends Yt {
        constructor(t, e, i, n) {
            super();
            const s = t.song.channels[t.channel].instruments[t.getCurrentInstrument()]
              , o = s.envelopes[e].target
              , a = s.envelopes[e].index;
            o == i && a == n || (s.envelopes[e].target = i,
            s.envelopes[e].index = n,
            s.preset = s.type,
            t.notifier.changed(),
            this.Nt())
        }
    }
    class Un extends Yt {
        constructor(t, e, i) {
            super();
            const n = t.song.channels[t.channel].instruments[t.getCurrentInstrument()];
            n.envelopes[e].envelope != i && (n.envelopes[e].envelope = i,
            n.preset = n.type,
            t.notifier.changed(),
            this.Nt())
        }
    }
    const {button: Kn, div: Jn, span: Yn, h2: Qn, input: Zn, br: Xn, select: ts, option: es} = J;
    class is {
        constructor(t) {
            this.m = t,
            this.qe = Zn({
                style: "width: 3em; margin-left: 1em;",
                type: "number",
                step: "1"
            }),
            this.Ne = ts({
                style: "width: 100%;"
            }, es({
                value: "splice"
            }, "Splice beats at end of bars."), es({
                value: "stretch"
            }, "Stretch notes to fit in bars."), es({
                value: "overflow"
            }, "Overflow notes across bars.")),
            this.Oe = Kn({
                class: "cancelButton"
            }),
            this.Re = Kn({
                class: "okayButton",
                style: "width:45%;"
            }, "Okay"),
            this.container = Jn({
                class: "prompt noSelection",
                style: "width: 250px;"
            }, Qn("Beats Per Bar"), Jn({
                style: "display: flex; flex-direction: row; align-items: center; height: 2em; justify-content: flex-end;"
            }, Jn({
                style: "text-align: right;"
            }, "Beats per bar:", Xn(), Yn({
                style: "font-size: smaller; color: ${ColorConfig.secondaryText};"
            }, "(Multiples of 3 or 4 are recommended)")), this.qe), Jn({
                style: "display: flex; flex-direction: row; align-items: center; height: 2em; justify-content: flex-end;"
            }, Jn({
                class: "selectContainer",
                style: "width: 100%;"
            }, this.Ne)), Jn({
                style: "display: flex; flex-direction: row-reverse; justify-content: space-between;"
            }, this.Re), this.Oe),
            this.$e = () => {
                this.m.undo()
            }
            ,
            this.cleanUp = () => {
                this.Re.removeEventListener("click", this.He),
                this.Oe.removeEventListener("click", this.$e),
                this.qe.removeEventListener("keypress", is._e),
                this.qe.removeEventListener("blur", is.Ve),
                this.container.removeEventListener("keydown", this.Ge)
            }
            ,
            this.Ge = t => {
                "BUTTON" != t.target.tagName && 13 == t.keyCode && this.He()
            }
            ,
            this.He = () => {
                window.localStorage.setItem("beatCountStrategy", this.Ne.value),
                this.m.prompt = null,
                this.m.record(new en(this.m,is.We(this.qe),this.Ne.value), !0)
            }
            ,
            this.qe.value = this.m.song.beatsPerBar + "",
            this.qe.min = p.beatsPerBarMin + "",
            this.qe.max = p.beatsPerBarMax + "";
            const e = window.localStorage.getItem("beatCountStrategy");
            null != e && (this.Ne.value = e),
            this.qe.select(),
            setTimeout(( () => this.qe.focus())),
            this.Re.addEventListener("click", this.He),
            this.Oe.addEventListener("click", this.$e),
            this.qe.addEventListener("keypress", is._e),
            this.qe.addEventListener("blur", is.Ve),
            this.container.addEventListener("keydown", this.Ge)
        }
        static _e(t) {
            const e = t.which ? t.which : t.keyCode;
            return 46 != e && e > 31 && (e < 48 || e > 57) && (t.preventDefault(),
            !0)
        }
        static Ve(t) {
            const e = t.target;
            e.value = String(is.We(e))
        }
        static We(t) {
            return Math.floor(Math.max(Number(t.min), Math.min(Number(t.max), Number(t.value))))
        }
    }
    const {button: ns, div: ss, label: os, br: as, h2: rs, input: hs} = J;
    class ls {
        constructor(t) {
            this.m = t,
            this.je = hs({
                style: "width: 3em; margin-left: 1em;",
                type: "number",
                step: "1"
            }),
            this.Ue = hs({
                style: "width: 3em; margin-left: 1em;",
                type: "number",
                step: "1"
            }),
            this.Ke = hs({
                style: "width: 3em; margin-left: 1em;",
                type: "number",
                step: "1"
            }),
            this.Je = hs({
                style: "width: 3em; margin-left: 1em;",
                type: "number",
                step: "1"
            }),
            this.Ye = hs({
                style: "width: 3em; margin-left: 1em;",
                type: "checkbox"
            }),
            this.Qe = hs({
                style: "width: 3em; margin-left: 1em;",
                type: "checkbox"
            }),
            this.Oe = ns({
                class: "cancelButton"
            }),
            this.Re = ns({
                class: "okayButton",
                style: "width:45%;"
            }, "Okay"),
            this.container = ss({
                class: "prompt noSelection",
                style: "width: 250px; text-align: right;"
            }, rs("Channel Settings"), os({
                style: "display: flex; flex-direction: row; align-items: center; height: 2em; justify-content: flex-end;"
            }, "Pitch channels:", this.Ue), os({
                style: "display: flex; flex-direction: row; align-items: center; height: 2em; justify-content: flex-end;"
            }, "Drum channels:", this.Ke), ss({
                style: "display: flex; flex-direction: row; align-items: center; height: 2em; justify-content: flex-end;"
            }, "Mod channels:", this.Je), os({
                style: "display: flex; flex-direction: row; align-items: center; height: 2em; justify-content: flex-end;"
            }, "Available patterns per channel:", this.je), os({
                style: "display: flex; flex-direction: row; align-items: center; height: 2em; justify-content: flex-end;"
            }, "Simultaneous instruments", as(), "per channel:", this.Ye), os({
                style: "display: flex; flex-direction: row; align-items: center; height: 2em; justify-content: flex-end;"
            }, "Different instruments", as(), "per pattern:", this.Qe), ss({
                style: "display: flex; flex-direction: row-reverse; justify-content: space-between;"
            }, this.Re), this.Oe),
            this.$e = () => {
                this.m.undo()
            }
            ,
            this.cleanUp = () => {
                this.Re.removeEventListener("click", this.He),
                this.Oe.removeEventListener("click", this.$e),
                this.je.removeEventListener("keypress", ls._e),
                this.Ue.removeEventListener("keypress", ls._e),
                this.Ke.removeEventListener("keypress", ls._e),
                this.Je.removeEventListener("keypress", ls._e),
                this.je.removeEventListener("blur", this.Ve),
                this.Ue.removeEventListener("blur", this.Ve),
                this.Ke.removeEventListener("blur", this.Ve),
                this.Je.removeEventListener("blur", this.Ve),
                this.container.removeEventListener("keydown", this.Ge)
            }
            ,
            this.Ge = t => {
                "BUTTON" != t.target.tagName && 13 == t.keyCode && this.He()
            }
            ,
            this.Ve = t => {
                const e = t.target;
                e.value = String(ls.We(e))
            }
            ,
            this.He = () => {
                const t = new Zt;
                t.append(new Di(this.m,this.Ye.checked,this.Qe.checked)),
                t.append(new Ki(this.m,ls.We(this.je))),
                t.append(new Ae(this.m,ls.We(this.Ue),ls.We(this.Ke),ls.We(this.Je))),
                this.m.prompt = null,
                this.m.record(t, !0)
            }
            ,
            this.je.value = this.m.song.patternsPerChannel + "",
            this.je.min = "1",
            this.je.max = p.barCountMax + "",
            this.Ue.value = this.m.song.pitchChannelCount + "",
            this.Ue.min = p.pitchChannelCountMin + "",
            this.Ue.max = p.pitchChannelCountMax + "",
            this.Ke.value = this.m.song.noiseChannelCount + "",
            this.Ke.min = p.noiseChannelCountMin + "",
            this.Ke.max = p.noiseChannelCountMax + "",
            this.Je.value = this.m.song.modChannelCount + "",
            this.Je.min = p.modChannelCountMin + "",
            this.Je.max = p.modChannelCountMax + "",
            this.Ye.checked = this.m.song.layeredInstruments,
            this.Qe.checked = this.m.song.patternInstruments,
            this.Ue.select(),
            setTimeout(( () => this.Ue.focus())),
            this.Re.addEventListener("click", this.He),
            this.Oe.addEventListener("click", this.$e),
            this.je.addEventListener("keypress", ls._e),
            this.Ue.addEventListener("keypress", ls._e),
            this.Ke.addEventListener("keypress", ls._e),
            this.Je.addEventListener("keypress", ls._e),
            this.je.addEventListener("blur", this.Ve),
            this.Ue.addEventListener("blur", this.Ve),
            this.Ke.addEventListener("blur", this.Ve),
            this.Je.addEventListener("blur", this.Ve),
            this.container.addEventListener("keydown", this.Ge)
        }
        static _e(t) {
            const e = t.which ? t.which : t.keyCode;
            return 46 != e && e > 31 && (e < 48 || e > 57) && (t.preventDefault(),
            !0)
        }
        static We(t) {
            return Math.floor(Math.max(Number(t.min), Math.min(Number(t.max), Number(t.value))))
        }
    }
    const {button: cs, div: ds, h2: ps} = J;
    class ms {
        constructor(t) {
            this.N = 0,
            this.Ze = 0,
            this.Xe = 0,
            this.ti = 0,
            this.O = !1,
            this.chipData = new Float32Array(64),
            this.startingChipData = new Float32Array(64),
            this.ei = 0,
            this.ii = [],
            this.u = 768,
            this.v = 294,
            this.ni = Y.path({
                fill: nt.uiWidgetBackground,
                "pointer-events": "none"
            }),
            this.si = Y.svg({
                "pointer-events": "none"
            }),
            this.oi = Y.svg({
                "pointer-events": "none"
            }),
            this.ai = Y.svg({
                "pointer-events": "none"
            }),
            this.q = Y.svg({
                style: `background-color: ${nt.editorBackground}; touch-action: none; overflow: visible;`,
                width: "100%",
                height: "100%",
                viewBox: "0 0 " + this.u + " " + this.v,
                preserveAspectRatio: "none"
            }, this.ni, this.si, this.oi, this.ai),
            this.container = J.div({
                class: "",
                style: "height: 294px; width: 768px; padding-bottom: 1.5em;"
            }, this.q),
            this.ri = () => {
                var t = !0;
                if (this.ii.length > 0)
                    for (var e = 0; e < 64; e++)
                        this.ii[this.ei][e] != this.chipData[e] && (t = !1,
                        e = 64);
                0 != t && 0 != this.ii.length || (this.ii.splice(0, this.ei),
                this.ei = 0,
                this.ii.unshift(this.chipData.slice()),
                this.ii.length > 32 && this.ii.pop())
            }
            ,
            this.undo = () => {
                this.ei < this.ii.length - 1 && (this.ei++,
                this.chipData = this.ii[this.ei].slice(),
                new ue(this.m,this.chipData),
                this.render())
            }
            ,
            this.redo = () => {
                this.ei > 0 && (this.ei--,
                this.chipData = this.ii[this.ei].slice(),
                new ue(this.m,this.chipData),
                this.render())
            }
            ,
            this.Ge = t => {
                90 == t.keyCode ? (this.undo(),
                t.stopPropagation()) : 89 == t.keyCode && (this.redo(),
                t.stopPropagation())
            }
            ,
            this.K = t => {
                t.preventDefault(),
                this.O = !0;
                const e = this.q.getBoundingClientRect();
                this.N = ((t.clientX || t.pageX) - e.left) * this.u / (e.right - e.left),
                this.Ze = ((t.clientY || t.pageY) - e.top) * this.v / (e.bottom - e.top),
                isNaN(this.N) && (this.N = 0),
                isNaN(this.Ze) && (this.Ze = 0),
                this.Xe = -1,
                this.X()
            }
            ,
            this.Y = t => {
                t.preventDefault(),
                this.O = !0;
                const e = this.q.getBoundingClientRect();
                this.N = (t.touches[0].clientX - e.left) * this.u / (e.right - e.left),
                this.Ze = (t.touches[0].clientY - e.top) * this.v / (e.bottom - e.top),
                isNaN(this.N) && (this.N = 0),
                isNaN(this.Ze) && (this.Ze = 0),
                this.Xe = -1,
                this.X()
            }
            ,
            this.Z = t => {
                if (null == this.container.offsetParent)
                    return;
                const e = this.q.getBoundingClientRect();
                this.N = ((t.clientX || t.pageX) - e.left) * this.u / (e.right - e.left),
                this.Ze = ((t.clientY || t.pageY) - e.top) * this.v / (e.bottom - e.top),
                isNaN(this.N) && (this.N = 0),
                isNaN(this.Ze) && (this.Ze = 0),
                this.X()
            }
            ,
            this.tt = t => {
                if (null == this.container.offsetParent)
                    return;
                if (!this.O)
                    return;
                t.preventDefault();
                const e = this.q.getBoundingClientRect();
                this.N = (t.touches[0].clientX - e.left) * this.u / (e.right - e.left),
                this.Ze = (t.touches[0].clientY - e.top) * this.v / (e.bottom - e.top),
                isNaN(this.N) && (this.N = 0),
                isNaN(this.Ze) && (this.Ze = 0),
                this.X()
            }
            ,
            this.et = t => {
                this.ri(),
                this.O = !1
            }
            ,
            this.m = t;
            for (let t = 0; t <= 4; t += 2)
                this.si.appendChild(Y.rect({
                    fill: nt.tonic,
                    x: t * this.u / 4 - 1,
                    y: 0,
                    width: 2,
                    height: this.v
                }));
            for (let t = 1; t <= 8; t++)
                this.oi.appendChild(Y.rect({
                    fill: nt.fifthNote,
                    x: t * this.u / 8 - 1,
                    y: 0,
                    width: 1,
                    height: this.v
                }));
            this.si.appendChild(Y.rect({
                fill: nt.tonic,
                x: 0,
                y: this.v / 2 - 1,
                width: this.u,
                height: 2
            }));
            for (let t = 0; t < 3; t++)
                this.oi.appendChild(Y.rect({
                    fill: nt.fifthNote,
                    x: 0,
                    y: 8 * t * (this.v / 49),
                    width: this.u,
                    height: 1
                })),
                this.oi.appendChild(Y.rect({
                    fill: nt.fifthNote,
                    x: 0,
                    y: this.v - 1 - 8 * t * (this.v / 49),
                    width: this.u,
                    height: 1
                }));
            let e = nt.getChannelColor(this.m.song, this.m.channel).primaryNote;
            for (let t = 0; t <= 64; t++) {
                let i = this.m.song.channels[this.m.channel].instruments[this.m.getCurrentInstrument()].customChipWave[t];
                this.chipData[t] = i,
                this.startingChipData[t] = i,
                this.ai.appendChild(Y.rect({
                    fill: e,
                    x: t * this.u / 64,
                    y: (i + 24) * (this.v / 49),
                    width: this.u / 64,
                    height: this.v / 49
                }))
            }
            this.ri(),
            this.container.addEventListener("mousedown", this.K),
            document.addEventListener("mousemove", this.Z),
            document.addEventListener("mouseup", this.et),
            this.container.addEventListener("touchstart", this.Y),
            this.container.addEventListener("touchmove", this.tt),
            this.container.addEventListener("touchend", this.et),
            this.container.addEventListener("touchcancel", this.et),
            this.q.addEventListener("keydown", this.Ge),
            this.container.addEventListener("keydown", this.Ge)
        }
        X() {
            if (this.O) {
                const o = Math.min(63, Math.max(0, Math.floor(64 * this.N / this.u)))
                  , a = Math.min(48, Math.max(0, Math.floor(49 * this.Ze / this.v)));
                if (-1 != this.Xe && this.Xe != o) {
                    var t = o
                      , e = this.Xe
                      , i = a
                      , n = this.ti;
                    this.Xe < o && (t = this.Xe,
                    e = o,
                    i = this.ti,
                    n = a);
                    for (var s = t; s <= e; s++) {
                        const o = Math.round(i + (s - t) / (e - t) * (n - i));
                        this.chipData[s] = o - 24,
                        this.ai.children[s].setAttribute("y", "" + o * (this.v / 49))
                    }
                } else
                    this.chipData[o] = a - 24,
                    this.ai.children[o].setAttribute("y", "" + a * (this.v / 49));
                new ue(this.m,this.chipData),
                this.Xe = o,
                this.ti = a
            }
        }
        render() {
            for (var t = 0; t < 64; t++)
                this.ai.children[t].setAttribute("y", "" + (this.chipData[t] + 24) * (this.v / 49))
        }
    }
    class us {
        constructor(t, e) {
            this.m = t,
            this.hi = e,
            this.customChipCanvas = new ms(this.m),
            this.ci = cs({
                style: "width: 55%;",
                type: "button"
            }),
            this.Oe = cs({
                class: "cancelButton"
            }),
            this.Re = cs({
                class: "okayButton",
                style: "width:45%;"
            }, "Okay"),
            this.copyButton = cs({
                style: "width:86px; margin-right: 5px;",
                class: "copyButton"
            }, ["Copy", Y.svg({
                style: "flex-shrink: 0; position: absolute; left: 0; top: 50%; margin-top: -1em; pointer-events: none;",
                width: "2em",
                height: "2em",
                viewBox: "-5 -21 26 26"
            }, [Y.path({
                d: "M 0 -15 L 1 -15 L 1 0 L 13 0 L 13 1 L 0 1 L 0 -15 z M 2 -1 L 2 -17 L 10 -17 L 14 -13 L 14 -1 z M 3 -2 L 13 -2 L 13 -12 L 9 -12 L 9 -16 L 3 -16 z",
                fill: "currentColor"
            })])]),
            this.pasteButton = cs({
                style: "width:86px;",
                class: "pasteButton"
            }, ["Paste", Y.svg({
                style: "flex-shrink: 0; position: absolute; left: 0; top: 50%; margin-top: -1em; pointer-events: none;",
                width: "2em",
                height: "2em",
                viewBox: "0 0 26 26"
            }, [Y.path({
                d: "M 8 18 L 6 18 L 6 5 L 17 5 L 17 7 M 9 8 L 16 8 L 20 12 L 20 22 L 9 22 z",
                stroke: "currentColor",
                fill: "none"
            }), Y.path({
                d: "M 9 3 L 14 3 L 14 6 L 9 6 L 9 3 z M 16 8 L 20 12 L 16 12 L 16 8 z",
                fill: "currentColor"
            })])]),
            this.copyPasteContainer = ds({
                style: "width: 185px;"
            }, this.copyButton, this.pasteButton),
            this.container = ds({
                class: "prompt noSelection",
                style: "width: 600px;"
            }, ps("Edit Custom Chip Instrument"), ds({
                style: "display: flex; width: 55%; align-self: center; flex-direction: row; align-items: center; justify-content: center;"
            }, this.ci), ds({
                style: "display: flex; flex-direction: row; align-items: center; justify-content: center;"
            }, this.customChipCanvas.container), ds({
                style: "display: flex; flex-direction: row-reverse; justify-content: space-between;"
            }, this.Re, this.copyPasteContainer), this.Oe),
            this.di = () => {
                this.hi.togglePlay(),
                this.updatePlayButton()
            }
            ,
            this.$e = () => {
                this.m.prompt = null,
                this.m.undo()
            }
            ,
            this.cleanUp = () => {
                this.Re.removeEventListener("click", this.He),
                this.Oe.removeEventListener("click", this.$e),
                this.container.removeEventListener("keydown", this.whenKeyPressed),
                this.ci.removeEventListener("click", this.di)
            }
            ,
            this.pi = () => {
                const t = this.customChipCanvas.chipData;
                window.localStorage.setItem("chipCopy", JSON.stringify(Array.from(t)))
            }
            ,
            this.mi = () => {
                const t = JSON.parse(String(window.localStorage.getItem("chipCopy")));
                for (let e = 0; e < 64; e++)
                    this.customChipCanvas.chipData[e] = t[e];
                this.customChipCanvas.ri(),
                new ue(this.m,this.customChipCanvas.chipData)
            }
            ,
            this.whenKeyPressed = t => {
                "BUTTON" != t.target.tagName && 13 == t.keyCode ? this.He() : 32 == t.keyCode ? (this.di(),
                t.preventDefault()) : 90 == t.keyCode ? (this.customChipCanvas.undo(),
                t.stopPropagation()) : 89 == t.keyCode ? (this.customChipCanvas.redo(),
                t.stopPropagation()) : 219 == t.keyCode ? this.m.synth.goToPrevBar() : 221 == t.keyCode && this.m.synth.goToNextBar()
            }
            ,
            this.He = () => {
                this.m.prompt = null,
                new ue(this.m,this.customChipCanvas.startingChipData),
                this.m.record(new ue(this.m,this.customChipCanvas.chipData), !0)
            }
            ,
            this.Re.addEventListener("click", this.He),
            this.Oe.addEventListener("click", this.$e),
            this.container.addEventListener("keydown", this.whenKeyPressed),
            this.copyButton.addEventListener("click", this.pi),
            this.pasteButton.addEventListener("click", this.mi),
            this.ci.addEventListener("click", this.di),
            this.updatePlayButton(),
            setTimeout(( () => this.ci.focus())),
            this.customChipCanvas.render()
        }
        updatePlayButton() {
            this.m.synth.playing ? (this.ci.classList.remove("playButton"),
            this.ci.classList.add("pauseButton"),
            this.ci.title = "Pause (Space)",
            this.ci.innerText = "Pause") : (this.ci.classList.remove("pauseButton"),
            this.ci.classList.add("playButton"),
            this.ci.title = "Play (Space)",
            this.ci.innerText = "Play")
        }
    }
    class fs {
        constructor(t, e=!1, i=!1) {
            if (this.m = t,
            this.u = 120,
            this.v = 26,
            this.ui = Y.path({
                fill: nt.uiWidgetBackground,
                "pointer-events": "none"
            }),
            this.fi = [],
            this.ge = [],
            this.yi = !1,
            this.bi = Y.path({
                fill: "currentColor",
                "pointer-events": "none"
            }),
            this.gi = Y.path({
                fill: "none",
                stroke: "currentColor",
                "stroke-width": 1,
                "stroke-dasharray": "3, 2",
                "pointer-events": "none"
            }),
            this.wi = Y.circle({
                fill: "white",
                stroke: "none",
                "pointer-events": "none",
                r: 4
            }),
            this.q = Y.svg({
                style: `background-color: ${nt.editorBackground}; touch-action: none;`,
                width: "100%",
                height: "100%",
                viewBox: "0 0 " + this.u + " " + this.v,
                preserveAspectRatio: "none"
            }, this.ui, this.gi, this.wi, this.bi),
            this.selfUndoSettings = [],
            this.selfUndoHistoryPos = 0,
            this.vi = J.div({
                style: "position: absolute; bottom: 0; left: 2px; font-size: 8px; line-height: 1; pointer-events: none;"
            }),
            this.coordText = null,
            this.container = J.div({
                class: "filterEditor",
                style: "height: 100%; position: relative;"
            }, this.q, this.vi),
            this.xi = 2,
            this.be = !1,
            this.ki = !1,
            this.Mi = !1,
            this.N = 0,
            this.Ze = 0,
            this.R = !1,
            this.O = !1,
            this.Si = !1,
            this.Fi = !1,
            this.Ci = !1,
            this.Ai = 2,
            this.Ei = 0,
            this.Ti = 0,
            this.Pi = 0,
            this.Bi = null,
            this.Ii = 0,
            this.Li = -1,
            this.Di = -1,
            this.zi = -1,
            this.qi = -1,
            this.Ni = -1,
            this.Ge = t => {
                90 == t.keyCode && (this.undo(),
                t.stopPropagation()),
                89 == t.keyCode && (this.redo(),
                t.stopPropagation())
            }
            ,
            this.W = t => {
                this.R = !0,
                this.ki || this.bi.style.setProperty("fill", "currentColor")
            }
            ,
            this.U = t => {
                this.R = !1,
                this.Oi(),
                null != this.coordText && (this.coordText.innerText = "")
            }
            ,
            this.K = t => {
                t.preventDefault(),
                this.Mi = !1;
                const e = this.q.getBoundingClientRect();
                this.N = ((t.clientX || t.pageX) - e.left) * this.u / (e.right - e.left),
                this.Ze = ((t.clientY || t.pageY) - e.top) * this.v / (e.bottom - e.top),
                isNaN(this.N) && (this.N = 0),
                isNaN(this.Ze) && (this.Ze = 0),
                this.Ri()
            }
            ,
            this.Y = t => {
                t.preventDefault(),
                this.Mi = !0;
                const e = this.q.getBoundingClientRect();
                this.N = (t.touches[0].clientX - e.left) * this.u / (e.right - e.left),
                this.Ze = (t.touches[0].clientY - e.top) * this.v / (e.bottom - e.top),
                isNaN(this.N) && (this.N = 0),
                isNaN(this.Ze) && (this.Ze = 0),
                this.Ri()
            }
            ,
            this.Z = t => {
                if (null == this.container.offsetParent)
                    return;
                const e = this.q.getBoundingClientRect();
                this.N = ((t.clientX || t.pageX) - e.left) * this.u / (e.right - e.left),
                this.Ze = ((t.clientY || t.pageY) - e.top) * this.v / (e.bottom - e.top),
                isNaN(this.N) && (this.N = 0),
                isNaN(this.Ze) && (this.Ze = 0),
                this.O || this.$i(),
                this.X()
            }
            ,
            this.tt = t => {
                if (null == this.container.offsetParent)
                    return;
                this.O && t.preventDefault();
                const e = this.q.getBoundingClientRect();
                this.N = (t.touches[0].clientX - e.left) * this.u / (e.right - e.left),
                this.Ze = (t.touches[0].clientY - e.top) * this.v / (e.bottom - e.top),
                isNaN(this.N) && (this.N = 0),
                isNaN(this.Ze) && (this.Ze = 0),
                this.O || this.$i(),
                this.X()
            }
            ,
            this.et = t => {
                if (this.yi) {
                    const t = this.m.song.channels[this.m.channel].instruments[this.m.getCurrentInstrument()];
                    this.Hi = this._i(t)
                }
                if (null != this.container.offsetParent) {
                    if (this.O && (this.m.lastChangeWas(this.Bi) || this.yi) && null != this.Bi) {
                        if (this.Fi || this.Si || this.Mi)
                            this.ki || this.m.record(this.Bi);
                        else if (this.Ei < this.Hi.controlPointCount && -1 != this.Ei) {
                            const t = this.Hi.controlPoints[this.Ei];
                            let e = new bi(this.m,this.Hi,t,this.Ei,this.be,!0);
                            this.ki || this.m.record(e)
                        }
                        this.Oi(),
                        this.ki && (this.selfUndoSettings.length = this.selfUndoHistoryPos + 1,
                        this.selfUndoSettings.push(JSON.stringify(this.ce.toJsonObject())),
                        this.selfUndoHistoryPos++)
                    }
                    this.Bi = null,
                    this.Si = !1,
                    this.Ci = !1,
                    this.O = !1,
                    this.yi = !1,
                    this.$i()
                }
            }
            ,
            this.be = e,
            this.ki = i,
            this.ki) {
                this.container.addEventListener("keydown", this.Ge),
                this.u = 1200,
                this.v = 260,
                this.xi = 14,
                this.q.setAttribute("viewBox", "0 -20 " + this.u + " " + (this.v + 30)),
                this.vi.style.setProperty("font-size", "16px"),
                this.vi.style.setProperty("position", ""),
                this.vi.style.setProperty("bottom", "-16px"),
                this.vi.style.setProperty("min-height", "1em"),
                this.gi.style.setProperty("stroke-width", "3"),
                this.gi.style.setProperty("stroke-dasharray", "6, 4"),
                this.gi.setAttribute("color", nt.getChannelColor(this.m.song, this.m.channel).primaryNote),
                this.container.style.setProperty("width", "85%"),
                this.wi.setAttribute("r", "20"),
                this.bi.setAttribute("fill", nt.getChannelColor(this.m.song, this.m.channel).primaryNote);
                for (let t = 0; t < p.filterMaxPoints; t++)
                    this.fi[t] = Y.text(),
                    this.fi[t].setAttribute("fill", nt.invertedText),
                    this.fi[t].setAttribute("text-anchor", "start"),
                    this.fi[t].setAttribute("dominant-baseline", "central"),
                    this.fi[t].setAttribute("pointer-events", "none"),
                    this.fi[t].setAttribute("font-weight", "bolder"),
                    this.fi[t].textContent = "" + (t + 1),
                    this.fi[t].style.setProperty("display", "none"),
                    this.fi[t].style.setProperty("font-size", "24px"),
                    this.q.appendChild(this.fi[t]);
                const t = this.m.song.channels[this.m.channel].instruments[this.m.getCurrentInstrument()]
                  , e = this.be ? t.noteFilter : t.eqFilter;
                this.selfUndoSettings.push(JSON.stringify(e.toJsonObject())),
                this.ge[0] = e;
                for (let e = 1; e < p.filterMorphCount; e++) {
                    const i = this.be ? t.noteSubFilters[e] : t.eqSubFilters[e];
                    if (null != i) {
                        let t = new Rt;
                        t.fromJsonObject(i.toJsonObject()),
                        this.ge[e] = t
                    }
                }
            }
            this.container.addEventListener("mousedown", this.K),
            this.container.addEventListener("mouseover", this.W),
            this.container.addEventListener("mouseout", this.U),
            document.addEventListener("mousemove", this.Z),
            document.addEventListener("mouseup", this.et),
            this.container.addEventListener("touchstart", this.Y),
            this.container.addEventListener("touchmove", this.tt),
            this.container.addEventListener("touchend", this.et),
            this.container.addEventListener("touchcancel", this.et)
        }
        Vi(t) {
            return p.filterFreqRange * t / this.u - .5
        }
        Gi(t) {
            return this.u * (t + .5) / p.filterFreqRange
        }
        Wi(t) {
            return (p.filterGainRange - 1) * (1 - (t - .5) / (this.v - 1))
        }
        ji(t) {
            return (this.v - 1) * (1 - t / (p.filterGainRange - 1)) + .5
        }
        Ri() {
            this.O = !0;
            const t = new Xt;
            this.Bi = t,
            this.m.setProspectiveChange(this.Bi),
            this.$i(),
            this.X()
        }
        $i() {
            this.Ti = this.Vi(this.N),
            this.Pi = this.Wi(this.Ze),
            this.Fi = !0,
            this.Ei = -1;
            let t = Number.POSITIVE_INFINITY;
            for (let e = 0; e < this.Hi.controlPointCount; e++) {
                const i = this.Hi.controlPoints[e]
                  , n = Math.sqrt(Math.pow(this.Gi(i.freq) - this.N, 2) + Math.pow(this.ji(i.gain) - this.Ze, 2));
                (n <= 13 * (+this.ki + 1) || this.Hi.controlPointCount >= p.filterMaxPoints) && n < t && (t = n,
                this.Ei = e,
                this.Fi = !1)
            }
            if (this.Fi) {
                const t = this.N / this.u;
                this.Ai = t < .2 ? 1 : t < .8 ? 2 : 0
            }
        }
        X() {
            if (this.yi) {
                const t = this.m.song.channels[this.m.channel].instruments[this.m.getCurrentInstrument()];
                if (this.Hi = this._i(t),
                null != this.Bi)
                    if (this.Bi instanceof Xt && this.Bi.checkFirst()instanceof wi) {
                        const t = this.Bi.checkFirst().getMoveData(!0)
                          , e = this.Hi.controlPoints[this.Ei];
                        null == e || e.type != t.point.type ? (this.Bi = null,
                        this.yi = !1,
                        this.O = !1) : (e.freq = t.freq,
                        e.gain = t.gain)
                    } else
                        this.Bi = null,
                        this.yi = !1,
                        this.O = !1
            }
            if (null != this.Bi && (this.m.lastChangeWas(this.Bi) || this.yi) ? this.Bi.undo() : this.O = !1,
            this.Bi = null,
            this.Ci = !1,
            null != this.coordText && !this.O) {
                let t = Math.round(this.Wi(this.Ze))
                  , e = Math.round(this.Vi(this.N));
                e >= 0 && e < p.filterFreqRange && t >= 0 && t < p.filterGainRange ? this.coordText.innerText = "(" + e + ", " + t + ")" : this.coordText.innerText = ""
            }
            if (this.O) {
                const t = new Xt;
                if (this.Bi = t,
                this.m.setProspectiveChange(this.Bi),
                this.Fi) {
                    const e = Math.max(0, Math.min(p.filterGainRange - 1, Math.round(this.Wi(this.Ze))))
                      , i = this.Ui(this.Hi, this.Vi(this.N), -1);
                    if (i >= 0 && i < p.filterFreqRange) {
                        const n = new Ot;
                        n.type = this.Ai,
                        n.freq = i,
                        n.gain = e,
                        t.append(new bi(this.m,this.Hi,n,this.Hi.controlPointCount,this.be)),
                        null != this.coordText && (this.coordText.innerText = "(" + i + ", " + e + ")")
                    } else
                        this.Ci = !0
                } else if (this.Ei >= this.Hi.controlPointCount || -1 == this.Ei)
                    this.Bi = null,
                    this.O = !1;
                else {
                    const e = this.Vi(this.N) - this.Ti
                      , i = this.Wi(this.Ze) - this.Pi;
                    let n = this.Hi.controlPoints[this.Ei];
                    const s = Math.max(0, Math.min(p.filterGainRange - 1, Math.round(n.gain + i)))
                      , o = this.Ui(this.Hi, n.freq + e, this.Ei);
                    if (0 == Math.round(e) && 0 == Math.round(i) && o == n.freq && s == n.gain || (this.Si = !0),
                    o >= 0 && o < p.filterFreqRange) {
                        if (t.append(new wi(this.m,n,n.freq,o,n.gain,s,this.be,this.Ei)),
                        null != this.coordText && (this.coordText.innerText = "(" + o + ", " + s + ")",
                        !this.yi)) {
                            const t = this.m.song.channels[this.m.channel].instruments[this.m.getCurrentInstrument()];
                            t.tmpEqFilterStart = t.eqFilter,
                            t.tmpEqFilterEnd = null,
                            t.tmpNoteFilterStart = t.noteFilter,
                            t.tmpNoteFilterEnd = null
                        }
                    } else
                        t.append(new bi(this.m,this.Hi,n,this.Ei,this.be,!0)),
                        this.Ci = !0
                }
            }
            (this.O || this.R) && this.Oi()
        }
        Ui(t, e, i) {
            const n = Math.round(e);
            let s = n
              , o = n
              , a = n <= e;
            for (; ; ) {
                let e = !1;
                const n = a ? s : o;
                for (let s = 0; s < t.controlPointCount; s++)
                    if (s != i && t.controlPoints[s].freq == n) {
                        e = !0;
                        break
                    }
                if (!e)
                    return n;
                a = !a,
                a && s--,
                a || o++
            }
        }
        static Ki(t, e, i, n=!1) {
            return `M ${t - i} ${e} a ${i} ${i} 0 1 ${n ? 1 : 0} ${2 * i} 0 a ${i} ${i} 0 1 ${n ? 1 : 0} ${2 * -i} 0 `
        }
        Oi() {
            this.wi.style.display = "none",
            this.vi.textContent = "";
            let t = ""
              , e = "";
            for (let i = 0; i < this.Hi.controlPointCount; i++) {
                const n = this.Hi.controlPoints[i]
                  , s = this.Gi(n.freq)
                  , o = this.ji(n.gain);
                t += fs.Ki(s, o, this.xi),
                1 == n.type ? e += "M 0 " + o + " L " + s + " " + o + " " : 0 == n.type && (e += "M " + this.u + " " + o + " L " + s + " " + o + " "),
                this.Ei == i && this.R && !this.O && (this.wi.setAttribute("cx", String(s)),
                this.wi.setAttribute("cy", String(o)),
                this.wi.style.display = "",
                null != this.coordText && (this.coordText.innerText = "(" + n.freq + ", " + n.gain + ")")),
                (this.Ei == i || this.Fi && this.O && i == this.Hi.controlPointCount - 1) && (this.R || this.O) && !this.Ci && (this.vi.textContent = i + 1 + ": " + p.filterTypeNames[n.type] + (this.ki ? " @" + q(n.getHz()) + "Hz" : "")),
                this.ki && (this.fi[i].style.setProperty("display", ""),
                this.fi[i].setAttribute("x", "" + (s - 7)),
                this.fi[i].setAttribute("y", "" + (o + 2)))
            }
            if (this.bi.setAttribute("d", t),
            this.gi.setAttribute("d", e),
            this.Fi && !this.O && this.R && (this.vi.textContent = "+ " + p.filterTypeNames[this.Ai]),
            this.ki)
                for (let t = this.Hi.controlPointCount; t < p.filterMaxPoints; t++)
                    this.fi[t].style.setProperty("display", "none");
            const i = [];
            for (let t = 0; t < this.Hi.controlPointCount; t++) {
                const e = this.Hi.controlPoints[t]
                  , n = new dt;
                e.toCoefficients(n, 44800),
                i.push(n)
            }
            const n = new pt;
            let s = "M 0 " + this.v + " ";
            for (let t = -1; t <= p.filterFreqRange; t++) {
                const e = Ot.getHzFromSettingValue(t)
                  , o = 2 * Math.PI * e / 44800
                  , a = Math.cos(o)
                  , r = Math.sin(o);
                let h = 1;
                for (const t of i)
                    n.analyzeComplex(t, a, r),
                    h *= n.magnitude();
                const l = Math.log2(h) / p.filterGainStep + p.filterGainCenter
                  , c = this.ji(l);
                s += "L " + q(this.Gi(t)) + " " + q(c) + " "
            }
            s += "L " + this.u + " " + this.v + " L 0 " + this.v + " z ",
            this.ui.setAttribute("d", s)
        }
        swapToSettings(t, e=!1) {
            const i = this.m.song.channels[this.m.channel].instruments[this.m.getCurrentInstrument()];
            new vi(this.m,t,this.ce,this.be,this.ge,this.be ? i.noteSubFilters : i.eqSubFilters),
            this.ce = t,
            this.ge[this.Ii] = t,
            e && this.ki && (this.selfUndoSettings.length = this.selfUndoHistoryPos + 1,
            this.selfUndoSettings.push(JSON.stringify(this.ce.toJsonObject())),
            this.selfUndoHistoryPos++),
            this.Hi = this.ce,
            this.Oi()
        }
        saveSettings() {
            let t = new Rt;
            const e = this.m.song.channels[this.m.channel].instruments[this.m.getCurrentInstrument()];
            t.fromJsonObject(JSON.parse(String(this.selfUndoSettings[0]))),
            this.m.record(new vi(this.m,this.ge[0],t,this.be,this.ge,this.be ? e.noteSubFilters : e.eqSubFilters), !0)
        }
        undo() {
            if (this.selfUndoHistoryPos > 0) {
                if (this.selfUndoHistoryPos--,
                null != this.selfUndoSettings[this.selfUndoHistoryPos + 1] && this.selfUndoSettings[this.selfUndoHistoryPos + 1].startsWith("jmp")) {
                    let t = this.selfUndoSettings[this.selfUndoHistoryPos + 1]
                      , e = +t.substring(3, t.indexOf("|"));
                    return this.swapToSubfilter(this.Ii, e),
                    e
                }
                if (this.selfUndoSettings[this.selfUndoHistoryPos].startsWith("jmp")) {
                    let t = new Rt
                      , e = this.selfUndoSettings[this.selfUndoHistoryPos];
                    t.fromJsonObject(JSON.parse(e.substring(e.indexOf(":") + 1))),
                    this.swapToSettings(t, !1)
                } else {
                    let t = new Rt;
                    t.fromJsonObject(JSON.parse(String(this.selfUndoSettings[this.selfUndoHistoryPos]))),
                    this.swapToSettings(t, !1)
                }
            }
            return -1
        }
        redo() {
            if (this.selfUndoHistoryPos < this.selfUndoSettings.length - 1) {
                if (this.selfUndoHistoryPos++,
                this.selfUndoSettings[this.selfUndoHistoryPos].startsWith("jmp")) {
                    let t = this.selfUndoSettings[this.selfUndoHistoryPos]
                      , e = +t.substring(t.indexOf("|") + 1, t.indexOf(":"));
                    return this.swapToSubfilter(this.Ii, e, !1),
                    e
                }
                {
                    let t = new Rt;
                    t.fromJsonObject(JSON.parse(String(this.selfUndoSettings[this.selfUndoHistoryPos]))),
                    this.swapToSettings(t, !1)
                }
            }
            return -1
        }
        resetToInitial() {
            this.selfUndoHistoryPos = 1,
            this.undo()
        }
        swapSubfilterIndices(t) {
            if (-1 == this.Ei)
                return;
            if (t >= this.Hi.controlPointCount)
                return;
            let e = this.Hi.controlPoints[this.Ei];
            this.Hi.controlPoints[this.Ei] = this.Hi.controlPoints[t],
            this.Hi.controlPoints[t] = e,
            this.render()
        }
        swapToSubfilter(t, e, i=!1) {
            if (t != e) {
                let n = new Rt;
                if (n.fromJsonObject(this.ce.toJsonObject()),
                this.ge[t] = n,
                null == this.ge[e]) {
                    let t = new Rt;
                    t.fromJsonObject(this.ge[0].toJsonObject()),
                    this.ge[e] = t
                }
                i && (this.selfUndoSettings.length = this.selfUndoHistoryPos + 1,
                this.selfUndoSettings.push("jmp" + t + "|" + e + ":" + JSON.stringify(this.ge[e].toJsonObject())),
                this.selfUndoHistoryPos++),
                this.Ii = e,
                this.swapToSettings(this.ge[e], !1)
            }
        }
        _i(t) {
            let e = this.be ? t.tmpNoteFilterStart : t.tmpEqFilterStart;
            return null == e && (e = this.be ? t.noteFilter : t.eqFilter),
            e
        }
        render(t=!1, e=!1) {
            this.yi = e && this.O;
            const i = this.m.song.channels[this.m.channel].instruments[this.m.getCurrentInstrument()]
              , n = this.be ? i.noteFilter : i.eqFilter;
            let s = t && !this.ki && (e || !this.R && !this.Si && !this.O) && this.m.synth.playing;
            s ? this.bi.style.setProperty("fill", `${nt.overwritingModSlider}`) : this.ki || this.bi.style.setProperty("fill", "currentColor"),
            this.Hi == n || this.yi || (this.Bi = null,
            this.O = !1),
            this.ce = n,
            s ? (this.Hi = this._i(i),
            this.yi && this.X()) : this.Hi = n,
            this.O || this.$i();
            let o = 0
              , a = 0
              , r = 0;
            for (let t = 0; t < this.Hi.controlPointCount; t++) {
                const e = this.Hi.controlPoints[t];
                o = 3 * o + e.type,
                a = a * p.filterFreqRange + e.freq,
                r = r * p.filterGainRange + e.gain
            }
            this.Li == this.Ei && this.Di == this.Hi.controlPointCount && this.zi == o && this.qi == a && this.Ni == r || (this.Li = this.Ei,
            this.Di = this.Hi.controlPointCount,
            this.zi = o,
            this.qi = a,
            this.Ni = r,
            this.Oi())
        }
    }
    const {button: ys, div: bs, h2: gs, p: ws} = J;
    class vs {
        constructor(t, e, i) {
            this.m = t,
            this.hi = e,
            this.be = i,
            this.filterData = new Rt,
            this.startingFilterData = new Rt,
            this.Ii = 0,
            this.ci = ys({
                style: "width: 55%;",
                type: "button"
            }),
            this.Ji = [],
            this.Yi = bs({
                class: "instrument-bar",
                style: "justify-content: center;"
            }),
            this.Oe = ys({
                class: "cancelButton"
            }),
            this.Re = ys({
                class: "okayButton",
                style: "width:45%;"
            }, "Okay"),
            this.Qi = bs({
                style: "width: 100%; display: flex; flex-direction: row; align-items: center; justify-content: center;"
            }),
            this.Zi = bs({}, gs("Edit Filter")),
            this.Xi = ys({
                style: "width:86px; margin-right: 5px;",
                class: "copyButton"
            }, ["Copy", Y.svg({
                style: "flex-shrink: 0; position: absolute; left: 0; top: 50%; margin-top: -1em; pointer-events: none;",
                width: "2em",
                height: "2em",
                viewBox: "-5 -21 26 26"
            }, [Y.path({
                d: "M 0 -15 L 1 -15 L 1 0 L 13 0 L 13 1 L 0 1 L 0 -15 z M 2 -1 L 2 -17 L 10 -17 L 14 -13 L 14 -1 z M 3 -2 L 13 -2 L 13 -12 L 9 -12 L 9 -16 L 3 -16 z",
                fill: "currentColor"
            })])]),
            this.tn = ys({
                style: "width:86px;",
                class: "pasteButton"
            }, ["Paste", Y.svg({
                style: "flex-shrink: 0; position: absolute; left: 0; top: 50%; margin-top: -1em; pointer-events: none;",
                width: "2em",
                height: "2em",
                viewBox: "0 0 26 26"
            }, [Y.path({
                d: "M 8 18 L 6 18 L 6 5 L 17 5 L 17 7 M 9 8 L 16 8 L 20 12 L 20 22 L 9 22 z",
                stroke: "currentColor",
                fill: "none"
            }), Y.path({
                d: "M 9 3 L 14 3 L 14 6 L 9 6 L 9 3 z M 16 8 L 20 12 L 16 12 L 16 8 z",
                fill: "currentColor"
            })])]),
            this.en = bs({
                style: "width: 185px;"
            }, this.Xi, this.tn),
            this.nn = bs({
                style: "text-align: left; margin-bottom: 0px; font-size: x-small; height: 1.3em; color: " + nt.secondaryText + ";"
            }, ws("")),
            this.container = bs({
                class: "prompt noSelection",
                style: "width: 600px;"
            }, this.Zi, bs({
                style: "display: flex; width: 55%; align-self: center; flex-direction: row; align-items: center; justify-content: center;"
            }, this.ci), this.Yi, this.Qi, bs({
                style: "display: flex; flex-direction: row-reverse; justify-content: space-between;"
            }, this.Re, this.en), this.Oe),
            this.sn = (t, e=!0, i=!0) => {
                this.Ji[this.Ii].classList.remove("selected-instrument"),
                i && this.filterEditor.swapToSubfilter(this.Ii, t, e),
                this.Ii = t,
                this.Ji[t].classList.add("selected-instrument")
            }
            ,
            this.an = () => {
                const t = this.be ? this.m.song.channels[this.m.channel].instruments[this.m.getCurrentInstrument()].noteFilter.toJsonObject() : this.m.song.channels[this.m.channel].instruments[this.m.getCurrentInstrument()].eqFilter.toJsonObject();
                window.localStorage.setItem("filterCopy", JSON.stringify(t))
            }
            ,
            this.rn = () => {
                let t = new Rt;
                t.fromJsonObject(JSON.parse(String(window.localStorage.getItem("filterCopy")))),
                null != t && this.filterEditor.swapToSettings(t, !0)
            }
            ,
            this.Ge = t => {
                if (90 == t.keyCode) {
                    let e = this.filterEditor.undo();
                    e >= 0 && this.sn(e, !1, !1),
                    t.stopPropagation()
                }
                if (89 == t.keyCode) {
                    let e = this.filterEditor.redo();
                    e >= 0 && this.sn(e, !1, !1),
                    t.stopPropagation()
                }
                t.keyCode >= 49 && t.keyCode <= 57 && (t.shiftKey || (this.filterEditor.swapSubfilterIndices(t.keyCode - 49),
                t.stopPropagation()))
            }
            ,
            this.di = () => {
                this.hi.togglePlay(),
                this.updatePlayButton()
            }
            ,
            this.$e = () => {
                this.m.prompt = null,
                this.filterEditor.resetToInitial(),
                this.m.undo()
            }
            ,
            this.cleanUp = () => {
                this.Re.removeEventListener("click", this.He),
                this.Oe.removeEventListener("click", this.$e),
                this.container.removeEventListener("keydown", this.whenKeyPressed),
                this.ci.removeEventListener("click", this.di)
            }
            ,
            this.whenKeyPressed = t => {
                "BUTTON" != t.target.tagName && 13 == t.keyCode ? this.He() : 32 == t.keyCode ? (this.di(),
                t.preventDefault()) : 90 == t.keyCode ? (this.filterEditor.undo(),
                t.stopPropagation()) : 89 == t.keyCode ? (this.filterEditor.redo(),
                t.stopPropagation()) : 219 == t.keyCode ? this.m.synth.goToPrevBar() : 221 == t.keyCode ? this.m.synth.goToNextBar() : t.keyCode >= 48 && t.keyCode <= 57 && t.shiftKey && this.sn(t.keyCode - 48)
            }
            ,
            this.He = () => {
                this.m.prompt = null,
                this.filterEditor.saveSettings()
            }
            ,
            this.Re.addEventListener("click", this.He),
            this.Oe.addEventListener("click", this.$e),
            this.ci.addEventListener("click", this.di),
            this.Xi.addEventListener("click", this.an),
            this.tn.addEventListener("click", this.rn),
            this.updatePlayButton();
            let n = nt.getChannelColor(this.m.song, this.m.channel);
            this.filterEditor = new fs(t,i,!0),
            this.Qi.appendChild(this.filterEditor.container),
            this.filterEditor.container.insertBefore(this.nn, this.filterEditor.container.firstChild),
            this.filterEditor.coordText = this.nn,
            this.Zi.children[0].innerHTML = i ? "Edit Note Filter" : "Edit EQ Filter";
            let s = ys({
                class: "no-underline",
                style: "max-width: 5em;"
            }, "Main");
            this.Yi.appendChild(s),
            this.Ji.push(s),
            s.addEventListener("click", ( () => {
                this.sn(0)
            }
            ));
            for (let t = 1; t < p.filterMorphCount; t++) {
                let e = ys({
                    class: "no-underline",
                    style: "max-width: 2em;"
                }, "" + t);
                this.Ji.push(e),
                this.Yi.appendChild(e),
                e.addEventListener("click", ( () => {
                    this.sn(t)
                }
                ))
            }
            this.Ji[p.filterMorphCount - 1].classList.add("last-button"),
            this.Ji[0].classList.add("selected-instrument"),
            this.Yi.style.setProperty("--text-color-lit", n.primaryNote),
            this.Yi.style.setProperty("--text-color-dim", n.secondaryNote),
            this.Yi.style.setProperty("--background-color-lit", n.primaryChannel),
            this.Yi.style.setProperty("--background-color-dim", n.secondaryChannel),
            this.Qi.addEventListener("keydown", this.Ge),
            this.filterEditor.container.addEventListener("keydown", this.Ge),
            this.container.addEventListener("keydown", this.Ge),
            setTimeout(( () => this.ci.focus())),
            this.filterEditor.render()
        }
        updatePlayButton() {
            this.m.synth.playing ? (this.ci.classList.remove("playButton"),
            this.ci.classList.add("pauseButton"),
            this.ci.title = "Pause (Space)",
            this.ci.innerText = "Pause") : (this.ci.classList.remove("pauseButton"),
            this.ci.classList.add("playButton"),
            this.ci.title = "Play (Space)",
            this.ci.innerText = "Play")
        }
    }
    const {button: xs, div: ks, h2: Ms, input: Ss, label: Fs, br: Cs} = J;
    class As {
        constructor(t) {
            this.m = t,
            this.Oe = xs({
                class: "cancelButton"
            }),
            this.hn = xs({
                class: "exportButton",
                style: "width:45%;"
            }, "Export"),
            this.ln = Ss({
                style: "width: 3em; margin-left: 1em;",
                type: "checkbox"
            }),
            this.cn = "" == this.m.song.channels[this.m.channel].name ? p.jsonFormat + "-Instrument" : this.m.song.channels[this.m.channel].name,
            this.dn = Ss({
                type: "text",
                style: "width: 10em;",
                value: this.cn,
                maxlength: 250,
                autofocus: "autofocus"
            }),
            this.container = ks({
                class: "prompt noSelection",
                style: "width: 200px;"
            }, Ms("Export Instruments Options"), ks({
                style: "display: flex; flex-direction: row; align-items: center; justify-content: space-between;"
            }, "File name:", this.dn), Fs({
                style: "display: flex; flex-direction: row; align-items: center; height: 2em; justify-content: flex-end;"
            }, "Export all instruments", Cs(), "in channel:", this.ln), ks({
                style: "display: flex; flex-direction: row-reverse; justify-content: space-between;"
            }, this.hn), this.Oe),
            this.$e = () => {
                this.m.undo()
            }
            ,
            this.cleanUp = () => {
                this.Oe.removeEventListener("click", this.$e),
                this.hn.removeEventListener("click", this.pn),
                this.dn.removeEventListener("input", As.mn)
            }
            ,
            this.pn = () => {
                this.ln.checked ? this.un() : this.fn()
            }
            ,
            this.un = () => {
                const t = this.m.song.channels[this.m.channel].instruments.map((t => {
                    const e = t.toJsonObject();
                    return e.isDrum = this.m.song.getChannelIsNoise(this.m.channel),
                    e
                }
                ))
                  , e = new Blob([JSON.stringify(t)],{
                    type: "application/json"
                })
                  , i = document.createElement("a");
                i.href = URL.createObjectURL(e),
                i.download = this.dn.value + ".json",
                document.body.appendChild(i),
                i.click(),
                document.body.removeChild(i),
                this.$e()
            }
            ,
            this.fn = () => {
                const t = this.m.song.channels[this.m.channel].instruments[this.m.getCurrentInstrument()].toJsonObject();
                t.isDrum = this.m.song.getChannelIsNoise(this.m.channel);
                const e = new Blob([JSON.stringify(t)],{
                    type: "application/json"
                })
                  , i = document.createElement("a");
                i.href = URL.createObjectURL(e),
                i.download = this.dn.value + ".json",
                document.body.appendChild(i),
                i.click(),
                document.body.removeChild(i),
                this.$e()
            }
            ,
            this.Oe.addEventListener("click", this.$e),
            this.hn.addEventListener("click", this.pn),
            this.dn.addEventListener("input", As.mn)
        }
        static mn(t, e) {
            let i;
            if (null != t)
                i = t.target;
            else {
                if (null == e)
                    return;
                i = e
            }
            const n = /[\+\*\$\?\|\{\}\\\/<>#%!`&'"=:@]/gi;
            if (n.test(i.value)) {
                let t = i.selectionStart;
                i.value = i.value.replace(n, ""),
                t--,
                i.setSelectionRange(t, t)
            }
        }
    }
    const {button: Es, div: Ts, h2: Ps, input: Bs, select: Is, option: Ls, code: Ds} = J;
    class zs {
        constructor(t) {
            if (this.m = t,
            this.Oe = Es({
                class: "cancelButton"
            }),
            this.yn = Is({
                style: "width: 100%;"
            }, Ls({
                value: "append"
            }, "Append instruments to the end of the list."), Ls({
                value: "replace"
            }, "Replace only the selected instrument."), Ls({
                value: "all"
            }, "Replace all instruments in the channel.")),
            this.bn = Bs({
                type: "file",
                accept: ".json,application/json"
            }),
            this.gn = Ts({
                style: "text-align: left;"
            }, "You must enable either ", Ds("Simultaneous instruments per channel"), " or ", Ds("Different instruments per pattern"), " to change the import strategy."),
            this.container = Ts({
                class: "prompt noSelection",
                style: "width: 300px;"
            }, Ps("Import Instrument(s)"), this.gn, Ts({
                style: "display: flex; flex-direction: row; align-items: center; height: 2em; justify-content: flex-end;"
            }, Ts({
                class: "selectContainer",
                style: "width: 100%;"
            }, this.yn)), this.bn, this.Oe),
            this.wn = () => {
                const t = this.bn.files[0];
                if (!t)
                    return;
                const e = new FileReader;
                e.onload = t => {
                    var e;
                    try {
                        const i = JSON.parse(String(null === (e = t.target) || void 0 === e ? void 0 : e.result));
                        if (console.log("Processing file:", i),
                        "Array" == i.constructor.name)
                            return 0 == (this.m.song.patternInstruments || this.m.song.layeredInstruments) ? void alert("Instrument file contains multiple instruments! Please turn on either Simultaneous instruments per channel or Different instruments per pattern!") : void this.vn(i);
                        this.xn(i)
                    } catch (t) {
                        console.error("Error reading file:", t)
                    }
                }
                ,
                e.readAsText(t)
            }
            ,
            this.$e = () => {
                this.m.undo()
            }
            ,
            this.cleanUp = () => {
                this.bn.removeEventListener("change", this.wn),
                this.Oe.removeEventListener("click", this.$e)
            }
            ,
            this.vn = t => {
                const e = this.m.song.channels[this.m.channel]
                  , i = e.instruments[this.m.getCurrentInstrument()];
                switch (this.yn.value) {
                case "replace":
                    window.localStorage.setItem("instrumentImportStrategy", this.yn.value);
                    const n = t[0];
                    this.m.record(new Hi(this.m,i,n));
                    for (let i = 1; i < t.length; i++) {
                        const n = t[i];
                        if (!this.kn(e)) {
                            alert("Max instruments reached! Some instruments were not imported.");
                            break
                        }
                        this.m.record(new _i(this.m,e,n))
                    }
                    return this.m.record(new Li(this.m,this.m.getCurrentInstrument())),
                    this.m.prompt = null,
                    void this.m.notifier.changed();
                case "all":
                    window.localStorage.setItem("instrumentImportStrategy", this.yn.value),
                    e.instruments.length = 0;
                    for (let i of t) {
                        if (!this.kn(e)) {
                            alert("Max instruments reached! Some instruments were not imported.");
                            break
                        }
                        this.m.record(new _i(this.m,e,i))
                    }
                    return this.m.record(new Li(this.m,e.instruments.length - 1)),
                    this.m.prompt = null,
                    void this.m.notifier.changed();
                default:
                    window.localStorage.setItem("instrumentImportStrategy", this.yn.value);
                    for (let i of t) {
                        if (!this.kn(e)) {
                            alert("Max instruments reached! Some instruments were not imported.");
                            break
                        }
                        this.m.record(new _i(this.m,e,i))
                    }
                    return this.m.record(new Li(this.m,e.instruments.length - 1)),
                    this.m.prompt = null,
                    void this.m.notifier.changed()
                }
            }
            ,
            this.kn = t => !(this.m.song.getMaxInstrumentsPerChannel() <= t.instruments.length),
            this.xn = t => {
                const e = this.m.song.channels[this.m.channel]
                  , i = e.instruments[this.m.getCurrentInstrument()];
                switch (this.yn.value) {
                case "replace":
                    return window.localStorage.setItem("instrumentImportStrategy", this.yn.value),
                    this.m.record(new Hi(this.m,i,t)),
                    this.m.record(new Li(this.m,this.m.getCurrentInstrument())),
                    this.m.prompt = null,
                    void this.m.notifier.changed();
                case "all":
                    window.localStorage.setItem("instrumentImportStrategy", this.yn.value),
                    e.instruments.length = 1;
                    const n = e.instruments[0];
                    return this.m.record(new Hi(this.m,n,t)),
                    this.m.record(new Li(this.m,0)),
                    this.m.prompt = null,
                    void this.m.notifier.changed();
                default:
                    return this.kn(e) ? (window.localStorage.setItem("instrumentImportStrategy", this.yn.value),
                    this.m.record(new _i(this.m,e,t)),
                    this.m.record(new Li(this.m,e.instruments.length - 1)),
                    this.m.prompt = null,
                    void this.m.notifier.changed()) : (alert("Max instruments reached! The instrument was not imported."),
                    void (this.m.prompt = null))
                }
            }
            ,
            0 == (t.song.patternInstruments || t.song.layeredInstruments))
                this.yn.disabled = !0,
                this.yn.value = "replace",
                this.gn.hidden = !1;
            else {
                const t = window.localStorage.getItem("instrumentImportStrategy");
                null != t && (this.yn.value = t),
                this.gn.hidden = !0
            }
            this.bn.addEventListener("change", this.wn),
            this.Oe.addEventListener("click", this.$e)
        }
    }
    const {button: qs, div: Ns, h2: Os, input: Rs} = J;
    function $s(t, e) {
        for (; 0 !== e; ) {
            const i = t % e;
            t = e,
            e = i
        }
        return t
    }
    function Hs(t, e) {
        let i = t
          , n = e;
        const s = $s(i, n);
        return s > 1 && (i = Math.floor(i / s),
        n = Math.floor(n / s)),
        [i, n]
    }
    function _s(t, e) {
        const i = t[0]
          , n = t[1]
          , s = e[0]
          , o = e[1];
        return Hs(function(t, e) {
            return Math.floor(Math.abs(t * e) / $s(t, e))
        }(i, s), $s(n, o))
    }
    class Vs {
        constructor(t) {
            var e, i, n, s, o, a, r, h, l;
            this.m = t,
            this.Mn = 2,
            this.Sn = 64,
            this.Fn = 14,
            this.Cn = p.pitchChannelCountMax + p.noiseChannelCountMax - 1,
            this.An = "euclidGenMemory",
            this.En = 0,
            this.Tn = 0,
            this.Pn = -1,
            this.Bn = 0,
            this.In = 1,
            this.Ln = p.barCountMax,
            this.Dn = 0,
            this.zn = 400,
            this.qn = 10,
            this.Nn = 100,
            this.On = 100,
            this.Rn = this.Nn / this.Sn,
            this.$n = this.Nn / 16,
            this.Hn = this.Nn / this.Sn,
            this._n = this.Nn / 2 - this.$n - this.Hn,
            this.Vn = [],
            this.Gn = qs({
                class: "no-underline",
                style: "flex-grow: 0; flex-basis: 30px;"
            }, Y.svg({
                width: "26",
                height: "26",
                viewBox: "-13 -13 26 26",
                "pointer-events": "none"
            }, Y.path({
                d: "M -7.07 -5.66 L -5.66 -7.07 L 0 -1.4 L 5.66 -7.07 L 7.07 -5.66 L 1.4 0 L 7.07 5.66 L 5.66 7.07 L 0 1.4 L -5.66 7.07 L -7.07 5.66 L -1.4 0 z",
                fill: nt.primaryText
            }))),
            this.Wn = qs({
                class: "no-underline last-button",
                style: "flex-grow: 0; flex-basis: 30px;"
            }, Y.svg({
                width: "26",
                height: "26",
                viewBox: "-13 -13 26 26",
                "pointer-events": "none"
            }, Y.path({
                d: "M -8 -1 L -1 -1 L -1 -8 L 1 -8 L 1 -1 L 8 -1 L 8 1 L 1 1 L 1 8 L -1 8 L -1 1 L -8 1 z",
                fill: nt.primaryText
            }))),
            this.jn = Ns({
                class: "instrument-bar",
                style: "justify-content: center; width: 100%;"
            }, this.Gn, this.Wn),
            this.Un = Y.svg({
                "pointer-events": "none"
            }),
            this.Kn = Y.svg({
                "pointer-events": "none"
            }),
            this.Jn = Ns({
                style: `flex-grow: 1; color: ${nt.secondaryText}`
            }),
            this.Yn = qs({
                style: "height: auto; min-height: var(--button-size);"
            }, Y.svg({
                width: "26",
                height: "26",
                viewBox: "-13 -14 26 26",
                "pointer-events": "none"
            }, Y.rect({
                x: "-6",
                y: "-6",
                width: "2",
                height: "12",
                fill: nt.primaryText
            }), Y.path({
                d: "M 6 -6 L 6 6 L -3 0 z",
                fill: nt.primaryText
            }))),
            this.Qn = qs({
                style: "height: auto; min-height: var(--button-size); margin-left: 1em;"
            }, Y.svg({
                width: "24",
                height: "26",
                viewBox: "-10 -14 24 26",
                "pointer-events": "none"
            }, Y.path({
                d: "M 6 -6 L 6 6 L -3 0 z",
                fill: nt.primaryText
            }))),
            this.Zn = qs({
                style: "height: auto; min-height: var(--button-size);"
            }, Y.svg({
                width: "24",
                height: "26",
                viewBox: "-14 -14 24 26",
                "pointer-events": "none"
            }, Y.path({
                d: "M -6 -6 L -6 6 L 3 0 z",
                fill: nt.primaryText
            }))),
            this.Xn = qs({
                style: "height: auto; min-height: var(--button-size); margin-left: 1em;"
            }, Y.svg({
                width: "26",
                height: "26",
                viewBox: "-13 -14 26 26",
                "pointer-events": "none"
            }, Y.rect({
                x: "4",
                y: "-6",
                width: "2",
                height: "12",
                fill: nt.primaryText
            }), Y.path({
                d: "M -6 -6 L -6 6 L 3 0 z",
                fill: nt.primaryText
            }))),
            this.ts = Y.circle({
                cx: this.Nn / 2,
                cy: this.On / 2,
                r: this._n,
                stroke: nt.primaryText,
                "stroke-width": "0.5",
                fill: "none"
            }),
            this.es = Y.svg({
                "pointer-events": "none"
            }),
            this.ns = Rs({
                style: "width: 3em; margin-left: 1em;",
                type: "number",
                min: this.Mn,
                max: this.Sn,
                value: "8",
                step: "1"
            }),
            this.ss = Rs({
                style: "width: 3em; margin-left: 1em;",
                type: "number",
                min: "0",
                max: "8",
                value: "5",
                step: "1"
            }),
            this.os = Rs({
                style: "width: 3em; margin-left: 1em;",
                type: "number",
                min: "0",
                max: this.Sn,
                value: "0",
                step: "1"
            }),
            this.rs = Rs({
                style: "width: 3em; margin-left: 1em;",
                type: "number",
                min: "1",
                max: p.partsPerBeat,
                value: "1",
                step: "1"
            }),
            this.hs = Rs({
                style: "width: 3em; margin-left: 1em;",
                type: "number",
                min: "1",
                max: p.partsPerBeat,
                value: "4",
                step: "1"
            }),
            this.ls = Rs({
                style: "width: 3em; margin-left: 1em;",
                type: "number",
                min: "1",
                max: this.Cn + 1,
                value: "1",
                step: "1"
            }),
            this.cs = Rs({
                style: "width: 3em; margin-left: 1em;",
                type: "number",
                min: "0",
                max: p.maxPitch,
                value: "0",
                step: "1"
            }),
            this.ds = Rs({
                style: "width: 3em; margin-left: 1em;",
                type: "number",
                min: "1",
                max: p.barCountMax,
                value: "1",
                step: "1"
            }),
            this.ps = qs({
                style: "height: auto; min-height: var(--button-size); margin-left: 1em;"
            }, "Extend until loop"),
            this.us = Rs({
                type: "checkbox",
                style: "width: 1em; padding: 0; margin-left: 1em;"
            }),
            this.fs = Rs({
                type: "checkbox",
                style: "width: 1em; padding: 0; margin-left: 1em;"
            }),
            this.Re = qs({
                class: "okayButton",
                style: "width: 45%;"
            }, "Okay"),
            this.Oe = qs({
                class: "cancelButton"
            }),
            this.container = Ns({
                class: "prompt noSelection",
                style: "width: 600px;"
            }, Os("Generate Euclidean Rhythm"), Ns({
                style: "display: flex; flex-direction: row; align-items: center;"
            }, this.jn), Ns({
                style: "display: flex; flex-direction: row; align-items: center; justify-content: space-between;"
            }, Ns({
                style: "flex-grow: 0; flex-shrink: 0;"
            }, this.Yn, this.Qn), this.Jn, Ns({
                style: "flex-grow: 0; flex-shrink: 0;"
            }, this.Zn, this.Xn)), Ns({
                style: "display: flex; flex-direction: row; align-items: center; justify-content: center;"
            }, Y.svg({
                "pointer-events": "none",
                style: "touch-action: none; overflow: hidden;",
                width: "100%",
                height: "20px",
                viewBox: `0 0 ${this.zn} ${this.qn}`,
                preserveAspectRatio: "none"
            }, this.Un, this.Kn)), Ns({
                style: "display: flex; flex-direction: row; align-items: center; justify-content: space-evenly;"
            }, Ns({
                style: "max-width: 150px; height: 100%;"
            }, Y.svg({
                "pointer-events": "none",
                width: "100%",
                height: "100%",
                style: "touch-action: none; overflow: hidden; margin-right: 1.5em; max-width: 150px; height: 100%;",
                viewBox: `0 0 ${this.Nn} ${this.On}`,
                preserveAspectRatio: "none"
            }, this.ts, this.es)), Ns({
                style: "display: flex; height: 100%;"
            }, Ns({
                style: "flex-grow: 1; "
            }, Ns({
                style: "display: flex; flex-direction: row; align-items: center; height: 3em; justify-content: flex-end;"
            }, Ns({
                style: `text-align: right; flex-grow: 1; color: ${nt.primaryText};`
            }, "Steps"), this.ns), Ns({
                style: "display: flex; flex-direction: row; align-items: center; height: 3em; justify-content: flex-end; margin-top: 0.5em;"
            }, Ns({
                style: `text-align: right; flex-grow: 1; color: ${nt.primaryText};`
            }, "Pulses"), this.ss), Ns({
                style: "display: flex; flex-direction: row; align-items: center; height: 3em; justify-content: flex-end; margin-top: 0.5em;"
            }, Ns({
                style: `text-align: right; flex-grow: 1; color: ${nt.primaryText};`
            }, "Rotation"), this.os)), Ns({
                style: "flex-grow: 1; margin-left: 1em;"
            }, Ns({
                style: "display: flex; flex-direction: row; align-items: center; height: 3em; justify-content: flex-end; margin-bottom: 1em;"
            }, Ns({
                style: `text-align: right; flex-grow: 1; color: ${nt.primaryText};`
            }, "Size"), Ns({
                style: "display: flex; flex-direction: column;"
            }, this.rs, this.hs)), Ns({
                style: "display: flex; flex-direction: row; align-items: center; height: 3em; justify-content: flex-end; margin-top: 0.5em;"
            }, Ns({
                style: `text-align: right; flex-grow: 1; color: ${nt.primaryText};`
            }, "Channel"), this.ls), Ns({
                style: "display: flex; flex-direction: row; align-items: center; height: 3em; justify-content: flex-end; margin-top: 0.5em;"
            }, Ns({
                style: `text-align: right; flex-grow: 1; color: ${nt.primaryText};`
            }, "Pitch"), this.cs)))), Ns({
                style: "display: flex; flex-direction: row; align-items: center; justify-content: flex-end;"
            }, Ns({
                style: `text-align: right; color: ${nt.primaryText};`
            }, "Generate fading notes"), this.us, Ns({
                style: `text-align: right; color: ${nt.primaryText}; margin-left: 1em;`
            }, "Invert"), this.fs), Ns({
                style: "display: flex; flex-direction: row; align-items: center; justify-content: flex-end;"
            }, Ns({
                style: `text-align: right; color: ${nt.primaryText};`
            }, "Length (in bars)"), this.ds, this.ps), Ns({
                style: "display: flex; flex-direction: row-reverse; justify-content: space-between;"
            }, this.Re), this.Oe),
            this.cleanUp = () => {
                this.Re.removeEventListener("click", this.He),
                this.Oe.removeEventListener("click", this.$e),
                this.container.removeEventListener("keydown", this.Ge),
                this.jn.removeEventListener("click", this.ys),
                this.Yn.removeEventListener("click", this.bs),
                this.Qn.removeEventListener("click", this.gs),
                this.Zn.removeEventListener("click", this.ws),
                this.Xn.removeEventListener("click", this.vs),
                this.ns.removeEventListener("change", this.xs),
                this.ss.removeEventListener("change", this.ks),
                this.os.removeEventListener("change", this.Ms),
                this.rs.removeEventListener("change", this.Ss),
                this.hs.removeEventListener("change", this.Ss),
                this.ls.removeEventListener("change", this.Fs),
                this.cs.removeEventListener("change", this.Cs),
                this.ds.removeEventListener("change", this.As),
                this.fs.removeEventListener("change", this.Es),
                this.us.removeEventListener("change", this.Ts),
                this.ps.removeEventListener("click", this.Ps)
            }
            ,
            this.$e = () => {
                this.m.undo()
            }
            ,
            this.He = () => {
                this.m.prompt = null;
                const t = new Zt
                  , e = this.m.song.beatsPerBar
                  , i = p.partsPerBeat
                  , n = i * e
                  , s = this.Bn
                  , o = s + this.In;
                if (o > this.m.song.barCount) {
                    const e = this.m.song.barCount - s
                      , i = this.In - e;
                    t.append(new ke(this.m,this.m.song.barCount,i))
                }
                let a = new Map
                  , r = new Map;
                for (let t = s; t < o; t++) {
                    const o = t - s
                      , h = o * n;
                    for (let t = 0; t < this.Bs.length; t++) {
                        const s = this.Bs[t]
                          , l = this.Is[t];
                        if (!(l.length > 0))
                            continue;
                        const c = s.steps;
                        if (l.length !== c) {
                            console.error("The size of the generated sequence and the specified number of steps it should take have diverged: generated", l.length, "steps but expected", c);
                            continue
                        }
                        const d = s.stepSizeNumerator / s.stepSizeDenominator
                          , m = s.pitch
                          , u = s.channel
                          , f = s.invert ? 0 : 1
                          , y = s.generateFadingNotes;
                        r.set(m, !0);
                        let b = a.get(u);
                        if (null == b) {
                            b = [];
                            for (let t = 0; t < this.In; t++) {
                                const t = [];
                                for (let e = 0; e < this.Bs.length; e++) {
                                    const e = [];
                                    t.push(e)
                                }
                                b.push(t)
                            }
                            a.set(u, b)
                        }
                        let g = b[o][t];
                        const w = Math.floor(e * o / d)
                          , v = Math.ceil(e * (o + 1) / d);
                        for (let t = w; t < v; t++) {
                            let e = !1
                              , s = !1;
                            const o = Math.floor(t * i * d) - h
                              , a = Math.floor((t + 1) * i * d) - h;
                            o < 0 && (e = !0),
                            (e || a > n) && (s = !0);
                            const r = Math.max(0, Math.min(n, o))
                              , u = Math.max(0, Math.min(n, a));
                            if (l[t % c] === f) {
                                const t = new Tt(m,r,u,p.noteSizeMax,y);
                                if (e && (t.continuesLastPattern = !0),
                                s && y) {
                                    const e = (r - o) / (a - o)
                                      , i = Math.round(p.noteSizeMax + (0 - p.noteSizeMax) * e);
                                    t.pins[0].size = i;
                                    const n = (u - o) / (a - o)
                                      , s = Math.round(p.noteSizeMax + (0 - p.noteSizeMax) * n);
                                    t.pins[1].size = s
                                }
                                g.push(t)
                            }
                        }
                    }
                }
                for (const [e,i] of a.entries())
                    for (let n = 0; n < i.length; n++) {
                        const o = i[n]
                          , a = n + s;
                        let h = [];
                        const l = this.m.song.getPattern(e, a);
                        null != l && (h = l.cloneNotes()),
                        t.append(new ve(this.m,0,a,e,1,1)),
                        t.append(new Ji(this.m,e,a));
                        const c = this.m.song.getPattern(e, a);
                        if (null == c)
                            throw new Error("Couldn't create new pattern");
                        let d = [];
                        for (let t = h.length - 1; t >= 0; t--) {
                            const e = h[t];
                            let i = [];
                            for (const t of e.pitches)
                                r.has(t) || i.push(t);
                            e.pitches = i,
                            e.pitches.length < 1 && h.splice(t, 1)
                        }
                        let m = [];
                        for (const t of h)
                            m.push({
                                noteType: "old",
                                eventType: "start",
                                part: t.start,
                                note: t
                            }),
                            m.push({
                                noteType: "old",
                                eventType: "end",
                                part: t.end,
                                note: t
                            });
                        for (const t of o)
                            for (const e of t)
                                m.push({
                                    noteType: "new",
                                    eventType: "start",
                                    part: e.start,
                                    note: e
                                }),
                                m.push({
                                    noteType: "new",
                                    eventType: "end",
                                    part: e.end,
                                    note: e
                                });
                        m.sort(( (t, e) => t.part - e.part));
                        let u = []
                          , f = null;
                        for (let t of m)
                            null == f ? f = {
                                part: t.part,
                                events: [t]
                            } : t.part !== f.part ? (u.push(f),
                            f = {
                                part: t.part,
                                events: [t]
                            }) : f.events.push(t);
                        null != f && u.push(f);
                        let y = []
                          , b = 0
                          , g = 0
                          , w = new Set
                          , v = []
                          , x = new Set;
                        for (const t of u)
                            if (0 === y.length) {
                                for (const e of t.events) {
                                    if ("end" === e.eventType)
                                        throw new Error("Got note end earlier than expected");
                                    if ("start" !== e.eventType)
                                        throw new Error("Unknown mergeable event type");
                                    y.push({
                                        noteType: e.noteType,
                                        note: e.note
                                    })
                                }
                                b = t.part
                            } else {
                                for (const e of t.events)
                                    if ("end" === e.eventType)
                                        w.add(e.note);
                                    else {
                                        if ("start" !== e.eventType)
                                            throw new Error("Unknown mergeable event type");
                                        v.push({
                                            noteType: e.noteType,
                                            note: e.note
                                        })
                                    }
                                g = t.part;
                                const e = new Tt(0,b,g,p.noteSizeMax,!1);
                                let i = !1
                                  , n = null
                                  , s = null;
                                for (const t of y) {
                                    const e = t.note;
                                    for (const t of e.pitches)
                                        x.add(t);
                                    if (e.continuesLastPattern && (i = !0),
                                    "new" === t.noteType)
                                        (null == n || t.note.start > n.start || t.note.end < n.end) && (n = t.note);
                                    else if ("old" === t.noteType) {
                                        if (null != s)
                                            throw new Error("Somehow got more than one old note");
                                        s = t.note
                                    }
                                }
                                const o = Array.from(x).sort(( (t, e) => t - e));
                                if (e.pitches = o,
                                e.continuesLastPattern = i,
                                null != n) {
                                    const t = n.start
                                      , i = n.end
                                      , s = n.pins[0].size
                                      , o = n.pins[1].size
                                      , a = (b - t) / (i - t)
                                      , r = Math.round(s + (o - s) * a);
                                    e.pins[0].size = r;
                                    const h = (g - t) / (i - t)
                                      , l = Math.round(s + (o - s) * h);
                                    e.pins[1].size = l
                                } else if (null != s) {
                                    const t = g - b
                                      , i = b - s.start
                                      , n = g - s.start;
                                    let o = []
                                      , a = -1
                                      , r = -1
                                      , h = 0
                                      , l = s.pins.length - 1;
                                    for (let t = 0; t < s.pins.length; t++) {
                                        const e = s.pins[t];
                                        if (e.time < i)
                                            h = t;
                                        else if (e.time >= i && e.time <= n)
                                            -1 === a && (a = t),
                                            r = t;
                                        else if (e.time > n) {
                                            l = t;
                                            break
                                        }
                                    }
                                    if (-1 !== a) {
                                        for (let t = a; t <= r; t++) {
                                            const e = s.pins[t]
                                              , n = e.time - i;
                                            o.push(Et(0, n, e.size))
                                        }
                                        const e = o[0]
                                          , c = o[o.length - 1];
                                        if (0 !== e.time) {
                                            const t = s.pins[h]
                                              , n = i - t.time
                                              , a = n / (n + e.time)
                                              , r = Math.round(t.size + (e.size - t.size) * a);
                                            o.unshift(Et(0, 0, r))
                                        }
                                        if (c.time !== t) {
                                            const e = s.pins[l]
                                              , a = n - (c.time + i)
                                              , r = a / (a + (e.time - n))
                                              , h = Math.round(c.size + (e.size - c.size) * r);
                                            o.push(Et(0, t, h))
                                        }
                                    } else {
                                        const e = s.pins[h]
                                          , a = s.pins[l]
                                          , r = i - e.time
                                          , c = n - e.time
                                          , d = a.time - e.time
                                          , p = r / d
                                          , m = c / d
                                          , u = Math.round(e.size + (a.size - e.size) * p)
                                          , f = Math.round(e.size + (a.size - e.size) * m);
                                        o.push(Et(0, 0, u)),
                                        o.push(Et(0, t, f))
                                    }
                                    e.pins = o
                                }
                                if (e.pins.length < 2)
                                    throw new Error("Ended up generating note with less than two pins");
                                if (e.pitches.length < 1)
                                    throw new Error("Ended up generating note with no pitches");
                                d.push(e);
                                for (let t of w)
                                    for (let e = y.length - 1; e >= 0; e--) {
                                        t === y[e].note && y.splice(e, 1)
                                    }
                                for (let t of v)
                                    y.push(t);
                                for (x.clear(),
                                w.clear(); v.length > 0; )
                                    v.pop();
                                b = g
                            }
                        c.notes = [];
                        for (let e = 0; e < d.length; e++) {
                            const i = d[e];
                            t.append(new gn(this.m,c,i,e))
                        }
                    }
                this.m.record(t, !0),
                window.localStorage.setItem(this.An, JSON.stringify({
                    sequences: this.Bs,
                    barAmount: this.In
                }))
            }
            ,
            this.Ls = () => {
                this.Is = [];
                for (let t = 0; t < this.Bs.length; t++)
                    this.Is.push([]),
                    this.Ds(t)
            }
            ,
            this.Ds = t => {
                const e = this.Bs[t];
                this.Is[t] = function(t, e, i) {
                    t = Math.max(0, t),
                    e = Math.max(0, Math.min(t, e));
                    let n = [];
                    for (let i = 0; i < t; i++)
                        n.push([i >= e ? 0 : 1]);
                    let s = t
                      , o = t - e;
                    if (s > 0 && o > 0)
                        for (; s !== o; ) {
                            s > o ? s -= o : o -= s;
                            const t = Math.min(s, o);
                            if (!(t <= 1))
                                for (let e = 0; e < t; e++) {
                                    const t = n.pop();
                                    if (null != t)
                                        for (const i of t)
                                            n[e].push(i)
                                }
                        }
                    let a = [];
                    for (const t of n)
                        for (const e of t)
                            a.push(e);
                    return 0 !== i && (i = (i % a.length + a.length) % a.length,
                    i = a.length - i,
                    a = a.slice(i).concat(a.slice(0, i))),
                    a
                }(e.steps, e.pulses, e.rotation)
            }
            ,
            this.zs = () => {
                this.Ds(this.En)
            }
            ,
            this.Ge = t => {
                "BUTTON" != t.target.tagName && 13 == t.keyCode && this.He()
            }
            ,
            this.ys = t => {
                if (t.target == this.Wn) {
                    const t = this.Bs[this.En];
                    this.Bs.push({
                        steps: t.steps,
                        pulses: t.pulses,
                        rotation: t.rotation,
                        stepSizeNumerator: t.stepSizeNumerator,
                        stepSizeDenominator: t.stepSizeDenominator,
                        channel: t.channel,
                        pitch: t.pitch,
                        invert: t.invert,
                        generateFadingNotes: t.generateFadingNotes
                    }),
                    this.En = this.Bs.length - 1,
                    this.zs(),
                    this.qs(),
                    this.Ns(),
                    this.Os(),
                    this.Rs()
                } else if (t.target == this.Gn)
                    this.Bs.splice(this.En, 1),
                    this.Is.splice(this.En, 1),
                    this.En = Math.max(0, Math.min(this.Bs.length - 1, this.En)),
                    this.qs(),
                    this.Ns(),
                    this.Os(),
                    this.Rs();
                else {
                    const e = this.Vn.indexOf(t.target);
                    -1 != e && (this.En = e,
                    this.qs(),
                    this.Ns(),
                    this.Os(),
                    this.Rs())
                }
            }
            ,
            this.bs = t => {
                this.Dn = this.Bn,
                this.$s(),
                this.Hs()
            }
            ,
            this.gs = t => {
                this.Dn = this.Dn - 1,
                this.Dn < this.Bn && (this.Dn += this.In),
                this.$s(),
                this.Hs()
            }
            ,
            this.ws = t => {
                this.Dn = this.Dn + 1;
                const e = this.Bn + this.In;
                this.Dn >= e && (this.Dn -= this.In),
                this.$s(),
                this.Hs()
            }
            ,
            this.vs = t => {
                const e = this.Bn + this.In;
                this.Dn = e - 1,
                this.$s(),
                this.Hs()
            }
            ,
            this.Es = t => {
                const e = this.Bs[this.En]
                  , i = this.fs.checked;
                e.invert = i,
                this._s(),
                this.$s()
            }
            ,
            this.Ts = t => {
                const e = this.Bs[this.En]
                  , i = this.us.checked;
                e.generateFadingNotes = i,
                this.$s()
            }
            ,
            this.Ps = t => {
                const e = [this.m.song.beatsPerBar, 1]
                  , i = function(t, e) {
                    const i = t[0]
                      , n = t[1]
                      , s = e[0];
                    return Hs(i * e[1], n * s)
                }(this.Bs.reduce(( (t, i) => {
                    const n = function(t, e) {
                        const i = t[0]
                          , n = t[1];
                        return Hs(i * e[0], n * e[1])
                    }([i.steps, 1], Hs(i.stepSizeNumerator, i.stepSizeDenominator));
                    return _s(t, _s(n, e))
                }
                ), [1, 1]), e)
                  , n = i[0];
                this.In = Math.max(1, Math.min(this.Ln, n));
                const s = this.Bn
                  , o = this.Bn + this.In;
                this.Dn = Math.max(s, Math.min(o - 1, this.Dn)),
                this.ds.value = this.In + "",
                this.$s(),
                this.Hs()
            }
            ,
            this.xs = t => {
                const e = Math.max(this.Mn, Math.min(this.Sn, +this.ns.value));
                this.Bs[this.En].steps = e,
                this.ns.value = e + "",
                this.Ns(),
                this.zs(),
                this.Rs()
            }
            ,
            this.ks = t => {
                const e = this.Bs[this.En]
                  , i = Math.max(0, Math.min(e.steps, +this.ss.value));
                e.pulses = i,
                this.ss.value = i + "",
                this.zs(),
                this.Rs()
            }
            ,
            this.Ms = t => {
                const e = Math.max(0, Math.min(this.Sn, +this.os.value));
                this.Bs[this.En].rotation = e,
                this.os.value = e + "",
                this.zs(),
                this.Rs()
            }
            ,
            this.Ss = t => {
                const e = Math.max(1, Math.min(p.partsPerBeat, +this.rs.value))
                  , i = Math.max(1, Math.min(p.partsPerBeat, +this.hs.value))
                  , n = this.Bs[this.En];
                n.stepSizeNumerator = e,
                n.stepSizeDenominator = i,
                this.rs.value = e + "",
                this.hs.value = i + "",
                this.$s()
            }
            ,
            this.Cs = t => {
                const e = this.Bs[this.En]
                  , i = this.m.song.getChannelIsNoise(e.channel) ? p.drumCount - 1 : p.maxPitch
                  , n = Math.max(0, Math.min(i, +this.cs.value));
                e.pitch = n,
                this.cs.value = n + "",
                this.Hs()
            }
            ,
            this.Fs = t => {
                const e = Math.max(0, Math.min(this.Cn, +this.ls.value - 1));
                this.Bs[this.En].channel = e,
                this.ls.value = e + 1 + "",
                this.Os(),
                this.Rs()
            }
            ,
            this.As = t => {
                const e = Math.max(1, Math.min(this.Ln, +this.ds.value));
                this.In = e;
                const i = this.Bn
                  , n = this.Bn + this.In;
                this.Dn = Math.max(i, Math.min(n - 1, this.Dn)),
                this.ds.value = e + "",
                this.$s(),
                this.Hs()
            }
            ,
            this.Vs = () => {
                const t = this.m.song.beatsPerBar
                  , e = nt.pitchBackground
                  , i = this.Un
                  , n = this.zn / t
                  , s = this.qn;
                for (let o = 0; o < t; o++) {
                    const t = o * n + 1
                      , a = 1
                      , r = n - 2
                      , h = s - 2
                      , l = Y.rect({
                        x: t,
                        y: a,
                        width: r,
                        height: h,
                        style: `fill: ${e};`
                    });
                    i.appendChild(l)
                }
                this.qs(),
                this.Os(),
                this.Ns()
            }
            ,
            this.qs = () => {
                const t = this.Bs[this.En];
                this.ns.value = t.steps + "",
                this.ss.value = t.pulses + "",
                this.os.value = t.rotation + "",
                this.rs.value = t.stepSizeNumerator + "",
                this.hs.value = t.stepSizeDenominator + "",
                this.ls.value = t.channel + 1 + "",
                this.cs.value = t.pitch + "",
                this.fs.checked = t.invert,
                this.us.checked = t.generateFadingNotes,
                this.ds.value = this.In + ""
            }
            ,
            this.Os = () => {
                const t = this.Bs[this.En]
                  , e = t.channel
                  , i = this.m.song.getChannelIsNoise(e) ? p.drumCount - 1 : p.maxPitch;
                this.cs.value = Math.max(0, Math.min(i, +this.cs.value)) + "",
                this.cs.max = i + "",
                t.pitch = +this.cs.value
            }
            ,
            this.Ns = () => {
                const t = this.Bs[this.En]
                  , e = t.steps;
                this.ss.value = Math.max(0, Math.min(e, +this.ss.value)) + "",
                this.ss.max = e + "",
                t.pulses = +this.ss.value
            }
            ,
            this.Rs = () => {
                this._s(),
                this.$s(),
                this.Hs(),
                this.Gs()
            }
            ,
            this.Gs = () => {
                const t = this.jn;
                for (; this.Vn.length < this.Bs.length; ) {
                    const e = qs({
                        class: "no-underline"
                    }, this.Vn.length + 1 + "");
                    this.Vn.push(e),
                    t.insertBefore(e, this.Gn)
                }
                for (let t = this.Tn; t < this.Bs.length; t++) {
                    this.Vn[t].style.display = ""
                }
                for (let t = this.Bs.length; t < this.Tn; t++)
                    this.Vn[t].style.display = "none";
                for (this.Tn = this.Bs.length; this.Vn.length > this.Fn; )
                    t.removeChild(this.Vn.pop());
                if (this.Gn.style.display = this.Bs.length > 1 ? "" : "none",
                this.Wn.style.display = this.Bs.length < this.Fn ? "" : "none",
                this.Bs.length < this.Fn ? this.Gn.classList.remove("last-button") : this.Gn.classList.add("last-button"),
                this.Pn != this.En) {
                    const t = this.Vn[this.Pn];
                    null != t && t.classList.remove("selected-instrument");
                    this.Vn[this.En].classList.add("selected-instrument"),
                    this.Pn = this.En
                }
                for (let t = 0; t < this.Bs.length; t++) {
                    const e = this.Vn[t];
                    t === this.Pn ? e.style.color = "" : e.style.color = nt.primaryText
                }
                const e = nt.getChannelColor(this.m.song, this.Bs[this.En].channel);
                this.jn.style.setProperty("--text-color-lit", e.primaryNote),
                this.jn.style.setProperty("--text-color-dim", e.secondaryNote),
                this.jn.style.setProperty("--background-color-lit", e.primaryChannel),
                this.jn.style.setProperty("--background-color-dim", e.secondaryChannel)
            }
            ,
            this.Hs = () => {
                const t = this.Bs[this.En].pitch
                  , e = (t + p.keys[this.m.song.key].basePitch) % p.pitchesPerOctave;
                let i = "";
                if (p.keys[e].isWhiteKey)
                    i = p.keys[e].name;
                else {
                    const n = p.blackKeyNameParents[t % p.pitchesPerOctave];
                    i = p.keys[(e + p.pitchesPerOctave + n) % p.pitchesPerOctave].name,
                    1 == n ? i += "♭" : -1 == n && (i += "♯")
                }
                i += Math.floor(t / p.pitchesPerOctave),
                this.Jn.innerText = `Bar ${this.Dn + 1}, ${i}`
            }
            ,
            this._s = () => {
                const t = this.Bs[this.En]
                  , e = t.steps
                  , i = t.channel
                  , n = this.Is[this.En]
                  , s = n.length > 0
                  , o = t.invert ? 0 : 1
                  , a = nt.getChannelColor(this.m.song, i).primaryNote
                  , r = nt.editorBackground;
                this.ts.setAttribute("stroke", a);
                const h = this.es;
                for (; null !== h.firstChild; )
                    h.removeChild(h.firstChild);
                const l = this.Nn / 2
                  , c = this.On / 2
                  , d = this._n
                  , p = Math.max(this.Rn, Math.min(this.$n, this.Nn / e));
                for (let t = 0; t < e; t++) {
                    const i = t / e * Math.PI * 2 - Math.PI / 2
                      , m = l + Math.cos(i) * d
                      , u = c + Math.sin(i) * d
                      , f = Y.circle({
                        cx: m,
                        cy: u,
                        r: p,
                        style: `stroke: ${a}; stroke-width: 0.5; fill: ${r}`
                    });
                    s && n[t % e] === o && f.setAttribute("style", `fill: ${a};`),
                    h.appendChild(f)
                }
            }
            ,
            this.$s = () => {
                const t = this.m.song.beatsPerBar
                  , e = p.partsPerBeat
                  , i = e * t
                  , n = this.Bs[this.En]
                  , s = n.steps
                  , o = n.channel
                  , a = n.stepSizeNumerator / n.stepSizeDenominator
                  , r = this.Is[this.En]
                  , h = r.length > 0
                  , l = n.invert ? 0 : 1
                  , c = n.generateFadingNotes
                  , d = nt.getChannelColor(this.m.song, o)
                  , m = d.primaryNote
                  , u = d.secondaryNote
                  , f = this.Dn - this.Bn
                  , y = f * i
                  , b = this.Kn;
                for (; null !== b.firstChild; )
                    b.removeChild(b.firstChild);
                let g = [];
                const w = this.zn / t / e
                  , v = this.qn
                  , x = .2
                  , k = Math.floor(t * f / a)
                  , M = Math.ceil(t * (f + 1) / a)
                  , S = x
                  , F = v - .4;
                for (let t = k; t < M; t++) {
                    let n = !1
                      , o = !1;
                    const d = Math.floor(t * e * a) - y
                      , f = Math.floor((t + 1) * e * a) - y;
                    d < 0 && (n = !0),
                    (n || f > i) && (o = !0);
                    const v = Math.max(0, Math.min(i, d))
                      , k = Math.max(0, Math.min(i, f))
                      , M = x + v * w
                      , C = (k - v) * w - .4;
                    if (h && r[t % s] === l) {
                        if (c) {
                            const t = Y.rect({
                                x: M,
                                y: S,
                                width: C,
                                height: F,
                                style: `fill: ${u};`
                            });
                            b.appendChild(t);
                            let e = p.noteSizeMax
                              , i = 0;
                            if (o) {
                                const t = (v - d) / (f - d);
                                e = Math.round(p.noteSizeMax + (0 - p.noteSizeMax) * t);
                                const n = (k - d) / (f - d);
                                i = Math.round(p.noteSizeMax + (0 - p.noteSizeMax) * n)
                            }
                            e /= p.noteSizeMax,
                            i /= p.noteSizeMax;
                            const n = M
                              , s = S + F / 2 * (1 - e)
                              , a = M + C
                              , r = S + F / 2 * (1 - i)
                              , h = M + C
                              , l = S + F - F / 2 * (1 - i)
                              , c = M
                              , y = S + F - F / 2 * (1 - e)
                              , g = Y.path({
                                d: `M ${n} ${s} L ${a} ${r} L ${h} ${l} L ${c} ${y} z`,
                                style: `fill: ${m};`
                            });
                            b.appendChild(g)
                        } else {
                            const t = Y.rect({
                                x: M,
                                y: S,
                                width: C,
                                height: F,
                                style: `fill: ${m};`
                            });
                            b.appendChild(t)
                        }
                        if (n) {
                            let t = 2.2;
                            const e = Math.min(F, 20)
                              , i = S + F / 2;
                            let n;
                            n = "M " + q(w * v + t) + " " + q(i - .1 * e),
                            n += "L " + q(w * v + t) + " " + q(i + .1 * e),
                            n += "L " + q(w * v + t + 4) + " " + q(i + .1 * e),
                            n += "L " + q(w * v + t + 4) + " " + q(i + .3 * e),
                            n += "L " + q(w * v + t + 12) + " " + q(i),
                            n += "L " + q(w * v + t + 4) + " " + q(i - .3 * e),
                            n += "L " + q(w * v + t + 4) + " " + q(i - .1 * e);
                            const s = Y.path();
                            s.setAttribute("d", n),
                            s.setAttribute("fill", nt.invertedText),
                            g.push(s)
                        }
                    }
                }
                for (let t of g)
                    b.appendChild(t)
            }
            ,
            this.Bn = this.m.bar,
            this.Dn = this.Bn,
            this.Ln = p.barCountMax - this.Bn,
            this.ds.max = this.Ln + "",
            this.Cn = this.m.song.pitchChannelCount + this.m.song.noiseChannelCount - 1,
            this.ls.max = this.Cn + 1 + "";
            const c = Math.max(this.Mn, Math.min(this.Sn, this.m.song.beatsPerBar))
              , d = Math.max(0, Math.min(c, 5));
            if (this.Bs = [{
                steps: c,
                pulses: d,
                rotation: 0,
                stepSizeNumerator: 1,
                stepSizeDenominator: 4,
                channel: Math.max(0, Math.min(this.Cn, this.m.channel)),
                pitch: 0,
                invert: !1,
                generateFadingNotes: !1
            }],
            this.m.selection.boxSelectionActive) {
                this.Bn = this.m.selection.boxSelectionBar,
                this.Dn = this.Bn,
                this.In = Math.max(1, Math.min(this.Ln, this.m.selection.boxSelectionWidth)),
                this.Bs[0].channel = Math.max(0, Math.min(this.Cn, this.m.selection.boxSelectionChannel));
                for (let t = 1; t < this.m.selection.boxSelectionHeight; t++)
                    this.Bs.push({
                        steps: c,
                        pulses: d,
                        rotation: 0,
                        stepSizeNumerator: 1,
                        stepSizeDenominator: 4,
                        channel: Math.max(0, Math.min(this.Cn, this.m.selection.boxSelectionChannel + t)),
                        pitch: 0,
                        invert: !1,
                        generateFadingNotes: !1
                    })
            } else {
                const t = JSON.parse(String(window.localStorage.getItem(this.An)));
                if (null != t) {
                    const c = t.sequences;
                    if (null != c && Array.isArray(c)) {
                        let t = [];
                        for (let l of c)
                            t.push({
                                steps: Math.max(this.Mn, Math.min(this.Sn, null !== (e = l.steps) && void 0 !== e ? e : this.m.song.beatsPerBar)),
                                pulses: Math.max(0, Math.min(this.Sn, null !== (i = l.pulses) && void 0 !== i ? i : 5)),
                                rotation: Math.max(0, Math.min(this.Sn, null !== (n = l.rotation) && void 0 !== n ? n : 0)),
                                stepSizeNumerator: Math.max(1, Math.min(p.partsPerBeat, null !== (s = l.stepSizeNumerator) && void 0 !== s ? s : 1)),
                                stepSizeDenominator: Math.max(1, Math.min(p.partsPerBeat, null !== (o = l.stepSizeDenominator) && void 0 !== o ? o : 4)),
                                channel: Math.max(0, Math.min(this.Cn, l.channel)),
                                pitch: null !== (a = l.pitch) && void 0 !== a ? a : 0,
                                invert: null !== (r = l.invert) && void 0 !== r && r,
                                generateFadingNotes: null !== (h = l.generateFadingNotes) && void 0 !== h && h
                            });
                        if (this.Bs = t,
                        1 === this.Bs.length) {
                            const t = this.Bs[this.En]
                              , e = Math.max(0, Math.min(this.Cn, this.m.channel));
                            t.channel = e;
                            const i = this.m.song.getChannelIsNoise(e) ? p.drumCount - 1 : p.maxPitch;
                            t.pitch = Math.max(0, Math.min(i, t.pitch))
                        }
                    }
                    this.In = Math.max(1, Math.min(this.Ln, null !== (l = t.barAmount) && void 0 !== l ? l : this.In))
                }
            }
            this.Ls(),
            this.Re.addEventListener("click", this.He),
            this.Oe.addEventListener("click", this.$e),
            this.container.addEventListener("keydown", this.Ge),
            this.jn.addEventListener("click", this.ys),
            this.Yn.addEventListener("click", this.bs),
            this.Qn.addEventListener("click", this.gs),
            this.Zn.addEventListener("click", this.ws),
            this.Xn.addEventListener("click", this.vs),
            this.ns.addEventListener("change", this.xs),
            this.ss.addEventListener("change", this.ks),
            this.os.addEventListener("change", this.Ms),
            this.rs.addEventListener("change", this.Ss),
            this.hs.addEventListener("change", this.Ss),
            this.ls.addEventListener("change", this.Fs),
            this.cs.addEventListener("change", this.Cs),
            this.ds.addEventListener("change", this.As),
            this.fs.addEventListener("change", this.Es),
            this.us.addEventListener("change", this.Ts),
            this.ps.addEventListener("click", this.Ps),
            this.Vs(),
            this.Rs()
        }
    }
    function Gs(t, e) {
        const i = new ArrayBuffer(e);
        let n = 0
          , s = Math.min(t.byteLength, i.byteLength);
        const o = [8, 4, 2, 1];
        for (const e of o)
            if (s >= e) {
                const o = a(e, t, i, n, s);
                n = o.nextOffset,
                s = o.leftBytes
            }
        return i;
        function a(t, e, i, n, s) {
            let o = Uint8Array;
            switch (t) {
            case 8:
                o = Float64Array;
                break;
            case 4:
                o = Float32Array;
                break;
            case 2:
                o = Uint16Array;
                break;
            default:
                o = Uint8Array
            }
            const a = new o(e,n,s / t | 0)
              , r = new o(i,n,s / t | 0);
            for (let t = 0; t < r.length; t++)
                r[t] = a[t];
            return {
                nextOffset: a.byteOffset + a.byteLength,
                leftBytes: s - r.length * t
            }
        }
    }
    class Ws {
        constructor(t) {
            this.Ws = 0,
            this.js = 0,
            this.Us = new ArrayBuffer(t),
            this.Ks = new DataView(this.Us)
        }
        Js(t) {
            this.js += t,
            this.js > this.Us.byteLength && (this.Us = Gs(this.Us, Math.max(2 * this.Us.byteLength, this.js)),
            this.Ks = new DataView(this.Us))
        }
        getWriteIndex() {
            return this.Ws
        }
        rewriteUint32(t, e) {
            this.Ks.setUint32(t, e >>> 0, !1)
        }
        writeUint32(t) {
            t >>>= 0,
            this.Js(4),
            this.Ks.setUint32(this.Ws, t, !1),
            this.Ws = this.js
        }
        writeUint24(t) {
            t >>>= 0,
            this.Js(3),
            this.Ks.setUint8(this.Ws, t >> 16 & 255),
            this.Ks.setUint8(this.Ws + 1, t >> 8 & 255),
            this.Ks.setUint8(this.Ws + 2, 255 & t),
            this.Ws = this.js
        }
        writeUint16(t) {
            t >>>= 0,
            this.Js(2),
            this.Ks.setUint16(this.Ws, t, !1),
            this.Ws = this.js
        }
        writeUint8(t) {
            t >>>= 0,
            this.Js(1),
            this.Ks.setUint8(this.Ws, t),
            this.Ws = this.js
        }
        writeInt8(t) {
            t |= 0,
            this.Js(1),
            this.Ks.setInt8(this.Ws, t),
            this.Ws = this.js
        }
        writeMidi7Bits(t) {
            if ((t >>>= 0) >= 128)
                throw new Error("7 bit value contained 8th bit!");
            this.Js(1),
            this.Ks.setUint8(this.Ws, t),
            this.Ws = this.js
        }
        writeMidiVariableLength(t) {
            if ((t >>>= 0) > 268435455)
                throw new Error("writeVariableLength value too big.");
            let e = !1;
            for (let i = 0; i < 4; i++) {
                const n = t >>> 21 - 7 * i & 127;
                0 == n && 3 != i || (e = !0),
                e && this.writeUint8((3 == i ? 0 : 128) | n)
            }
        }
        writeMidiAscii(t) {
            this.writeMidiVariableLength(t.length);
            for (let e = 0; e < t.length; e++) {
                const i = t.charCodeAt(e);
                if (i > 127)
                    throw new Error("Trying to write unicode character as ascii.");
                this.writeUint8(i)
            }
        }
        toCompactArrayBuffer() {
            return Gs(this.Us, this.js)
        }
    }
    const js = 8192
      , Us = {
        35: {
            frequency: 0,
            duration: 2,
            volume: 3
        },
        36: {
            frequency: 0,
            duration: 2,
            volume: 3
        },
        37: {
            frequency: 5,
            duration: 1,
            volume: 3
        },
        38: {
            frequency: 4,
            duration: 2,
            volume: 3
        },
        39: {
            frequency: 5,
            duration: 2,
            volume: 3
        },
        40: {
            frequency: 4,
            duration: 2,
            volume: 3
        },
        41: {
            frequency: 1,
            duration: 2,
            volume: 3
        },
        42: {
            frequency: 8,
            duration: 1,
            volume: 3
        },
        43: {
            frequency: 1,
            duration: 2,
            volume: 3
        },
        44: {
            frequency: 8,
            duration: 1,
            volume: 2
        },
        45: {
            frequency: 2,
            duration: 2,
            volume: 3
        },
        46: {
            frequency: 8,
            duration: 4,
            volume: 3
        },
        47: {
            frequency: 2,
            duration: 2,
            volume: 3
        },
        48: {
            frequency: 3,
            duration: 2,
            volume: 3
        },
        49: {
            frequency: 7,
            duration: 4,
            volume: 3
        },
        50: {
            frequency: 3,
            duration: 2,
            volume: 3
        },
        51: {
            frequency: 6,
            duration: 4,
            volume: 2
        },
        52: {
            frequency: 7,
            duration: 4,
            volume: 3
        },
        53: {
            frequency: 6,
            duration: 2,
            volume: 3
        },
        54: {
            frequency: 11,
            duration: 2,
            volume: 3
        },
        55: {
            frequency: 9,
            duration: 4,
            volume: 3
        },
        56: {
            frequency: 7,
            duration: 1,
            volume: 2
        },
        57: {
            frequency: 7,
            duration: 4,
            volume: 3
        },
        58: {
            frequency: 10,
            duration: 2,
            volume: 2
        },
        59: {
            frequency: 6,
            duration: 4,
            volume: 3
        },
        69: {
            frequency: 10,
            duration: 2,
            volume: 3
        },
        70: {
            frequency: 10,
            duration: 2,
            volume: 3
        },
        73: {
            frequency: 10,
            duration: 1,
            volume: 2
        },
        74: {
            frequency: 10,
            duration: 2,
            volume: 2
        }
    };
    function Ks(t) {
        return Math.pow(t / 127, 4) / .3844015376046128
    }
    const {button: Js, div: Ys, h2: Qs, input: Zs, select: Xs, option: to} = J;
    function eo(t, e, i) {
        return t + i * (e - t)
    }
    function io(t, e) {
        if (navigator.msSaveOrOpenBlob)
            return void navigator.msSaveOrOpenBlob(t, e);
        const i = document.createElement("a");
        if (null != i.download) {
            const n = URL.createObjectURL(t);
            setTimeout((function() {
                URL.revokeObjectURL(n)
            }
            ), 6e4),
            i.href = n,
            i.download = e,
            setTimeout((function() {
                i.dispatchEvent(new MouseEvent("click"))
            }
            ), 0)
        } else {
            const e = URL.createObjectURL(t);
            setTimeout((function() {
                URL.revokeObjectURL(e)
            }
            ), 6e4),
            window.open(e, "_blank") || (window.location.href = e)
        }
    }
    class no {
        constructor(t) {
            this.m = t,
            this.outputStarted = !1,
            this.dn = Zs({
                type: "text",
                style: "width: 10em;",
                value: p.jsonFormat + "-Song",
                maxlength: 250,
                autofocus: "autofocus"
            }),
            this.Ys = Ys({
                style: "width: 10em;"
            }, new Text("0:00")),
            this.Qs = Zs({
                type: "checkbox"
            }),
            this.Zs = Zs({
                style: "width: 2em;",
                type: "number",
                min: "1",
                max: "4",
                step: "1"
            }),
            this.Xs = Zs({
                type: "checkbox"
            }),
            this.eo = Xs({
                style: "width: 100%;"
            }, to({
                value: "wav"
            }, "Export to .wav file."), to({
                value: "mp3"
            }, "Export to .mp3 file."), to({
                value: "midi"
            }, "Export to .mid file."), to({
                value: "json"
            }, "Export to .json file."), to({
                value: "html"
            }, "Export to .html file.")),
            this.io = Zs({
                type: "checkbox"
            }),
            this.no = Ys({
                style: "vertical-align: middle; align-items: center; justify-content: space-between; margin-bottom: 14px;"
            }, "Remove Whitespace: ", this.io),
            this.Oe = Js({
                class: "cancelButton"
            }),
            this.hn = Js({
                class: "exportButton",
                style: "width:45%;"
            }, "Export"),
            this.so = Ys({
                style: `width: 0%; background: ${nt.loopAccent}; height: 100%; position: absolute; z-index: 2;`
            }),
            this.oo = Ys({
                style: "position: relative; top: -1px; z-index: 3;"
            }, "0%"),
            this.ao = Ys({
                style: `height: 12px; background: ${nt.uiWidgetBackground}; display: block; position: relative; z-index: 1;`
            }, this.so, this.oo),
            this.container = Ys({
                class: "prompt noSelection",
                style: "width: 200px;"
            }, Qs("Export Options"), Ys({
                style: "display: flex; flex-direction: row; align-items: center; justify-content: space-between;"
            }, "File name:", this.dn), Ys({
                style: "display: flex; flex-direction: row; align-items: center; justify-content: space-between;"
            }, "Length:", this.Ys), Ys({
                style: "display: table; width: 100%;"
            }, Ys({
                style: "display: table-row;"
            }, Ys({
                style: "display: table-cell;"
            }, "Intro:"), Ys({
                style: "display: table-cell;"
            }, "Loop Count:"), Ys({
                style: "display: table-cell;"
            }, "Outro:")), Ys({
                style: "display: table-row;"
            }, Ys({
                style: "display: table-cell; vertical-align: middle;"
            }, this.Qs), Ys({
                style: "display: table-cell; vertical-align: middle;"
            }, this.Zs), Ys({
                style: "display: table-cell; vertical-align: middle;"
            }, this.Xs))), Ys({
                class: "selectContainer",
                style: "width: 100%;"
            }, this.eo), this.no, Ys({
                style: "text-align: left;"
            }, "Exporting can be slow. Reloading the page or clicking the X will cancel it. Please be patient."), this.ao, Ys({
                style: "display: flex; flex-direction: row-reverse; justify-content: space-between;"
            }, this.hn), this.Oe),
            this.$e = () => {
                null != this.synth && (this.synth.renderingSong = !1),
                this.outputStarted = !1,
                this.m.undo()
            }
            ,
            this.cleanUp = () => {
                this.dn.removeEventListener("input", no.mn),
                this.Zs.removeEventListener("blur", no.Ve),
                this.hn.removeEventListener("click", this.ro),
                this.Oe.removeEventListener("click", this.$e),
                this.container.removeEventListener("keydown", this.Ge)
            }
            ,
            this.Ge = t => {
                "BUTTON" != t.target.tagName && 13 == t.keyCode && this.ro()
            }
            ,
            this.ro = () => {
                if (1 != this.outputStarted)
                    switch (window.localStorage.setItem("exportFormat", this.eo.value),
                    window.localStorage.setItem("exportWhitespace", this.io.value),
                    this.eo.value) {
                    case "wav":
                        this.outputStarted = !0,
                        this.ho("wav");
                        break;
                    case "mp3":
                        this.outputStarted = !0,
                        this.ho("mp3");
                        break;
                    case "midi":
                        this.outputStarted = !0,
                        this.lo();
                        break;
                    case "json":
                        this.outputStarted = !0,
                        this.co();
                        break;
                    case "html":
                        this.do();
                        break;
                    default:
                        throw new Error("Unhandled file export type.")
                    }
            }
            ,
            this.Zs.value = "1",
            0 == this.m.song.loopStart ? (this.Qs.checked = !1,
            this.Qs.disabled = !0) : (this.Qs.checked = !0,
            this.Qs.disabled = !1),
            this.m.song.loopStart + this.m.song.loopLength == this.m.song.barCount ? (this.Xs.checked = !1,
            this.Xs.disabled = !0) : (this.Xs.checked = !0,
            this.Xs.disabled = !1);
            const e = window.localStorage.getItem("exportFormat");
            null != e && (this.eo.value = e);
            const i = "false" != window.localStorage.getItem("exportWhitespace");
            null != i && (this.io.checked = i),
            "json" == this.eo.value ? this.no.style.display = "block" : this.no.style.display = "none",
            this.dn.select(),
            setTimeout(( () => this.dn.focus())),
            this.dn.addEventListener("input", no.mn),
            this.Zs.addEventListener("blur", no.Ve),
            this.hn.addEventListener("click", this.ro),
            this.Oe.addEventListener("click", this.$e),
            this.Xs.addEventListener("click", ( () => {
                this.Ys.firstChild.textContent = this.samplesToTime(this.m.synth.getTotalSamples(this.Qs.checked, this.Xs.checked, +this.Zs.value - 1))
            }
            )),
            this.Qs.addEventListener("click", ( () => {
                this.Ys.firstChild.textContent = this.samplesToTime(this.m.synth.getTotalSamples(this.Qs.checked, this.Xs.checked, +this.Zs.value - 1))
            }
            )),
            this.Zs.addEventListener("change", ( () => {
                this.Ys.firstChild.textContent = this.samplesToTime(this.m.synth.getTotalSamples(this.Qs.checked, this.Xs.checked, +this.Zs.value - 1))
            }
            )),
            this.eo.addEventListener("change", ( () => {
                "json" == this.eo.value ? this.no.style.display = "block" : this.no.style.display = "none"
            }
            )),
            this.container.addEventListener("keydown", this.Ge),
            this.dn.value = t.song.title,
            no.mn(null, this.dn),
            this.Ys.firstChild.textContent = this.samplesToTime(this.m.synth.getTotalSamples(this.Qs.checked, this.Xs.checked, +this.Zs.value - 1))
        }
        samplesToTime(t) {
            const e = Math.round(t / this.m.synth.samplesPerSecond)
              , i = e % 60;
            return Math.floor(e / 60) + ":" + (i < 10 ? "0" : "") + i
        }
        changeFileName(t) {
            this.dn.value = t
        }
        static mn(t, e) {
            let i;
            if (null != t)
                i = t.target;
            else {
                if (null == e)
                    return;
                i = e
            }
            const n = /[\+\*\$\?\|\{\}\\\/<>#%!`&'"=:@]/gi;
            if (n.test(i.value)) {
                let t = i.selectionStart;
                i.value = i.value.replace(n, ""),
                t--,
                i.setSelectionRange(t, t)
            }
        }
        static Ve(t) {
            const e = t.target;
            e.value = Math.floor(Math.max(Number(e.min), Math.min(Number(e.max), Number(e.value)))) + ""
        }
        po() {
            if (0 == this.outputStarted)
                return;
            const t = 5 * this.synth.samplesPerSecond
              , e = this.currentChunk * t
              , i = Math.min(t, this.sampleFrames - e)
              , n = new Float32Array(i)
              , s = new Float32Array(i);
            if (this.synth.renderingSong = !0,
            this.synth.synthesize(n, s, i),
            this.recordedSamplesL.set(n, e),
            this.recordedSamplesR.set(s, e),
            this.so.style.setProperty("width", Math.round((this.currentChunk + 1) / this.totalChunks * 100) + "%"),
            this.oo.innerText = Math.round((this.currentChunk + 1) / this.totalChunks * 100) + "%",
            this.currentChunk++,
            this.currentChunk >= this.totalChunks)
                if (this.synth.renderingSong = !1,
                this.oo.innerText = "Encoding...",
                "wav" == this.thenExportTo)
                    this.mo();
                else {
                    if ("mp3" != this.thenExportTo)
                        throw new Error("Unrecognized file export type chosen!");
                    this.uo()
                }
            else
                setTimeout(( () => {
                    this.po()
                }
                ))
        }
        ho(t) {
            if (this.thenExportTo = t,
            this.currentChunk = 0,
            this.synth = new Jt(this.m.song),
            "wav" == t)
                this.synth.samplesPerSecond = 48e3;
            else {
                if ("mp3" != t)
                    throw new Error("Unrecognized file export type chosen!");
                this.synth.samplesPerSecond = 44100
            }
            if (this.so.style.setProperty("width", "0%"),
            this.oo.innerText = "0%",
            this.synth.loopRepeatCount = Number(this.Zs.value) - 1,
            !this.Qs.checked)
                for (let t = 0; t < this.m.song.loopStart; t++)
                    this.synth.goToNextBar();
            this.synth.initModFilters(this.m.song),
            this.synth.computeLatestModValues(),
            this.synth.warmUpSynthesizer(this.m.song),
            this.sampleFrames = this.synth.getTotalSamples(this.Qs.checked, this.Xs.checked, this.synth.loopRepeatCount),
            this.totalChunks = Math.ceil(this.sampleFrames / (5 * this.synth.samplesPerSecond)),
            this.recordedSamplesL = new Float32Array(this.sampleFrames),
            this.recordedSamplesR = new Float32Array(this.sampleFrames),
            setTimeout(( () => {
                this.po()
            }
            ))
        }
        mo() {
            const t = this.recordedSamplesL.length
              , e = this.synth.samplesPerSecond
              , i = 2 * t;
            let n = 0;
            const s = new ArrayBuffer(44 + 2 * i)
              , o = new DataView(s);
            o.setUint32(n, 1380533830, !1),
            n += 4,
            o.setUint32(n, 36 + 2 * i, !0),
            n += 4,
            o.setUint32(n, 1463899717, !1),
            n += 4,
            o.setUint32(n, 1718449184, !1),
            n += 4,
            o.setUint32(n, 16, !0),
            n += 4,
            o.setUint16(n, 1, !0),
            n += 2,
            o.setUint16(n, 2, !0),
            n += 2,
            o.setUint32(n, e, !0),
            n += 4,
            o.setUint32(n, 2 * e * 2, !0),
            n += 4,
            o.setUint16(n, 4, !0),
            n += 2,
            o.setUint16(n, 16, !0),
            n += 2,
            o.setUint32(n, 1684108385, !1),
            n += 4,
            o.setUint32(n, 2 * i, !0),
            n += 4;
            {
                const e = 32767;
                for (let i = 0; i < t; i++) {
                    let t = Math.floor(Math.max(-1, Math.min(1, this.recordedSamplesL[i])) * e)
                      , s = Math.floor(Math.max(-1, Math.min(1, this.recordedSamplesR[i])) * e);
                    o.setInt16(n, t, !0),
                    n += 2,
                    o.setInt16(n, s, !0),
                    n += 2
                }
            }
            io(new Blob([s],{
                type: "audio/wav"
            }), this.dn.value.trim() + ".wav"),
            this.$e()
        }
        uo() {
            const t = () => {
                const t = 1152
                  , e = new window.lamejs.Mp3Encoder(2,this.synth.samplesPerSecond,192)
                  , i = []
                  , n = new Int16Array(this.recordedSamplesL.length)
                  , s = new Int16Array(this.recordedSamplesR.length);
                for (let t = 0; t < this.recordedSamplesL.length; t++)
                    n[t] = Math.floor(32767 * Math.max(-1, Math.min(1, this.recordedSamplesL[t]))),
                    s[t] = Math.floor(32767 * Math.max(-1, Math.min(1, this.recordedSamplesR[t])));
                for (let o = 0; o < n.length; o += t) {
                    const a = n.subarray(o, o + t)
                      , r = s.subarray(o, o + t)
                      , h = e.encodeBuffer(a, r);
                    h.length > 0 && i.push(h)
                }
                const o = e.flush();
                o.length > 0 && i.push(o);
                io(new Blob(i,{
                    type: "audio/mp3"
                }), this.dn.value.trim() + ".mp3"),
                this.$e()
            }
            ;
            if ("lamejs"in window)
                t();
            else {
                var e = document.createElement("script");
                e.src = "https://cdn.jsdelivr.net/npm/lamejs@1.2.0/lame.min.js",
                e.onload = t,
                document.head.appendChild(e)
            }
        }
        lo() {
            const t = this.m.song
              , e = 2 * p.ticksPerPart * p.partsPerBeat
              , i = 2 * p.ticksPerPart
              , n = t.getBeatsPerMinute()
              , s = Math.round(6e7 / n)
              , o = e * t.beatsPerBar
              , a = 24
              , r = [];
            if (this.Qs.checked)
                for (let u = 0; u < t.loopStart; u++)
                    r.push(u);
            for (let f = 0; f < Number(this.Zs.value); f++)
                for (let y = t.loopStart; y < t.loopStart + t.loopLength; y++)
                    r.push(y);
            if (this.Xs.checked)
                for (let b = t.loopStart + t.loopLength; b < t.barCount; b++)
                    r.push(b);
            const h = [{
                isMeta: !0,
                channel: -1,
                midiChannel: -1,
                isNoise: !1,
                isDrumset: !1
            }];
            let l = 0
              , c = !1;
            for (let g = 0; g < this.m.song.pitchChannelCount + this.m.song.noiseChannelCount; g++)
                if (c || 4 != this.m.song.channels[g].instruments[0].type) {
                    if (l >= 16)
                        continue;
                    h.push({
                        isMeta: !1,
                        channel: g,
                        midiChannel: l++,
                        isNoise: this.m.song.getChannelIsNoise(g),
                        isDrumset: !1
                    }),
                    9 == l && l++
                } else
                    h.push({
                        isMeta: !1,
                        channel: g,
                        midiChannel: 9,
                        isNoise: !0,
                        isDrumset: !0
                    }),
                    c = !0;
            const d = new Ws(1024);
            d.writeUint32(1297377380),
            d.writeUint32(6),
            d.writeUint16(1),
            d.writeUint16(h.length),
            d.writeUint16(e);
            for (const w of h) {
                d.writeUint32(1297379947);
                const {isMeta: v, channel: k, midiChannel: M, isNoise: S, isDrumset: F} = w
                  , C = d.getWriteIndex();
                d.writeUint32(0);
                let A = 0
                  , E = 0;
                const T = function(t) {
                    if (t < A)
                        throw new Error("Midi event time cannot go backwards.");
                    d.writeMidiVariableLength(t - A),
                    A = t
                }
                  , P = function(t, e) {
                    if (!(e >= 0 && e <= 127))
                        throw new Error("Midi control event value out of range: " + e);
                    d.writeUint8(176 | M),
                    d.writeMidi7Bits(t),
                    d.writeMidi7Bits(0 | e)
                };
                if (v) {
                    T(0),
                    d.writeUint8(255),
                    d.writeMidi7Bits(1),
                    d.writeMidiAscii("Composed with jummbus.bitbucket.io"),
                    T(0),
                    d.writeUint8(255),
                    d.writeMidi7Bits(81),
                    d.writeMidiVariableLength(3),
                    d.writeUint24(s),
                    T(0),
                    d.writeUint8(255),
                    d.writeMidi7Bits(88),
                    d.writeMidiVariableLength(4),
                    d.writeUint8(t.beatsPerBar),
                    d.writeUint8(2),
                    d.writeUint8(24),
                    d.writeUint8(8);
                    let B = t.scale == p.scales.dictionary.Custom.index ? t.scaleCustom : p.scales[t.scale].flags;
                    const I = B[3] && !B[4]
                      , L = t.key;
                    let D = L;
                    for (1 == (1 & L) && (D += 6),
                    I && (D += 9); D > 6; )
                        D -= 12;
                    T(0),
                    d.writeUint8(255),
                    d.writeMidi7Bits(89),
                    d.writeMidiVariableLength(2),
                    d.writeInt8(D),
                    d.writeUint8(I ? 1 : 0),
                    this.Qs.checked && (E += o * t.loopStart),
                    T(E),
                    d.writeUint8(255),
                    d.writeMidi7Bits(6),
                    d.writeMidiAscii("Loop Start");
                    for (let z = 0; z < parseInt(this.Zs.value); z++)
                        E += o * t.loopLength,
                        T(E),
                        d.writeUint8(255),
                        d.writeMidi7Bits(6),
                        d.writeMidiAscii(z < Number(this.Zs.value) - 1 ? "Loop Repeat" : "Loop End");
                    if (this.Xs.checked && (E += o * (t.barCount - t.loopStart - t.loopLength)),
                    E != o * r.length)
                        throw new Error("Miscalculated number of bars.")
                } else {
                    let q = S ? "noise channel " + k : "pitch channel " + k;
                    T(0),
                    d.writeUint8(255),
                    d.writeMidi7Bits(3),
                    d.writeMidiAscii(q),
                    T(0),
                    P(101, 0),
                    T(0),
                    P(100, 0),
                    T(0),
                    P(6, a),
                    T(0),
                    P(38, 0),
                    T(0),
                    P(101, 127),
                    T(0),
                    P(100, 127);
                    let O = -1;
                    function R(e) {
                        const i = t.channels[k].instruments[e]
                          , n = N.valueToPreset(i.preset);
                        if (O != e) {
                            if (O = e,
                            T(E),
                            d.writeUint8(255),
                            d.writeMidi7Bits(4),
                            d.writeMidiAscii("Instrument " + (e + 1)),
                            !F) {
                                let t = 81;
                                if (null != n && null != n.midiProgram)
                                    t = n.midiProgram;
                                else if (4 == i.type)
                                    t = 116;
                                else if (2 == i.type || 3 == i.type)
                                    t = S ? 116 : 75;
                                else if (0 == i.type)
                                    no.midiChipInstruments.length > i.chipWave && (t = no.midiChipInstruments[i.chipWave]);
                                else if (6 == i.type || 1 == i.type || 11 == i.type || 5 == i.type || 8 == i.type)
                                    t = 81;
                                else if (7 == i.type)
                                    t = 25;
                                else {
                                    if (9 != i.type)
                                        throw new Error("Unrecognized instrument type.");
                                    t = 81
                                }
                                T(E),
                                d.writeUint8(192 | M),
                                d.writeMidi7Bits(t)
                            }
                            T(E);
                            let t = (s = Jt.instrumentVolumeToVolumeMult(i.volume),
                            127 * Math.pow(.3844015376046128 * s, .25));
                            P(7, Math.min(127, Math.round(t))),
                            T(E);
                            let o = 63 * (i.pan / p.panCenter - 1) + 64;
                            P(10, Math.min(127, Math.round(o)))
                        }
                        var s
                    }
                    null == t.getPattern(k, 0) && R(0);
                    let $ = js
                      , H = 127
                      , _ = !1;
                    const V = S ? p.spectrumBasePitch : p.keys[t.key].basePitch
                      , G = S ? p.noiseInterval : 1;
                    for (const W of r) {
                        const j = t.getPattern(k, W);
                        if (null != j) {
                            const U = j.instruments[0]
                              , K = t.channels[k].instruments[U]
                              , J = N.valueToPreset(K.preset);
                            R(U);
                            let Y = K.getChord().arpeggiates
                              , Q = Y ? 1 : p.maxChordSize;
                            K.getChord().customInterval && (0 == K.type || 5 == K.type ? (Q = 2,
                            Y = !0) : 1 == K.type ? Q = p.operatorCount : console.error("Unrecognized instrument type for harmonizing arpeggio: " + K.type));
                            for (let Z = 0; Z < j.notes.length; Z++) {
                                const X = j.notes[Z]
                                  , tt = E + X.start * i;
                                let et = tt
                                  , it = X.pins[0].size
                                  , nt = X.pins[0].interval;
                                const st = [-1, -1, -1, -1]
                                  , ot = [-1, -1, -1, -1]
                                  , at = Math.min(Q, X.pitches.length)
                                  , rt = F ? Math.max(1, Math.round(90 * X.pins[0].size / p.noteSizeMax)) : 90;
                                let ht = X.pickMainInterval()
                                  , lt = ht * G;
                                if (!F) {
                                    let dt = a
                                      , pt = -24;
                                    for (let mt = 1; mt < X.pins.length; mt++) {
                                        const ut = X.pins[mt].interval * G;
                                        dt = Math.min(dt, ut + a),
                                        pt = Math.max(pt, ut - a)
                                    }
                                    lt = Math.min(dt, Math.max(pt, lt))
                                }
                                for (let ft = 1; ft < X.pins.length; ft++) {
                                    const yt = tt + X.pins[ft].time * i
                                      , bt = X.pins[ft].size
                                      , gt = X.pins[ft].interval
                                      , wt = yt - et;
                                    for (let vt = 0; vt < wt; vt++) {
                                        const xt = et + vt
                                          , kt = eo(it, bt, vt / wt)
                                          , Mt = eo(nt, gt, vt / wt) * G - lt
                                          , St = Math.max(0, Math.min(16383, Math.round(8192 * (1 + Mt / a))))
                                          , Ft = Math.min(127, Math.round((m = Jt.noteSizeToVolumeMult(kt),
                                        127 * Math.pow(m, .25))));
                                        St != $ && (T(xt),
                                        d.writeUint8(224 | M),
                                        d.writeMidi7Bits(127 & St),
                                        d.writeMidi7Bits(St >> 7 & 127),
                                        $ = St),
                                        Ft == H || F || (T(xt),
                                        P(11, Ft),
                                        H = Ft);
                                        const Ct = xt == tt;
                                        for (let At = 0; At < at; At++) {
                                            let Et = X.pitches[At];
                                            if (F) {
                                                Et += ht;
                                                const Tt = [36, 41, 45, 48, 40, 39, 59, 49, 46, 55, 69, 54];
                                                if (Et < 0 || Et >= Tt.length)
                                                    throw new Error("Could not find corresponding drumset pitch. " + Et);
                                                Et = Tt[Et]
                                            } else {
                                                if (Y && X.pitches.length > At + 1 && At == at - 1) {
                                                    const Pt = (xt - E) % e
                                                      , Bt = p.ticksPerArpeggio * i / p.ticksPerPart
                                                      , It = Math.floor(Pt / Bt);
                                                    Et = X.pitches[At + x(X.pitches.length - At, K.fastTwoNoteArp, It)]
                                                }
                                                Et = V + Et * G + lt,
                                                null != J && null != J.midiSubharmonicOctaves ? Et += 12 * J.midiSubharmonicOctaves : S && (Et += 12 * +N.presetCategories.dictionary["Drum Presets"].presets.dictionary["taiko drum"].midiSubharmonicOctaves),
                                                S && (Et *= 2)
                                            }
                                            Et = Math.max(0, Math.min(127, Et)),
                                            ot[At] = Et,
                                            Ct || st[At] == ot[At] || (T(xt),
                                            d.writeUint8(128 | M),
                                            d.writeMidi7Bits(st[At]),
                                            d.writeMidi7Bits(rt))
                                        }
                                        for (let Lt = 0; Lt < at; Lt++)
                                            (Ct || st[Lt] != ot[Lt]) && (T(xt),
                                            d.writeUint8(144 | M),
                                            d.writeMidi7Bits(ot[Lt]),
                                            d.writeMidi7Bits(rt),
                                            st[Lt] = ot[Lt])
                                    }
                                    et = yt,
                                    it = bt,
                                    nt = gt
                                }
                                const ct = E + X.end * i;
                                for (let Dt = 0; Dt < at; Dt++)
                                    T(ct),
                                    d.writeUint8(128 | M),
                                    d.writeMidi7Bits(st[Dt]),
                                    d.writeMidi7Bits(rt);
                                _ = !0
                            }
                        } else
                            _ && (_ = !1,
                            127 != H && (H = 127,
                            T(E),
                            P(11, H)),
                            $ != js && ($ = js,
                            T(E),
                            d.writeUint8(224 | M),
                            d.writeMidi7Bits(127 & $),
                            d.writeMidi7Bits($ >> 7 & 127)));
                        E += o
                    }
                }
                T(E),
                d.writeUint8(255),
                d.writeMidi7Bits(47),
                d.writeMidiVariableLength(0),
                d.rewriteUint32(C, d.getWriteIndex() - C - 4)
            }
            var m;
            io(new Blob([d.toCompactArrayBuffer()],{
                type: "audio/midi"
            }), this.dn.value.trim() + ".mid"),
            this.$e()
        }
        co() {
            const t = this.m.song.toJsonObject(this.Qs.checked, Number(this.Zs.value), this.Xs.checked);
            let e = this.io.checked ? void 0 : "\t";
            const i = JSON.stringify(t, null, e);
            io(new Blob([i],{
                type: "application/json"
            }), this.dn.value.trim() + ".json"),
            this.$e()
        }
        do() {
            const t = `<!DOCTYPE html><meta charset="utf-8">\n\nYou should be redirected to the song at:<br /><br />\n\n<a id="destination" href="${new URL("#" + this.m.song.toBase64String(),location.href).href}"></a>\n\n<style>\n\t:root {\n\t\tcolor: white;\n\t\tbackground: black;\n\t\tfont-family:\n\t\tsans-serif;\n\t}\n\ta {\n\t\tcolor: #98f;\n\t}\n\ta[href]::before {\n\t\tcontent: attr(href);\n\t}\n</style>\n\n<script>\n\tlocation.assign(document.querySelector("a#destination").href);\n<\/script>\n`;
            io(new Blob([t],{
                type: "text/html"
            }), this.dn.value.trim() + ".html"),
            this.$e()
        }
    }
    no.midiChipInstruments = [74, 71, 80, 70, 68, 81, 81, 81, 81];
    class so {
        static setLayout(t) {
            this.l.textContent = this.fo[t]
        }
    }
    so.fo = {
        small: "",
        long: `\n\t\t\t/* long layout */\n\t\t\t@media (min-width: 711px) {\n\t\t\t\t#beepboxEditorContainer {\n\t\t\t\t\tmax-width: initial;\n\t\t\t\t\theight: 100vh;\n\t\t\t\t\tpadding-top: 0px;\n\t\t\t\t}\n\t\t\t\t.beepboxEditor {\n\t\t\t\t\twidth: 100%;\n\t\t\t\t\theight: 100vh;\n\t\t\t\t\tgrid-template-columns: minmax(0, 1fr) 390px; /* minmax(0, 1fr) min-content; Chrome 80 grid layout regression. https://bugs.chromium.org/p/chromium/issues/detail?id=1050307 */\n\t\t\t\t\tgrid-template-rows: minmax(481px, 1fr) minmax(0, min-content);\n\t\t\t\t\tgrid-template-areas: "pattern-area settings-area" "track-area track-area";\n\t\t\t\t}\n\t\t\t\t.beepboxEditor .pattern-area {\n\t\t\t\t\twidth: 100%;\n\t\t\t\t\theight: 100%;\n\t\t\t\t}\n\t\t\t\t.beepboxEditor .track-area {\n\t\t\t\t\twidth: 100%;\n\t\t\t\t\tdisplay: flex;\n\t\t\t\t\tflex-direction: column;\n\t\t\t\t}\n\t\t\t\t.beepboxEditor .trackAndMuteContainer {\n\t\t\t\t\twidth: 100%;\n\t\t\t\t\tmin-height: 0;\n\t\t\t\t\tflex: 1;\n\t\t\t\t\toverflow: auto;\n\t\t\t\t\tmax-height: 97.5vh;\n\t\t\t\t}\n\t\t\t\t.beepboxEditor .instrument-settings-area {\n\t\t\t\t\toverflow-y: auto;\n\t\t\t\t\tposition: relative;\n\t\t\t\t}\n\t\t\t\t.beepboxEditor .instrument-settings-area > .editor-controls {\n\t\t\t\t\tposition: absolute;\n\t\t\t\t\twidth: 100%;\n\t\t\t\t}\n\t\t\t\t.beepboxEditor .song-settings-area {\n\t\t\t\t\toverflow-y: auto;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t.beepboxEditor .settings-area {\n\t\t\t\t\twidth: 390px;\n\t\t\t\t\tgrid-template-columns: minmax(0, 1fr) minmax(0, 1fr);\n\t\t\t\t\tgrid-template-rows: auto auto auto minmax(0, 1fr);\n\t\t\t\t\tgrid-template-areas:\n\t\t\t\t\t\t"instrument-settings-area version-area"\n\t\t\t\t\t\t"instrument-settings-area play-pause-area"\n\t\t\t\t\t\t"instrument-settings-area menu-area"\n\t\t\t\t\t\t"instrument-settings-area song-settings-area";\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t.beepboxEditor .barScrollBar {\n\t\t\t\t\tdisplay: none;\n\t\t\t\t}\n\t\t\t\t.beepboxEditor.selectRow {\n\t\t\t\t\theight: 2em;\n\t\t\t\t}\n\t\t\t\t.beepboxEditor .trackAndMuteContainer {\n\t\t\t\t\tmax-height: 446px;\n\t\t\t\t}\n\n\t\t\t\t.beepboxEditor .trackContainer {\n\t\t\t\t\toverflow: visible;\n\t\t\t\t}\n\t\t\t\t.beepboxEditor .trackAndMuteContainer {\n\t\t\t\t\tscrollbar-width: auto;\n\t\t\t\t}\n\t\t\t\t.beepboxEditor .trackAndMuteContainer::-webkit-scrollbar {\n\t\t\t\t\twidth: 20px;\n\t\t\t\t\theight: 20px;\n\t\t\t\t}\n\t\t\t\t.beepboxEditor .trackAndMuteContainer::-webkit-scrollbar-track {\n\t\t\t\t\tbackground: ${nt.editorBackground};\n\t\t\t\t}\n\t\t\t\t.beepboxEditor .trackAndMuteContainer::-webkit-scrollbar-thumb {\n\t\t\t\t\tbackground-color: ${nt.uiWidgetBackground};\n\t\t\t\t\tborder: 3px solid ${nt.editorBackground};\n\t\t\t\t}\n\t\t\t\t.beepboxEditor .trackAndMuteContainer::-webkit-scrollbar-corner {\n\t\t\t\t\tbackground-color: ${nt.editorBackground};\n\t\t\t\t}\n\t\t\t}\n\t\t`,
        tall: `\t\t\t/* tall layout */\n\t\t\t@media (min-width: 711px) {\n\t\t\t\t#beepboxEditorContainer {\n\t\t\t\t\tmax-width: initial;\n\t\t\t\t\theight: 100vh;\n\t\t\t\t\tpadding-top: 0px;\n\t\t\t\t}\n\t\t\t\t.beepboxEditor {\n\t\t\t\t\twidth: 100%;\n\t\t\t\t\theight: 100vh;\n\t\t\t\t\tgrid-template-columns: minmax(0, 1fr) minmax(0, 1fr) 192px;\n\t\t\t\t\tgrid-template-rows: 1fr;\n\t\t\t\t\tgrid-template-areas: "track-area pattern-area settings-area";\n\t\t\t\t}\n\t\t\t\t.beepboxEditor .pattern-area {\n\t\t\t\t\twidth: 100%;\n\t\t\t\t\theight: 100%;\n\t\t\t\t}\n\t\t\t\t.beepboxEditor .track-area {\n\t\t\t\t\twidth: 100%;\n\t\t\t\t\theight: 100%;\n\t\t\t\t\tdisplay: flex;\n\t\t\t\t\tflex-direction: column;\n\t\t\t\t\tjustify-content: center;\n\t\t\t\t}\n\t\t\t\t.beepboxEditor .trackAndMuteContainer {\n\t\t\t\t\twidth: 100%;\n\t\t\t\t\tmin-height: 0;\n\t\t\t\t\tflex: 0;\n\t\t\t\t\toverflow: auto;\n\t\t\t\t\tflex-basis: initial;\n\t\t\t\t\tflex-grow: 0;\n\t\t\t\t\tmax-height: 97.5vh;\n\t\t\t\t}\n\t\t\t\t.beepboxEditor .instrument-settings-area > .editor-controls {\n\t\t\t\t\tposition: absolute;\n\t\t\t\t\twidth: 100%;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t.beepboxEditor .settings-area {\n\t\t\t\t\twidth: 192px;\n\t\t\t\t\tposition: relative;\n\t\t\t\t\toverflow-y: auto;\n\t\t\t\t\tgrid-template-columns: minmax(0, 1fr);\n\t\t\t\t\tgrid-template-rows: auto auto auto auto minmax(0, 1fr);\n\t\t\t\t\tgrid-template-areas:\n\t\t\t\t\t\t"version-area"\n\t\t\t\t\t\t"play-pause-area"\n\t\t\t\t\t\t"menu-area"\n\t\t\t\t\t\t"song-settings-area"\n\t\t\t\t\t\t"instrument-settings-area";\n\t\t\t\t}\n\t\t\t\t.beepboxEditor .version-area {\n\t\t\t\t\tposition: sticky;\n\t\t\t\t\ttop: 0;\n\t\t\t\t\tz-index: 1;\n\t\t\t\t\tbackground: ${nt.editorBackground};\n\t\t\t\t}\n\t\t\t\t.beepboxEditor .play-pause-area {\n\t\t\t\t\tposition: sticky;\n\t\t\t\t\ttop: 22px;\n\t\t\t\t\tz-index: 1;\n\t\t\t\t\tbackground: ${nt.editorBackground};\n\t\t\t\t}\n\t\t\t\t.beepboxEditor .menu-area {\n\t\t\t\t\tposition: sticky;\n\t\t\t\t\ttop: 82px;\n\t\t\t\t\tz-index: 1;\n\t\t\t\t\tbackground: ${nt.editorBackground};\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t.beepboxEditor .barScrollBar {\n\t\t\t\t\tdisplay: none;\n\t\t\t\t}\n\t\t\t\t.beepboxEditor .trackContainer {\n\t\t\t\t\toverflow: visible;\n\t\t\t\t}\n\t\t\t\t.beepboxEditor .trackAndMuteContainer {\n\t\t\t\t\tscrollbar-width: auto;\n\t\t\t\t}\n\t\t\t\t.beepboxEditor .trackAndMuteContainer::-webkit-scrollbar {\n\t\t\t\t\twidth: 20px;\n\t\t\t\t\theight: 20px;\n\t\t\t\t}\n\t\t\t\t.beepboxEditor .trackAndMuteContainer::-webkit-scrollbar-track {\n\t\t\t\t\tbackground: ${nt.editorBackground};\n\t\t\t\t}\n\t\t\t\t.beepboxEditor .trackAndMuteContainer::-webkit-scrollbar-thumb {\n\t\t\t\t\tbackground-color: ${nt.uiWidgetBackground};\n\t\t\t\t\tborder: 3px solid ${nt.editorBackground};\n\t\t\t\t}\n\t\t\t\t.beepboxEditor .trackAndMuteContainer::-webkit-scrollbar-corner {\n\t\t\t\t\tbackground-color: ${nt.editorBackground};\n\t\t\t\t}\n\t\t\t}\n\t\t`,
        wide: `\t\t\t/* wide (JB) layout */\n\t\t\t@media (min-width: 1001px) {\n\t\t\t\t#beepboxEditorContainer {\n\t\t\t\t\tmax-width: initial;\n\t\t\t\t\theight: 100vh;\n\t\t\t\t\tpadding-top: 0px;\n\t\t\t\t}\n\t\t\t\t.beepboxEditor {\n\t\t\t\t\twidth: 100%;\n\t\t\t\t\theight: 100vh;\n\t\t\t\t\tgrid-template-columns: 512px minmax(0, 1fr) 30em;\n\t\t\t\t\tgrid-template-rows: minmax(481px, 1fr) min-content;\n\t\t\t\t\tgrid-template-areas: "track-area pattern-area settings-area";\n\t\t\t\t}\n\t\t\t\t.beepboxEditor .pattern-area {\n\t\t\t\t\twidth: 100%;\n\t\t\t\t\theight: 100%;\n\t\t\t\t}\n\t\t\t\t.beepboxEditor .track-area {\n\t\t\t\t\twidth: 100%;\n\t\t\t\t\theight: 100%;\n\t\t\t\t\tmax-height: 100%\n\t\t\t\t}\n\t\t\t\t.beepboxEditor .editor-widget-column {\n\t\t\t\t\tflex: 0;\n\t\t\t\t}\n\t\t\t\t.beepboxEditor .trackAndMuteContainer {\n\t\t\t\t\twidth: 100%;\n\t\t\t\t\tflex: 0;\n\t\t\t\t\tflex-basis: initial;\n\t\t\t\t\tflex-grow: 0;\n\t\t\t\t\toverflow-y: auto;\n\t\t\t\t\tmax-height: 97.5vh;\n\t\t\t\t}\n\t\t\t\t.beepboxEditor .instrument-settings-area {\n\t\t\t\t\toverflow-y: auto;\n\t\t\t\t\tposition: relative;\n\t\t\t\t}\n\t\t\t\t.beepboxEditor .instrument-settings-area > .editor-controls {\n\t\t\t\t\tposition: absolute;\n\t\t\t\t\twidth: 100%;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t.beepboxEditor .song-settings-area {\n\t\t\t\t\toverflow-y: auto;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t.beepboxEditor .settings-area {\n\t\t\t\t\twidth: 30em;\n\t\t\t\t\tgrid-template-columns: minmax(0, 1fr) minmax(0, 1fr);\n\t\t\t\t\tgrid-template-rows: auto auto auto minmax(0, 1fr);\n\t\t\t\t\tgrid-template-areas:\n\t\t\t\t\t\t"instrument-settings-area version-area"\n\t\t\t\t\t\t"instrument-settings-area play-pause-area"\n\t\t\t\t\t\t"instrument-settings-area menu-area"\n\t\t\t\t\t\t"instrument-settings-area song-settings-area";\n\t\t\t\t}\n\t\t\t\t.beepboxEditor .version-area {\n\t\t\t\t\tposition: sticky;\n\t\t\t\t\ttop: 0;\n\t\t\t\t\tz-index: 1;\n\t\t\t\t\tbackground: ${nt.editorBackground};\n\t\t\t\t}\n\t\t\t\t.beepboxEditor .play-pause-area {\n\t\t\t\t\tposition: sticky;\n\t\t\t\t\ttop: 22px;\n\t\t\t\t\tz-index: 1;\n\t\t\t\t\tbackground: ${nt.editorBackground};\n\t\t\t\t}\n\t\t\t\t.beepboxEditor .menu-area {\n\t\t\t\t\tposition: sticky;\n\t\t\t\t\ttop: 82px;\n\t\t\t\t\tz-index: 1;\n\t\t\t\t\tbackground: ${nt.editorBackground};\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t.beepboxEditor .trackContainer {\n\t\t\t\t\toverflow: visible;\n\t\t\t\t}\n\t\t\t}\n\t\t`,
        "flipped long": `\n            \t/* AB Special layout */\n\t\t\t@media (min-width: 711px) {\n\t\t\t\t#beepboxEditorContainer {\n\t\t\t\t\tmax-width: initial;\n\t\t\t\t\theight: 100vh;\n\t\t\t\t\tpadding-top: 0px;\n\t\t\t\t}\n\t\t\t\t.beepboxEditor {\n\t\t\t\t\twidth: 100%;\n\t\t\t\t\theight: 100vh;\n\t\t\t\t\tgrid-template-columns: 390px minmax(0, 1fr);\n\t\t\t\t\tgrid-template-rows: minmax(481px, 1fr) minmax(0, min-content);\n\t\t\t\t\tgrid-template-areas: "settings-area pattern-area" "track-area track-area";\n\t\t\t\t}\n\t\t\t\t.beepboxEditor .pattern-area {\n\t\t\t\t\twidth: 100%;\n\t\t\t\t\theight: 100%;\n\t\t\t\t}\n\t\t\t\t.beepboxEditor .track-area {\n\t\t\t\t\twidth: 100%;\n\t\t\t\t\tdisplay: flex;\n\t\t\t\t\tflex-direction: column;\n\t\t\t\t}\n\t\t\t\t.beepboxEditor .trackAndMuteContainer {\n\t\t\t\t\twidth: 100%;\n\t\t\t\t\tmin-height: 0;\n\t\t\t\t\tflex: 1;\n\t\t\t\t\toverflow: auto;\n\t\t\t\t\tmax-height: 97.5vh;\n\t\t\t\t}\n\t\t\t\t.beepboxEditor .instrument-settings-area {\n\t\t\t\t\toverflow-y: auto;\n\t\t\t\t\tposition: relative;\n\t\t\t\t}\n\t\t\t\t.beepboxEditor .instrument-settings-area > .editor-controls {\n\t\t\t\t\tposition: absolute;\n\t\t\t\t\twidth: 100%;\n\t\t\t\t}\n\t\t\t\t.beepboxEditor .song-settings-area {\n\t\t\t\t\toverflow-y: auto;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t.beepboxEditor .settings-area {\n\t\t\t\t\twidth: 30em;\n\t\t\t\t\tgrid-template-columns: minmax(0, 1fr) minmax(0, 1fr);\n\t\t\t\t\tgrid-template-rows: auto auto auto minmax(0, 1fr);\n\t\t\t\t\tgrid-template-areas:\n\t\t\t\t\t\t"version-area instrument-settings-area"\n\t\t\t\t\t\t"play-pause-area instrument-settings-area"\n\t\t\t\t\t\t"menu-area instrument-settings-area"\n\t\t\t\t\t\t"song-settings-area instrument-settings-area";\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t.beepboxEditor .barScrollBar {\n\t\t\t\t\tdisplay: none;\n\t\t\t\t}\n\t\t\t\t.beepboxEditor.selectRow {\n\t\t\t\t\theight: 2em;\n\t\t\t\t}\n\t\t\t\t.beepboxEditor .trackAndMuteContainer {\n\t\t\t\t\tmax-height: 446px;\n\t\t\t\t}\n\n\t\t\t\t.beepboxEditor .trackContainer {\n\t\t\t\t\toverflow: visible;\n\t\t\t\t}\n\t\t\t\t.beepboxEditor .trackAndMuteContainer {\n\t\t\t\t\tscrollbar-width: auto;\n\t\t\t\t}\n\t\t\t\t.beepboxEditor .trackAndMuteContainer::-webkit-scrollbar {\n\t\t\t\t\twidth: 20px;\n\t\t\t\t\theight: 20px;\n\t\t\t\t}\n\t\t\t\t.beepboxEditor .trackAndMuteContainer::-webkit-scrollbar-track {\n\t\t\t\t\tbackground: ${nt.editorBackground};\n\t\t\t\t}\n\t\t\t\t.beepboxEditor .trackAndMuteContainer::-webkit-scrollbar-thumb {\n\t\t\t\t\tbackground-color: ${nt.uiWidgetBackground};\n\t\t\t\t\tborder: 3px solid ${nt.editorBackground};\n\t\t\t\t}\n\t\t\t\t.beepboxEditor .trackAndMuteContainer::-webkit-scrollbar-corner {\n\t\t\t\t\tbackground-color: ${nt.editorBackground};\n\t\t\t\t}\n\t\t\t}\n\t\t`,
        "wide long": `\n\t\t\t@media (min-width: 711px) {\n\t\t\t\t#beepboxEditorContainer {\n\t\t\t\t\tmax-width: initial;\n\t\t\t\t\theight: 100vh;\n\t\t\t\t\tpadding-top: 0px;\n\t\t\t\t}\n\t\t\t\t.beepboxEditor {\n\t\t\t\t\twidth: 100%;\n\t\t\t\t\theight: 100vh;\n\t\t\t\t\tgrid-template-columns: minmax(0, 1fr) 390px; /* minmax(0, 1fr) min-content; Chrome 80 grid layout regression. https://bugs.chromium.org/p/chromium/issues/detail?id=1050307 */\n\t\t\t\t\tgrid-template-rows: minmax(481px, 1fr) minmax(0, min-content);\n\t\t\t\t\tgrid-template-areas: "pattern-area settings-area" "track-area settings-area";\n\t\t\t\t}\n\t\t\t\t.beepboxEditor .pattern-area {\n\t\t\t\t\twidth: 100%;\n\t\t\t\t\theight: 100%;\n\t\t\t\t}\n\t\t\t\t.beepboxEditor .track-area {\n\t\t\t\t\tdisplay: flex;\n\t\t\t\t}\n\t\t\t\t.beepboxEditor .trackAndMuteContainer {\n\t\t\t\t\twidth: 100%;\n\t\t\t\t\tmin-height: 0;\n\t\t\t\t\tflex: 1;\n\t\t\t\t\toverflow: auto;\n\t\t\t\t\tmax-height: 97.5vh;\n\t\t\t\t}\n\t\t\t\t.beepboxEditor .instrument-settings-area {\n\t\t\t\t\toverflow-y: auto;\n\t\t\t\t\tposition: relative;\n\t\t\t\t}\n\t\t\t\t.beepboxEditor .instrument-settings-area > .editor-controls {\n\t\t\t\t\tposition: absolute;\n\t\t\t\t\twidth: 100%;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t.beepboxEditor .song-settings-area {\n\t\t\t\t\toverflow-y: auto;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t.beepboxEditor .settings-area {\n\t\t\t\t\twidth: 30em;\n\t\t\t\t\tgrid-template-columns: minmax(0, 1fr) minmax(0, 1fr);\n\t\t\t\t\tgrid-template-rows: auto auto auto minmax(0, 1fr);\n\t\t\t\t\tgrid-template-areas:\n\t\t\t\t\t\t"instrument-settings-area version-area"\n\t\t\t\t\t\t"instrument-settings-area play-pause-area"\n\t\t\t\t\t\t"instrument-settings-area menu-area"\n\t\t\t\t\t\t"instrument-settings-area song-settings-area";\n\t\t\t\t}\t\t\t\t\n\t\t\t\t.beepboxEditor .barScrollBar {\n\t\t\t\t\tdisplay: none;\n\t\t\t\t}\n\t\t\t\t.beepboxEditor.selectRow {\n\t\t\t\t\theight: 2em;\n\t\t\t\t}\n\t\t\t\t.beepboxEditor .trackAndMuteContainer {\n\t\t\t\t\tmax-height: 446px;\n\t\t\t\t}\n\n\t\t\t\t.beepboxEditor .trackContainer {\n\t\t\t\t\toverflow: visible;\n\t\t\t\t}\n\t\t\t\t.beepboxEditor .trackAndMuteContainer {\n\t\t\t\t\tscrollbar-width: auto;\n\t\t\t\t}\n\t\t\t\t.beepboxEditor .trackAndMuteContainer::-webkit-scrollbar {\n\t\t\t\t\twidth: 20px;\n\t\t\t\t\theight: 20px;\n\t\t\t\t}\n\t\t\t\t.beepboxEditor .trackAndMuteContainer::-webkit-scrollbar-track {\n\t\t\t\t\tbackground: ${nt.editorBackground};\n\t\t\t\t}\n\t\t\t\t.beepboxEditor .trackAndMuteContainer::-webkit-scrollbar-thumb {\n\t\t\t\t\tbackground-color: ${nt.uiWidgetBackground};\n\t\t\t\t\tborder: 3px solid ${nt.editorBackground};\n\t\t\t\t}\n\t\t\t\t.beepboxEditor .trackAndMuteContainer::-webkit-scrollbar-corner {\n\t\t\t\t\tbackground-color: ${nt.editorBackground};\n\t\t\t\t}\n\t\t\t}\n\t\t`,
        "focused long": `\n\t\t\t/* focused long layout */\n\t\t\t@media (min-width: 711px) {\n\t\t\t\t#beepboxEditorContainer {\n\t\t\t\t\tmax-width: initial;\n\t\t\t\t\theight: 100vh;\n\t\t\t\t\tpadding-top: 0px;\n\t\t\t\t}\n\t\t\t\t.beepboxEditor {\n\t\t\t\t\twidth: 100%;\n\t\t\t\t\theight: 100vh;\n\t\t\t\t\tgrid-template-columns: minmax(0, 1fr) 190px; \n\t\t\t\t\tgrid-template-rows: minmax(481px, 1fr) minmax(0, min-content);\n\t\t\t\t\tgrid-template-areas: "pattern-area settings-area" "track-area settings-area";\n\t\t\t\t}\n\t\t\t\t.beepboxEditor .pattern-area {\n\t\t\t\t\twidth: 100%;\n\t\t\t\t\theight: 100%;\n\t\t\t\t}\n\t\t\t\t.beepboxEditor .track-area {\n\t\t\t\t\tdisplay: flex;\n\t\t\t\t}\n\t\t\t\t.beepboxEditor .trackAndMuteContainer {\n\t\t\t\t\twidth: 100%;\n\t\t\t\t\tmin-height: 0;\n\t\t\t\t\tflex: 1;\n\t\t\t\t\toverflow: auto;\n\t\t\t\t\tmax-height: 97.5vh;\n\t\t\t\t}\n\t\t\t\t.beepboxEditor .instrument-settings-area {\n\t\t\t\t\toverflow-y: auto;\n\t\t\t\t\tposition: relative;\n\t\t\t\t}\n\t\t\t\t.beepboxEditor .instrument-settings-area > .editor-controls {\n\t\t\t\t\tposition: absolute;\n\t\t\t\t\twidth: 100%;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t.beepboxEditor .instrument-settings-area > .editor-controls {\n\t\t\t\t\tposition: absolute;\n\t\t\t\t\twidth: 100%;\n\t\t\t\t}\n\n\t\t\t\t.beepboxEditor .settings-area {\n\t\t\t\t\twidth: 100%;\n\t\t\t\t\tposition: relative;\n\t\t\t\t\toverflow-y: auto;\n\t\t\t\t\tgrid-template-columns: minmax(0, 1fr);\n\t\t\t\t\tgrid-template-rows: auto auto auto auto minmax(0, 1fr);\n\t\t\t\t\tgrid-template-areas:\n\t\t\t\t\t\t"version-area"\n\t\t\t\t\t\t"play-pause-area"\n\t\t\t\t\t\t"menu-area"\n\t\t\t\t\t\t"song-settings-area"\n\t\t\t\t\t\t"instrument-settings-area";\n\t\t\t\t}\n\t\t\t\t.beepboxEditor .barScrollBar {\n\t\t\t\t\tdisplay: none;\n\t\t\t\t}\n\t\t\t\t.beepboxEditor.selectRow {\n\t\t\t\t\theight: 2em;\n\t\t\t\t}\n\t\t\t\t.beepboxEditor .trackAndMuteContainer {\n\t\t\t\t\tmax-height: 446px;\n\t\t\t\t}\n\n\t\t\t\t.beepboxEditor .trackContainer {\n\t\t\t\t\toverflow: visible;\n\t\t\t\t}\n\t\t\t\t.beepboxEditor .trackAndMuteContainer {\n\t\t\t\t\tscrollbar-width: auto;\n\t\t\t\t}\n\t\t\t\t.beepboxEditor .trackAndMuteContainer::-webkit-scrollbar {\n\t\t\t\t\twidth: 20px;\n\t\t\t\t\theight: 20px;\n\t\t\t\t}\n\t\t\t\t.beepboxEditor .trackAndMuteContainer::-webkit-scrollbar-track {\n\t\t\t\t\tbackground: ${nt.editorBackground};\n\t\t\t\t}\n\t\t\t\t.beepboxEditor .trackAndMuteContainer::-webkit-scrollbar-thumb {\n\t\t\t\t\tbackground-color: ${nt.uiWidgetBackground};\n\t\t\t\t\tborder: 3px solid ${nt.editorBackground};\n\t\t\t\t}\n\t\t\t\t.beepboxEditor .trackAndMuteContainer::-webkit-scrollbar-corner {\n\t\t\t\t\tbackground-color: ${nt.editorBackground};\n\t\t\t\t}\n\t\t\t}\n\t\t`
    },
    so.l = document.head.appendChild(J.style({
        type: "text/css"
    }));
    class oo {
        constructor(t, e=!1) {
            this.m = t,
            this.yo = e,
            this.u = 120,
            this.v = 26,
            this.bo = Y.svg({
                "pointer-events": "none"
            }),
            this.wo = Y.svg({
                "pointer-events": "none"
            }),
            this.vo = Y.path({
                fill: "none",
                stroke: "currentColor",
                "stroke-width": 2,
                "pointer-events": "none"
            }),
            this.xo = [],
            this.ko = Y.svg({
                "pointer-events": "none"
            }),
            this.q = Y.svg({
                style: "background-color: ${ColorConfig.editorBackground}; touch-action: none; cursor: crosshair;",
                width: "100%",
                height: "100%",
                viewBox: "0 0 " + this.u + " " + this.v,
                preserveAspectRatio: "none"
            }, this.bo, this.wo, this.vo, this.ko),
            this.container = J.div({
                class: "harmonics",
                style: "height: 100%;"
            }, this.q),
            this.N = 0,
            this.Ze = 0,
            this.Mo = 0,
            this.So = 0,
            this.O = !1,
            this.Fo = null,
            this.Co = "",
            this.Ao = !0,
            this.instrument = this.m.song.channels[this.m.channel].instruments[this.m.getCurrentInstrument()],
            this.Eo = this.instrument.harmonicsWave,
            this.ei = 0,
            this.ii = [],
            this.storeChange = () => {
                var t = !0;
                if (this.ii.length > 0)
                    for (var e = 0; e < p.harmonicsControlPoints; e++)
                        this.ii[this.ei][e] != this.instrument.harmonicsWave.harmonics[e] && (t = !1,
                        e = p.harmonicsControlPoints);
                0 != t && 0 != this.ii.length || (this.ii.splice(0, this.ei),
                this.ei = 0,
                this.ii.unshift(this.instrument.harmonicsWave.harmonics.slice()),
                this.ii.length > 32 && this.ii.pop())
            }
            ,
            this.undo = () => {
                if (this.ei < this.ii.length - 1) {
                    this.ei++;
                    const t = this.ii[this.ei].slice();
                    this.setHarmonicsWave(t)
                }
            }
            ,
            this.redo = () => {
                if (this.ei > 0) {
                    this.ei--;
                    const t = this.ii[this.ei].slice();
                    this.setHarmonicsWave(t)
                }
            }
            ,
            this.K = t => {
                t.preventDefault(),
                this.O = !0;
                const e = this.q.getBoundingClientRect();
                this.N = ((t.clientX || t.pageX) - e.left) * this.u / (e.right - e.left),
                this.Ze = ((t.clientY || t.pageY) - e.top) * this.v / (e.bottom - e.top),
                isNaN(this.N) && (this.N = 0),
                isNaN(this.Ze) && (this.Ze = 0),
                this.Mo = this.Vi(this.N),
                this.So = this.To(this.Ze),
                this.X()
            }
            ,
            this.Y = t => {
                t.preventDefault(),
                this.O = !0;
                const e = this.q.getBoundingClientRect();
                this.N = (t.touches[0].clientX - e.left) * this.u / (e.right - e.left),
                this.Ze = (t.touches[0].clientY - e.top) * this.v / (e.bottom - e.top),
                isNaN(this.N) && (this.N = 0),
                isNaN(this.Ze) && (this.Ze = 0),
                this.Mo = this.Vi(this.N),
                this.So = this.To(this.Ze),
                this.X()
            }
            ,
            this.Z = t => {
                if (null == this.container.offsetParent)
                    return;
                const e = this.q.getBoundingClientRect();
                this.N = ((t.clientX || t.pageX) - e.left) * this.u / (e.right - e.left),
                this.Ze = ((t.clientY || t.pageY) - e.top) * this.v / (e.bottom - e.top),
                isNaN(this.N) && (this.N = 0),
                isNaN(this.Ze) && (this.Ze = 0),
                this.X()
            }
            ,
            this.tt = t => {
                if (null == this.container.offsetParent)
                    return;
                if (!this.O)
                    return;
                t.preventDefault();
                const e = this.q.getBoundingClientRect();
                this.N = (t.touches[0].clientX - e.left) * this.u / (e.right - e.left),
                this.Ze = (t.touches[0].clientY - e.top) * this.v / (e.bottom - e.top),
                isNaN(this.N) && (this.N = 0),
                isNaN(this.Ze) && (this.Ze = 0),
                this.X(),
                this.render()
            }
            ,
            this.et = t => {
                this.O && (this.yo || this.m.record(this.Fo),
                this.storeChange(),
                this.Fo = null),
                this.O = !1
            }
            ;
            for (let t = 1; t <= p.harmonicsControlPoints; t *= 2)
                this.bo.appendChild(Y.rect({
                    fill: nt.tonic,
                    x: (t - .5) * (this.u - 8) / (p.harmonicsControlPoints - 1) - 1,
                    y: 0,
                    width: 2,
                    height: this.v
                }));
            for (let t = 3; t <= p.harmonicsControlPoints; t *= 2)
                this.wo.appendChild(Y.rect({
                    fill: nt.fifthNote,
                    x: (t - .5) * (this.u - 8) / (p.harmonicsControlPoints - 1) - 1,
                    y: 0,
                    width: 2,
                    height: this.v
                }));
            for (let t = 0; t < 4; t++) {
                const e = Y.rect({
                    fill: "currentColor",
                    x: this.u - 2 * t - 1,
                    y: 0,
                    width: 1,
                    height: this.v
                });
                this.xo.push(e),
                this.ko.appendChild(e)
            }
            this.storeChange(),
            this.container.addEventListener("mousedown", this.K),
            document.addEventListener("mousemove", this.Z),
            document.addEventListener("mouseup", this.et),
            this.container.addEventListener("touchstart", this.Y),
            this.container.addEventListener("touchmove", this.tt),
            this.container.addEventListener("touchend", this.et),
            this.container.addEventListener("touchcancel", this.et)
        }
        Vi(t) {
            return (p.harmonicsControlPoints - 1) * t / (this.u - 8) - .5
        }
        To(t) {
            return p.harmonicsMax * (1 - t / this.v)
        }
        X() {
            if (this.O) {
                const t = this.Vi(this.N)
                  , e = this.To(this.Ze)
                  , i = this.m.song.channels[this.m.channel].instruments[this.m.getCurrentInstrument()]
                  , n = i.harmonicsWave;
                if (t != this.Mo) {
                    const i = (e - this.So) / (t - this.Mo)
                      , s = this.So - this.Mo * i
                      , o = Math.ceil(Math.min(this.Mo, t))
                      , a = Math.floor(Math.max(this.Mo, t));
                    for (let t = o; t <= a; t++)
                        t < 0 || t >= p.harmonicsControlPoints || (n.harmonics[t] = Math.max(0, Math.min(p.harmonicsMax, Math.round(t * i + s))))
                }
                n.harmonics[Math.max(0, Math.min(p.harmonicsControlPoints - 1, Math.round(t)))] = Math.max(0, Math.min(p.harmonicsMax, Math.round(e))),
                this.Mo = t,
                this.So = e,
                this.Fo = new Ye(this.m,i,n),
                this.m.setProspectiveChange(this.Fo)
            }
        }
        getHarmonicsWave() {
            return this.m.song.channels[this.m.channel].instruments[this.m.getCurrentInstrument()].harmonicsWave
        }
        setHarmonicsWave(t) {
            const e = this.m.song.channels[this.m.channel].instruments[this.m.getCurrentInstrument()];
            for (let i = 0; i < p.harmonicsControlPoints; i++)
                e.harmonicsWave.harmonics[i] = t[i];
            this.m.record(new Ye(this.m,e,e.harmonicsWave)),
            this.render()
        }
        saveSettings() {
            const t = this.m.song.channels[this.m.channel].instruments[this.m.getCurrentInstrument()];
            return new Ye(this.m,t,t.harmonicsWave)
        }
        resetToInitial() {
            const t = this.m.song.channels[this.m.channel].instruments[this.m.getCurrentInstrument()];
            this.setHarmonicsWave(this.Eo.harmonics),
            this.m.record(new Ye(this.m,t,this.Eo))
        }
        render() {
            const t = this.m.song.channels[this.m.channel].instruments[this.m.getCurrentInstrument()].harmonicsWave
              , e = t => (1 - t / p.harmonicsMax) * this.v;
            let i = q(this.v)
              , n = "";
            for (let s = 0; s < p.harmonicsControlPoints - 1; s++) {
                if (0 == t.harmonics[s])
                    continue;
                let o = q((s + .5) * (this.u - 8) / (p.harmonicsControlPoints - 1));
                n += "M " + o + " " + i + " ",
                n += "L " + o + " " + q(e(t.harmonics[s])) + " "
            }
            const s = e(t.harmonics[p.harmonicsControlPoints - 1]);
            for (let t = 0; t < 4; t++) {
                const e = this.xo[t];
                e.setAttribute("y", q(s)),
                e.setAttribute("height", q(this.v - s))
            }
            this.Co != n && (this.Co = n,
            this.vo.setAttribute("d", n)),
            this.Ao != this.m.prefs.showFifth && (this.Ao = this.m.prefs.showFifth,
            this.wo.style.display = this.m.prefs.showFifth ? "" : "none")
        }
    }
    class ao {
        constructor(t, e) {
            this.m = t,
            this.hi = e,
            this.harmonicsEditor = new oo(this.m,!0),
            this.ci = J.button({
                style: "width: 55%;",
                type: "button"
            }),
            this.Oe = J.button({
                class: "cancelButton"
            }),
            this.Re = J.button({
                class: "okayButton",
                style: "width:45%;"
            }, "Okay"),
            this.copyButton = J.button({
                style: "width:86px; margin-right: 5px;",
                class: "copyButton"
            }, ["Copy", Y.svg({
                style: "flex-shrink: 0; position: absolute; left: 0; top: 50%; margin-top: -1em; pointer-events: none;",
                width: "2em",
                height: "2em",
                viewBox: "-5 -21 26 26"
            }, [Y.path({
                d: "M 0 -15 L 1 -15 L 1 0 L 13 0 L 13 1 L 0 1 L 0 -15 z M 2 -1 L 2 -17 L 10 -17 L 14 -13 L 14 -1 z M 3 -2 L 13 -2 L 13 -12 L 9 -12 L 9 -16 L 3 -16 z",
                fill: "currentColor"
            })])]),
            this.pasteButton = J.button({
                style: "width:86px;",
                class: "pasteButton"
            }, ["Paste", Y.svg({
                style: "flex-shrink: 0; position: absolute; left: 0; top: 50%; margin-top: -1em; pointer-events: none;",
                width: "2em",
                height: "2em",
                viewBox: "0 0 26 26"
            }, [Y.path({
                d: "M 8 18 L 6 18 L 6 5 L 17 5 L 17 7 M 9 8 L 16 8 L 20 12 L 20 22 L 9 22 z",
                stroke: "currentColor",
                fill: "none"
            }), Y.path({
                d: "M 9 3 L 14 3 L 14 6 L 9 6 L 9 3 z M 16 8 L 20 12 L 16 12 L 16 8 z",
                fill: "currentColor"
            })])]),
            this.copyPasteContainer = J.div({
                style: "width: 185px;"
            }, this.copyButton, this.pasteButton),
            this.container = J.div({
                class: "prompt noSelection",
                style: "width: 500px;"
            }, J.h2("Edit Harmonics Instrument"), J.div({
                style: "display: flex; width: 55%; align-self: center; flex-direction: row; align-items: center; justify-content: center;"
            }, this.ci), J.div({
                style: "display: flex; flex-direction: row; align-items: center; justify-content: center;"
            }, this.harmonicsEditor.container), J.div({
                style: "display: flex; flex-direction: row-reverse; justify-content: space-between;"
            }, this.Re, this.copyPasteContainer), this.Oe),
            this.di = () => {
                this.hi.togglePlay(),
                this.updatePlayButton()
            }
            ,
            this.$e = () => {
                this.m.prompt = null,
                this.m.undo()
            }
            ,
            this.cleanUp = () => {
                this.Re.removeEventListener("click", this.He),
                this.Oe.removeEventListener("click", this.$e),
                this.container.removeEventListener("keydown", this.whenKeyPressed),
                this.harmonicsEditor.container.removeEventListener("mousemove", ( () => this.harmonicsEditor.render())),
                this.ci.removeEventListener("click", this.di)
            }
            ,
            this.pi = () => {
                const t = this.harmonicsEditor.getHarmonicsWave();
                window.localStorage.setItem("harmonicsCopy", JSON.stringify(t.harmonics))
            }
            ,
            this.mi = () => {
                const t = JSON.parse(String(window.localStorage.getItem("harmonicsCopy")));
                this.harmonicsEditor.setHarmonicsWave(t),
                this.harmonicsEditor.storeChange()
            }
            ,
            this.whenKeyPressed = t => {
                "BUTTON" != t.target.tagName && 13 == t.keyCode ? this.He() : 32 == t.keyCode ? (this.di(),
                t.preventDefault()) : 90 == t.keyCode ? (this.harmonicsEditor.undo(),
                t.stopPropagation()) : 89 == t.keyCode ? (this.harmonicsEditor.redo(),
                t.stopPropagation()) : 219 == t.keyCode ? this.m.synth.goToPrevBar() : 221 == t.keyCode && this.m.synth.goToNextBar()
            }
            ,
            this.He = () => {
                this.m.prompt = null,
                this.m.record(this.harmonicsEditor.saveSettings(), !0),
                this.m.prompt = null
            }
            ,
            this.Re.addEventListener("click", this.He),
            this.Oe.addEventListener("click", this.$e),
            this.container.addEventListener("keydown", this.whenKeyPressed),
            this.copyButton.addEventListener("click", this.pi),
            this.pasteButton.addEventListener("click", this.mi),
            this.ci.addEventListener("click", this.di),
            this.harmonicsEditor.container.addEventListener("mousemove", ( () => this.harmonicsEditor.render())),
            this.harmonicsEditor.container.addEventListener("mousedown", ( () => this.harmonicsEditor.render())),
            this.container.addEventListener("mousemove", ( () => this.harmonicsEditor.render())),
            this.container.addEventListener("mousedown", ( () => this.harmonicsEditor.render())),
            this.updatePlayButton(),
            setTimeout(( () => this.ci.focus())),
            this.harmonicsEditor.render()
        }
        updatePlayButton() {
            this.m.synth.playing ? (this.ci.classList.remove("playButton"),
            this.ci.classList.add("pauseButton"),
            this.ci.title = "Pause (Space)",
            this.ci.innerText = "Pause") : (this.ci.classList.remove("pauseButton"),
            this.ci.classList.add("playButton"),
            this.ci.title = "Play (Space)",
            this.ci.innerText = "Play")
        }
    }
    const {span: ro} = J;
    class ho {
        constructor(t, e, i) {
            this.input = t,
            this.m = e,
            this.Po = i,
            this.Fo = null,
            this.Bo = "",
            this.Io = "",
            this.Lo = () => {
                this.m.lastChangeWas(this.Fo) || (this.Io = this.Bo),
                this.Fo = this.Po(this.Io, this.input.value),
                this.m.setProspectiveChange(this.Fo)
            }
            ,
            this.Do = () => {
                this.m.record(this.Fo),
                this.Fo = null
            }
            ,
            t.addEventListener("input", this.Lo),
            t.addEventListener("change", this.Do)
        }
        updateValue(t) {
            this.Bo = t,
            this.input.value = String(t)
        }
    }
    class lo {
        constructor(t, e, i, n) {
            this.input = t,
            this.m = e,
            this.Po = i,
            this.Fo = null,
            this.Bo = 0,
            this.Io = 0,
            this.Lo = () => {
                this.m.lastChangeWas(this.Fo) || (this.Io = this.Bo),
                null != this.Po && (this.Fo = this.Po(this.Io, parseInt(this.input.value)),
                this.m.setProspectiveChange(this.Fo))
            }
            ,
            this.Do = () => {
                null != this.Po && (this.m.record(this.Fo),
                this.Fo = null)
            }
            ,
            this.container = ro(n ? {
                class: "midTick",
                style: "position: sticky; width: 61.5%;"
            } : {
                style: "position: sticky;"
            }, t),
            t.addEventListener("input", this.Lo),
            t.addEventListener("change", this.Do)
        }
        updateValue(t) {
            this.Bo = t,
            this.input.value = String(t)
        }
        getValueBeforeProspectiveChange() {
            return this.Io
        }
    }
    class co {
        constructor(t) {
            this.ct = 0,
            this.Ks = t
        }
        getReadIndex() {
            return this.ct
        }
        readUint32() {
            if (this.ct + 4 > this.Ks.byteLength)
                throw new Error("Reading past the end of the buffer.");
            const t = this.Ks.getUint32(this.ct, !1);
            return this.ct += 4,
            t
        }
        readUint24() {
            return this.readUint8() << 16 | this.readUint8() << 8 | this.readUint8()
        }
        readUint16() {
            if (this.ct + 2 > this.Ks.byteLength)
                throw new Error("Reading past the end of the buffer.");
            const t = this.Ks.getUint16(this.ct, !1);
            return this.ct += 2,
            t
        }
        readUint8() {
            if (this.ct + 1 > this.Ks.byteLength)
                throw new Error("Reading past the end of the buffer.");
            const t = this.Ks.getUint8(this.ct);
            return this.ct++,
            t
        }
        readInt8() {
            if (this.ct + 1 > this.Ks.byteLength)
                throw new Error("Reading past the end of the buffer.");
            const t = this.Ks.getInt8(this.ct);
            return this.ct++,
            t
        }
        peakUint8() {
            if (this.ct + 1 > this.Ks.byteLength)
                throw new Error("Reading past the end of the buffer.");
            return this.Ks.getUint8(this.ct)
        }
        readMidi7Bits() {
            const t = this.readUint8();
            return t >= 128 && console.log("7 bit value contained 8th bit! value " + t + ", index " + this.ct),
            127 & t
        }
        readMidiVariableLength() {
            let t = 0;
            for (let e = 0; e < 4; e++) {
                const e = this.readUint8();
                if (t += 127 & e,
                !(128 & e))
                    break;
                t <<= 7
            }
            return t
        }
        skipBytes(t) {
            this.ct += t
        }
        hasMore() {
            return this.Ks.byteLength > this.ct
        }
        getReaderForNextBytes(t) {
            if (this.ct + t > this.Ks.byteLength)
                throw new Error("Reading past the end of the buffer.");
            const e = new co(new DataView(this.Ks.buffer,this.Ks.byteOffset + this.ct,t));
            return this.skipBytes(t),
            e
        }
    }
    const {button: po, p: mo, div: uo, h2: fo, input: yo, select: bo, option: go} = J;
    class wo {
        constructor(t) {
            this.m = t,
            this.bn = yo({
                type: "file",
                accept: ".json,application/json,.mid,.midi,audio/midi,audio/x-midi"
            }),
            this.Oe = po({
                class: "cancelButton"
            }),
            this.zo = bo({
                style: "width: 100%;"
            }, go({
                value: "auto"
            }, "Auto-detect mode (for json)"), go({
                value: "BeepBox"
            }, "BeepBox"), go({
                value: "ModBox"
            }, "ModBox"), go({
                value: "JummBox"
            }, "JummBox"), go({
                value: "SynthBox"
            }, "SynthBox"), go({
                value: "GoldBox"
            }, "GoldBox"), go({
                value: "PaandorasBox"
            }, "PaandorasBox"), go({
                value: "UltraBox"
            }, "UltraBox")),
            this.container = uo({
                class: "prompt noSelection",
                style: "width: 300px;"
            }, fo("Import"), mo({
                style: "text-align: left; margin: 0.5em 0;"
            }, "BeepBox songs can be exported and re-imported as .json files. You could also use other means to make .json files for BeepBox as long as they follow the same structure."), mo({
                style: "text-align: left; margin: 0.5em 0;"
            }, "BeepBox can also (crudely) import .mid files. There are many tools available for creating .mid files. Shorter and simpler songs are more likely to work well."), this.zo, this.bn, this.Oe),
            this.$e = () => {
                this.m.undo()
            }
            ,
            this.cleanUp = () => {
                this.bn.removeEventListener("change", this.wn),
                this.Oe.removeEventListener("click", this.$e)
            }
            ,
            this.wn = () => {
                const t = this.bn.files[0];
                if (!t)
                    return;
                const e = t.name.slice(2 + (t.name.lastIndexOf(".") - 1 >>> 0)).toLowerCase();
                if ("json" == e) {
                    const e = new FileReader;
                    e.addEventListener("load", (t => {
                        this.m.prompt = null,
                        this.m.goBackToStart(),
                        this.m.record(new rn(this.m,e.result,this.zo.value), !0, !0)
                    }
                    )),
                    e.readAsText(t)
                } else if ("midi" == e || "mid" == e) {
                    const e = new FileReader;
                    e.addEventListener("load", (t => {
                        this.m.prompt = null,
                        this.m.goBackToStart(),
                        this.qo(e.result)
                    }
                    )),
                    e.readAsArrayBuffer(t)
                } else
                    console.error("Unrecognized file extension."),
                    this.$e()
            }
            ,
            this.bn.select(),
            setTimeout(( () => this.bn.focus())),
            this.bn.addEventListener("change", this.wn),
            this.Oe.addEventListener("click", this.$e)
        }
        qo(t) {
            const e = new co(new DataView(t));
            let i = null;
            const n = [];
            for (; e.hasMore(); ) {
                const R = e.readUint32()
                  , $ = e.readUint32();
                if (1297377380 == R)
                    null == i ? i = e.getReaderForNextBytes($) : console.error("This MIDI file has more than one header chunk.");
                else if (1297379947 == R) {
                    const H = e.getReaderForNextBytes($);
                    H.hasMore() && n.push({
                        reader: H,
                        nextEventMidiTick: H.readMidiVariableLength(),
                        ended: !1,
                        runningStatus: -1
                    })
                } else
                    e.skipBytes($)
            }
            if (null == i)
                return console.error("No header chunk found in this MIDI file."),
                void this.$e();
            const s = i.readUint16();
            i.readUint16();
            const o = i.readUint16();
            let a = 0;
            const r = []
              , h = 2 == s;
            if (h)
                r.push(a);
            else
                for (let _ = 0; _ < n.length; _++)
                    r.push(_);
            const l = [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]
              , c = [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]
              , d = [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]
              , m = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
              , u = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
              , f = [100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100]
              , y = [64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64]
              , b = [[], [], [], [], [], [], [], [], [], [], [], [], [], [], [], []]
              , g = [[], [], [], [], [], [], [], [], [], [], [], [], [], [], [], []]
              , w = [[], [], [], [], [], [], [], [], [], [], [], [], [], [], [], []];
            let v = []
              , x = 5e5
              , k = 8
              , M = 0
              , S = !1
              , F = 0;
            for (; ; ) {
                let V = Number.MAX_VALUE
                  , G = !1;
                for (const W of r) {
                    const j = n[W];
                    for (; !j.ended && j.nextEventMidiTick == F; ) {
                        const U = 128 & j.reader.peakUint8() ? j.reader.readUint8() : j.runningStatus
                          , K = 240 & U
                          , J = 15 & U;
                        240 != K && (j.runningStatus = U);
                        let Y = !1;
                        switch (K) {
                        case 128:
                            {
                                const Q = j.reader.readMidi7Bits();
                                j.reader.readMidi7Bits(),
                                b[J].push({
                                    midiTick: F,
                                    pitch: Q,
                                    velocity: 0,
                                    program: -1,
                                    instrumentVolume: -1,
                                    instrumentPan: -1,
                                    on: !1
                                })
                            }
                            break;
                        case 144:
                            {
                                const Z = j.reader.readMidi7Bits()
                                  , X = j.reader.readMidi7Bits();
                                if (0 == X)
                                    b[J].push({
                                        midiTick: F,
                                        pitch: Z,
                                        velocity: 0,
                                        program: -1,
                                        instrumentVolume: -1,
                                        instrumentPan: -1,
                                        on: !1
                                    });
                                else {
                                    const tt = Math.max(0, Math.min(p.volumeRange - 1, Math.round(Jt.volumeMultToInstrumentVolume(Ks(f[J])))))
                                      , et = Math.max(0, Math.min(p.panMax, Math.round(((y[J] - 64) / 63 + 1) * p.panCenter)));
                                    b[J].push({
                                        midiTick: F,
                                        pitch: Z,
                                        velocity: Math.max(0, Math.min(1, (X + 14) / 90)),
                                        program: u[J],
                                        instrumentVolume: tt,
                                        instrumentPan: et,
                                        on: !0
                                    })
                                }
                            }
                            break;
                        case 160:
                            j.reader.readMidi7Bits(),
                            j.reader.readMidi7Bits();
                            break;
                        case 176:
                            {
                                const it = j.reader.readMidi7Bits()
                                  , nt = j.reader.readMidi7Bits();
                                switch (it) {
                                case 6:
                                    0 == l[J] && 0 == c[J] && (d[J] = nt);
                                    break;
                                case 7:
                                    f[J] = nt;
                                    break;
                                case 10:
                                    y[J] = nt;
                                    break;
                                case 11:
                                    w[J].push({
                                        midiTick: F,
                                        size: Jt.volumeMultToNoteSize((C = nt,
                                        Math.pow(C / 127, 4)))
                                    });
                                    break;
                                case 38:
                                    0 == l[J] && 0 == c[J] && (m[J] = nt);
                                    break;
                                case 100:
                                    c[J] = nt;
                                    break;
                                case 101:
                                    l[J] = nt
                                }
                            }
                            break;
                        case 192:
                            {
                                const st = j.reader.readMidi7Bits();
                                u[J] = st
                            }
                            break;
                        case 208:
                            j.reader.readMidi7Bits();
                            break;
                        case 224:
                            {
                                const ot = j.reader.readMidi7Bits()
                                  , at = ((j.reader.readMidi7Bits() << 7 | ot) / 8192 - 1) * (d[J] + .01 * m[J]);
                                g[J].push({
                                    midiTick: F,
                                    interval: at
                                })
                            }
                            break;
                        case 240:
                            if (255 == U) {
                                const rt = j.reader.readMidi7Bits()
                                  , ht = j.reader.readMidiVariableLength();
                                if (47 == rt)
                                    Y = !0,
                                    j.reader.skipBytes(ht);
                                else if (81 == rt)
                                    x = j.reader.readUint24(),
                                    v.push({
                                        midiTick: F,
                                        microsecondsPerBeat: x
                                    }),
                                    j.reader.skipBytes(ht - 3);
                                else if (88 == rt) {
                                    const lt = j.reader.readUint8();
                                    let ct = j.reader.readUint8();
                                    for (j.reader.readUint8(),
                                    j.reader.readUint8(),
                                    j.reader.skipBytes(ht - 4),
                                    k = 4 * lt; 0 == (1 & k) && (ct > 0 || k > p.beatsPerBarMax) && k >= 2 * p.beatsPerBarMin; )
                                        k >>= 1,
                                        ct -= 1;
                                    k = Math.max(p.beatsPerBarMin, Math.min(p.beatsPerBarMax, k))
                                } else
                                    89 == rt ? (M = j.reader.readInt8(),
                                    S = 1 == j.reader.readUint8(),
                                    j.reader.skipBytes(ht - 2)) : j.reader.skipBytes(ht)
                            } else {
                                if (240 != U && 247 != U)
                                    return console.error("Unrecognized event status: " + U),
                                    void this.$e();
                                {
                                    const dt = j.reader.readMidiVariableLength();
                                    j.reader.skipBytes(dt)
                                }
                            }
                            break;
                        default:
                            return console.error("Unrecognized event type: " + K),
                            void this.$e()
                        }
                        !Y && j.reader.hasMore() ? j.nextEventMidiTick = F + j.reader.readMidiVariableLength() : (j.ended = !0,
                        h && (a++,
                        a < n.length && (r[0] = a,
                        n[a].nextEventMidiTick += F,
                        V = Math.min(V, n[a].nextEventMidiTick),
                        G = !0)))
                    }
                    j.ended || (G = !0,
                    V = Math.min(V, j.nextEventMidiTick))
                }
                if (!G)
                    break;
                F = V
            }
            var C;
            for (const pt of v) {
                x = pt.microsecondsPerBeat;
                break
            }
            const A = 6e7
              , E = Math.max(p.tempoMin, Math.min(p.tempoMax, Math.round(A / x)))
              , T = o / p.partsPerBeat
              , P = p.partsPerBeat * k
              , B = Math.ceil(F / T / P);
            function I(t) {
                return Math.round(t / T)
            }
            let L = M;
            for (S && (L += 3),
            1 == (1 & L) && (L += 6); L < 0; )
                L += 12;
            L %= 12;
            const D = []
              , z = []
              , q = [];
            for (let mt = 0; mt < 16; mt++) {
                if (0 == b[mt].length)
                    continue;
                const ut = new _t
                  , ft = N.midiProgramToPresetValue(b[mt][0].program)
                  , yt = null == ft ? null : N.valueToPreset(ft)
                  , bt = 9 == mt
                  , gt = bt || null != yt && 1 == yt.isNoise
                  , wt = null != yt && 1 == yt.isMod
                  , vt = gt ? p.spectrumBasePitch : p.keys[L].basePitch
                  , xt = gt ? p.noiseInterval : 1
                  , kt = gt ? .5 : 1
                  , Mt = gt ? p.drumCount - 1 : p.maxPitch;
                gt ? bt ? z.unshift(ut) : z.push(ut) : wt ? q.push(ut) : D.push(ut);
                let St = 1
                  , Ft = 0
                  , Ct = 0
                  , At = p.panCenter;
                if (bt) {
                    const Bt = [];
                    let It = -1
                      , Lt = null
                      , Dt = 0
                      , zt = !1;
                    const qt = N.nameToPresetValue("standard drumset")
                      , Nt = N.valueToPreset(qt)
                      , Ot = new Ht(!1,!1);
                    Ot.fromJsonObject(Nt.settings, !1, !1, !1, !1, 1),
                    Ot.preset = qt,
                    ut.instruments.push(Ot);
                    for (let Rt = 0; Rt <= b[mt].length; Rt++) {
                        const $t = Rt == b[mt].length ? null : b[mt][Rt]
                          , Vt = null == $t ? Number.MAX_SAFE_INTEGER : I($t.midiTick);
                        if (Bt.length > 0 && Vt > Dt && (null == $t || $t.on)) {
                            const Gt = Math.floor(Dt / P)
                              , Wt = Gt * P;
                            if (It != Gt || null == Lt) {
                                for (It++; It < Gt; )
                                    ut.bars[It] = 0,
                                    It++;
                                Lt = new Pt,
                                ut.patterns.push(Lt),
                                ut.bars[It] = ut.patterns.length,
                                Lt.instruments[0] = 0,
                                Lt.instruments.length = 1
                            }
                            (!zt || Ot.volume > Ct) && (Ot.volume = Ct,
                            Ot.pan = At,
                            Ot.panDelay = 0,
                            zt = !0);
                            const jt = [];
                            let Ut = Mt
                              , Kt = 0
                              , Yt = 1;
                            for (const ie of Bt) {
                                const ne = Us[ie];
                                -1 == jt.indexOf(ne.frequency) && jt.push(ne.frequency),
                                Yt = Math.max(Yt, Math.round(ne.volume * St)),
                                Ut = Math.min(Ut, ne.duration),
                                Kt = Math.max(Kt, ne.duration)
                            }
                            const Qt = Math.min(Kt, Math.max(Ut, 2))
                              , Xt = Dt - Wt
                              , te = Math.min(P, Math.min(Vt - Wt, Xt + 6 * Qt))
                              , ee = new Tt(-1,Xt,te,Yt,!0);
                            ee.pitches.length = 0;
                            for (let se = 0; se < Math.min(p.maxChordSize, jt.length); se++) {
                                const oe = jt[se + Math.max(0, jt.length - p.maxChordSize)];
                                -1 == ee.pitches.indexOf(oe) && ee.pitches.push(oe)
                            }
                            Lt.notes.push(ee),
                            Bt.length = 0
                        }
                        null != $t && $t.on && null != Us[$t.pitch] && (Bt.push($t.pitch),
                        Dt = Vt,
                        St = $t.velocity,
                        Ct = $t.instrumentVolume,
                        At = $t.instrumentPan)
                    }
                } else {
                    let ae = 0
                      , re = p.noteSizeMax
                      , he = 0
                      , le = 0;
                    function ce(t) {
                        for (; he < g[mt].length && g[mt][he].midiTick <= t; )
                            ae = g[mt][he].interval,
                            he++
                    }
                    function de(t) {
                        for (; le < w[mt].length && w[mt][le].midiTick <= t; )
                            re = w[mt][le].size,
                            le++
                    }
                    const pe = []
                      , me = [];
                    let ue = -1
                      , fe = null
                      , ye = 0
                      , be = 0
                      , ge = 0
                      , we = 0;
                    for (let xe of b[mt]) {
                        const ke = xe.midiTick
                          , Me = I(ke);
                        if (me.length > 0 && Me > be) {
                            const Se = Math.floor(be / P)
                              , Fe = Math.ceil(Me / P);
                            let Ce = !1;
                            for (let Ae = Se; Ae < Fe; Ae++) {
                                const Ee = Ae * P
                                  , Te = Ae * k * o
                                  , Pe = (Ae + 1) * k * o
                                  , Be = Math.max(0, be - Ee)
                                  , Ie = Math.min(P, Me - Ee)
                                  , Le = Math.max(Te, ye)
                                  , De = Math.min(Pe, ke);
                                if (Be < Ie) {
                                    const ze = N.midiProgramToPresetValue(Ft)
                                      , qe = null == ze ? null : N.valueToPreset(ze);
                                    if (ue != Ae || null == fe) {
                                        for (ue++; ue < Ae; )
                                            ut.bars[ue] = 0,
                                            ue++;
                                        if (fe = new Pt,
                                        ut.patterns.push(fe),
                                        ut.bars[ue] = ut.patterns.length,
                                        null == pe[Ft]) {
                                            const Je = new Ht(gt,wt);
                                            pe[Ft] = Je,
                                            null != ze && null != qe && 1 == qe.isNoise == gt ? (Je.fromJsonObject(qe.settings, gt, wt, !1, !1, 1),
                                            Je.preset = ze) : (Je.setTypeAndReset(wt ? 10 : gt ? 2 : 0, gt, wt),
                                            Je.chord = 0),
                                            Je.volume = Ct,
                                            Je.pan = At,
                                            Je.panDelay = 0,
                                            ut.instruments.push(Je)
                                        }
                                        fe.instruments[0] = ut.instruments.indexOf(pe[Ft]),
                                        fe.instruments.length = 1
                                    }
                                    null != pe[Ft] && (pe[Ft].volume = Math.min(pe[Ft].volume, Ct),
                                    pe[Ft].pan = Math.min(pe[Ft].pan, At));
                                    const Ne = new Tt(-1,Be,Ie,p.noteSizeMax,!1);
                                    Ne.pins.length = 0,
                                    Ne.continuesLastPattern = Ce && 0 == Be,
                                    Ce = !0,
                                    ce(Le),
                                    de(Le);
                                    const Oe = me[0] * kt - vt
                                      , Re = Math.round((Oe + ae) / xt)
                                      , $e = Math.round(ae - vt);
                                    let He = Et(0, 0, Math.round(St * re));
                                    Ne.pins.push(He);
                                    const _e = [{
                                        part: 0,
                                        pitch: Re,
                                        size: He.size,
                                        keyPitch: !1,
                                        keySize: !1
                                    }];
                                    let Ve = 0
                                      , Ge = (Oe + ae) / xt
                                      , We = St * re;
                                    for (let Ye = Be + 1; Ye <= Ie; Ye++) {
                                        const Qe = Math.max(Le, Math.min(De - 1, Math.round(T * (Ye + Ee))))
                                          , Ze = Ye - Be
                                          , Xe = Ye == Ie;
                                        ce(Qe),
                                        de(Qe);
                                        const ti = (ae + Oe) / xt
                                          , ei = St * re
                                          , ii = Math.round(ti)
                                          , ni = Math.abs(ti - ii) < .01
                                          , si = Math.abs(Ge - Math.round(Ge)) < .01 ? Math.abs(ti - Ge) >= 1 : Math.floor(ti) != Math.floor(Ge)
                                          , oi = ni || si
                                          , ai = Math.round(ei)
                                          , ri = Math.abs(ei - ai) < .01
                                          , hi = Math.abs(We - Math.round(We)) ? Math.abs(ei - We) >= 1 : Math.floor(ei) != Math.floor(We)
                                          , li = ri || hi;
                                        if (Ge = ti,
                                        We = ei,
                                        oi || li || Xe) {
                                            const ci = {
                                                part: Ze,
                                                pitch: ii,
                                                size: ai,
                                                keyPitch: oi || Xe,
                                                keySize: li || Xe
                                            }
                                              , di = _e[Ve];
                                            let pi = !1
                                              , mi = Number.MAX_VALUE;
                                            if (ci.keyPitch) {
                                                const ui = (ci.pitch - di.pitch) / (ci.part - di.part);
                                                let fi = Math.abs(ui)
                                                  , yi = !1
                                                  , bi = Number.MAX_VALUE;
                                                for (let gi = Ve + 1; gi < _e.length; gi++) {
                                                    const wi = _e[gi];
                                                    if (wi.keyPitch) {
                                                        const vi = di.pitch + ui * (wi.part - di.part)
                                                          , xi = Math.abs(vi - wi.pitch);
                                                        fi < xi && (fi = xi,
                                                        yi = !0,
                                                        bi = gi)
                                                    }
                                                }
                                                yi && (pi = !0,
                                                mi = Math.min(mi, bi))
                                            }
                                            if (ci.keySize) {
                                                const ki = (ci.size - di.size) / (ci.part - di.part);
                                                let Mi = Math.abs(ki)
                                                  , Si = !1
                                                  , Fi = Number.MAX_VALUE;
                                                for (let Ci = Ve + 1; Ci < _e.length; Ci++) {
                                                    const Ai = _e[Ci];
                                                    if (Ai.keySize) {
                                                        const Ei = di.size + ki * (Ai.part - di.part)
                                                          , Ti = Math.abs(Ei - Ai.size);
                                                        Mi < Ti && (Mi = Ti,
                                                        Si = !0,
                                                        Fi = Ci)
                                                    }
                                                }
                                                Si && (pi = !0,
                                                mi = Math.min(mi, Fi))
                                            }
                                            if (pi) {
                                                const Pi = _e[mi];
                                                Ne.pins.push(Et(Pi.pitch - Re, Pi.part, Pi.size)),
                                                Ve = mi
                                            }
                                            _e.push(ci)
                                        }
                                    }
                                    const je = _e[_e.length - 1];
                                    Ne.pins.push(Et(je.pitch - Re, je.part, je.size));
                                    let Ue = Mt
                                      , Ke = 0;
                                    for (const Bi of Ne.pins)
                                        Ue = Math.min(Ue, Mt - Bi.interval),
                                        Ke = Math.min(Ke, -Bi.interval);
                                    Ne.pitches.length = 0;
                                    for (let Ii = 0; Ii < Math.min(p.maxChordSize, me.length); Ii++) {
                                        let Li = me[Ii + Math.max(0, me.length - p.maxChordSize)] * kt;
                                        null != qe && null != qe.midiSubharmonicOctaves && (Li -= 12 * qe.midiSubharmonicOctaves);
                                        const Di = Math.max(Ke, Math.min(Ue, Math.round((Li + $e) / xt)));
                                        if (-1 == Ne.pitches.indexOf(Di)) {
                                            Ne.pitches.push(Di);
                                            const zi = Ne.end - Ne.start;
                                            ge += Di * zi,
                                            we += zi
                                        }
                                    }
                                    fe.notes.push(Ne)
                                }
                            }
                        }
                        -1 != me.indexOf(xe.pitch) && me.splice(me.indexOf(xe.pitch), 1),
                        xe.on && (me.push(xe.pitch),
                        St = xe.velocity,
                        Ft = xe.program,
                        Ct = xe.instrumentVolume,
                        At = xe.instrumentPan),
                        ye = ke,
                        be = Me
                    }
                    const ve = ge / we;
                    ut.octave = gt || wt ? 0 : Math.max(0, Math.min(p.pitchOctaves - 1, Math.floor(ve / 12)))
                }
                for (; ut.bars.length < B; )
                    ut.bars.push(0)
            }
            if (v.length > 1) {
                let qi = new _t;
                q.push(qi);
                let Ni = new Ht(!1,!0);
                Ni.setTypeAndReset(9, !1, !0),
                Ni.modulators[0] = p.modulators.dictionary.tempo.index,
                Ni.modChannels[0] = -1,
                qi.instruments.push(Ni);
                const Oi = p.modCount - 1;
                let Ri = -1
                  , $i = null
                  , Hi = 0;
                for (let _i = 0; _i < v.length; _i++) {
                    const Vi = v[_i]
                      , Gi = Vi.midiTick
                      , Wi = I(Gi);
                    let ji = -1
                      , Ui = -1;
                    if (_i === v.length - 1)
                        ji = Gi + 1,
                        Ui = Wi + 1;
                    else {
                        ji = v[_i + 1].midiTick,
                        Ui = I(ji)
                    }
                    let Ki = Math.floor(Wi / P)
                      , Ji = Math.ceil(Ui / P);
                    for (let Yi = Ki; Yi < Ji; Yi++) {
                        const Qi = Yi * P
                          , Zi = Math.max(0, Hi - Qi);
                        let Xi = Math.min(P, Ui - Qi);
                        if (Zi < Xi) {
                            if (Ri != Yi || null == $i) {
                                for (Ri++; Ri < Yi; )
                                    qi.bars[Ri] = 0,
                                    Ri++;
                                $i = new Pt,
                                qi.patterns.push($i),
                                qi.bars[Ri] = qi.patterns.length,
                                $i.instruments[0] = 0,
                                $i.instruments.length = 1
                            }
                            const tn = Math.max(p.tempoMin, Math.min(p.tempoMax, Math.round(A / Vi.microsecondsPerBeat) - p.modulators.dictionary.tempo.convertRealFactor))
                              , en = new Tt(Oi,Zi,Xi,tn,!1);
                            $i.notes.push(en)
                        }
                    }
                    Hi = Ui
                }
            }
            function O(t, e) {
                for (; t.length > e; ) {
                    let e = t.length - 2
                      , i = t.length - 1
                      , n = Number.MAX_VALUE
                      , s = Number.MAX_VALUE;
                    for (let o = 0; o < t.length - 1; o++)
                        for (let a = o + 1; a < t.length; a++) {
                            const r = t[o]
                              , h = t[a];
                            let l = 0
                              , c = 0;
                            for (let t = 0; t < r.bars.length && t < h.bars.length; t++)
                                0 != r.bars[t] && 0 != h.bars[t] && l++,
                                0 == r.bars[t] && 0 == h.bars[t] && c++;
                            l <= n && (l < n || c < s) && (e = o,
                            i = a,
                            n = l,
                            s = c)
                        }
                    const o = t[e]
                      , a = t[i]
                      , r = o.instruments.length
                      , h = o.patterns.length;
                    for (const t of a.instruments)
                        o.instruments.push(t);
                    for (const t of a.patterns)
                        t.instruments[0] += r,
                        o.patterns.push(t);
                    for (let t = 0; t < o.bars.length && t < a.bars.length; t++)
                        0 == o.bars[t] && 0 != a.bars[t] && (o.bars[t] = a.bars[t] + h);
                    t.splice(i, 1)
                }
            }
            O(D, p.pitchChannelCountMax),
            O(z, p.noiseChannelCountMax),
            O(q, p.modChannelCountMax);
            this.m.goBackToStart();
            for (const nn of this.m.song.channels)
                nn.muted = !1;
            this.m.prompt = null,
            this.m.record(new class extends Zt {
                constructor(t) {
                    super();
                    const e = t.song;
                    e.tempo = E,
                    e.beatsPerBar = k,
                    e.key = L,
                    e.scale = 0,
                    e.rhythm = 2,
                    e.layeredInstruments = !1,
                    e.patternInstruments = D.some((t => t.instruments.length > 1)) || z.some((t => t.instruments.length > 1)),
                    dn(D),
                    dn(z),
                    dn(q),
                    this.append(new ln(t,D,z,q)),
                    e.loopStart = 0,
                    e.loopLength = e.barCount,
                    this.Nt(),
                    t.notifier.changed()
                }
            }
            (this.m), !0, !0)
        }
    }
    class vo {
        constructor(t, e) {
            this.No = document.createTextNode(""),
            this.vi = J.div({
                class: "channelBoxLabel"
            }, this.No),
            this.container = J.div({
                class: "channelBox",
                style: `margin: 1px; height: ${xo.patternHeight - 2}px;`
            }, this.vi),
            this.Oo = -1,
            this.Ro = "?",
            this.$o = "?",
            this.container.style.background = nt.uiWidgetBackground,
            this.vi.style.color = e
        }
        setWidth(t) {
            this.container.style.width = t - 2 + "px"
        }
        setHeight(t) {
            this.container.style.height = t - 2 + "px"
        }
        setIndex(t, e, i, n, s, o) {
            this.Oo != t && (t >= 100 ? (this.vi.setAttribute("font-size", "16"),
            this.vi.style.setProperty("transform", "translate(0px, -1.5px)")) : (this.vi.setAttribute("font-size", "20"),
            this.vi.style.setProperty("transform", "translate(0px, 0px)")),
            this.Oo = t,
            this.No.data = String(t));
            let a = e ? nt.c_invertedText : n;
            this.Ro != a && (this.vi.style.color = a,
            this.Ro = a),
            e || (n = s ? i ? nt.c_trackEditorBgNoiseDim : nt.c_trackEditorBgNoise : o ? i ? nt.c_trackEditorBgModDim : nt.c_trackEditorBgMod : i ? nt.c_trackEditorBgPitchDim : nt.c_trackEditorBgPitch),
            n = e ? n : 0 == t ? "none" : n,
            this.$o != n && (this.container.style.background = n,
            this.$o = n)
        }
    }
    class xo {
        constructor(t, e) {
            this.m = t,
            this.index = e,
            this.Ho = -1,
            this._o = -1,
            this.Vo = [],
            this.container = J.div({
                class: "channelRow"
            })
        }
        render() {
            xo.patternHeight = this.m.getChannelHeight();
            const t = this.m.getBarWidth();
            if (this.Vo.length != this.m.song.barCount) {
                for (let e = this.Vo.length; e < this.m.song.barCount; e++) {
                    const i = new vo(this.index,nt.getChannelColor(this.m.song, this.index).secondaryChannel);
                    i.setWidth(t),
                    this.container.appendChild(i.container),
                    this.Vo[e] = i
                }
                for (let t = this.m.song.barCount; t < this.Vo.length; t++)
                    this.container.removeChild(this.Vo[t].container);
                this.Vo.length = this.m.song.barCount
            }
            if (this.Ho != t) {
                this.Ho = t;
                for (let e = 0; e < this.Vo.length; e++)
                    this.Vo[e].setWidth(t)
            }
            if (this._o != xo.patternHeight) {
                this._o = xo.patternHeight;
                for (let t = 0; t < this.Vo.length; t++)
                    this.Vo[t].setHeight(xo.patternHeight)
            }
            for (let t = 0; t < this.Vo.length; t++) {
                const e = this.m.song.getPattern(this.index, t)
                  , i = t == this.m.bar && this.index == this.m.channel
                  , n = null == e || 0 == e.notes.length
                  , s = this.Vo[t];
                if (t < this.m.song.barCount) {
                    const e = nt.getChannelColor(this.m.song, this.index);
                    s.setIndex(this.m.song.channels[this.index].bars[t], i, n, n && !i ? e.secondaryChannel : e.primaryChannel, this.index >= this.m.song.pitchChannelCount && this.index < this.m.song.pitchChannelCount + this.m.song.noiseChannelCount, this.index >= this.m.song.pitchChannelCount + this.m.song.noiseChannelCount),
                    s.container.style.visibility = "visible"
                } else
                    s.container.style.visibility = "hidden";
                t == this.m.synth.loopBarStart ? s.container.style.setProperty("border-left", `1px dashed ${nt.uiWidgetFocus}`) : s.container.style.setProperty("border-left", "none"),
                t == this.m.synth.loopBarEnd ? s.container.style.setProperty("border-right", `1px dashed ${nt.uiWidgetFocus}`) : s.container.style.setProperty("border-right", "none")
            }
        }
    }
    xo.patternHeight = 28;
    const {button: ko, label: Mo, div: So, form: Fo, h2: Co, input: Ao} = J;
    class Eo {
        constructor(t) {
            this.m = t,
            this.bn = Ao({
                type: "file",
                accept: ".json,application/json,.mid,.midi,audio/midi,audio/x-midi"
            }),
            this.Re = ko({
                class: "okayButton",
                style: "width:45%;"
            }, "Okay"),
            this.Oe = ko({
                class: "cancelButton"
            }),
            this.Go = Fo({
                style: "display: flex; gap: 10px; flex-wrap: wrap; justify-content: center;"
            }, Mo({
                class: "layout-option"
            }, Ao({
                type: "radio",
                name: "layout",
                value: "small"
            }), Y('\t\t\t\t\t<svg viewBox="-4 -1 28 22">\n\t\t\t\t\t\t<rect x="0" y="0" width="20" height="20" fill="none" stroke="currentColor" stroke-width="1"/>\n\t\t\t\t\t\t<rect x="2" y="2" width="11" height="10" fill="currentColor"/>\n\t\t\t\t\t\t<rect x="14" y="2" width="4" height="16" fill="currentColor"/>\n\t\t\t\t\t\t<rect x="2" y="13" width="11" height="5" fill="currentColor"/>\n\t\t\t\t\t</svg>\n\t\t\t\t'), So("Small")), Mo({
                class: "layout-option"
            }, Ao({
                type: "radio",
                name: "layout",
                value: "long"
            }), Y('\t\t\t\t\t<svg viewBox="-1 -1 28 22">\n\t\t\t\t\t\t<rect x="0" y="0" width="26" height="20" fill="none" stroke="currentColor" stroke-width="1"/>\n\t\t\t\t\t\t<rect x="2" y="2" width="12" height="10" fill="currentColor"/>\n\t\t\t\t\t\t<rect x="15" y="2" width="4" height="10" fill="currentColor"/>\n\t\t\t\t\t\t<rect x="20" y="2" width="4" height="10" fill="currentColor"/>\n\t\t\t\t\t\t<rect x="2" y="13" width="22" height="5" fill="currentColor"/>\n\t\t\t\t\t</svg>\n\t\t\t\t'), So("Long")), Mo({
                class: "layout-option"
            }, Ao({
                type: "radio",
                name: "layout",
                value: "tall"
            }), Y('\t\t\t\t\t<svg viewBox="-1 -1 28 22">\n\t\t\t\t\t\t<rect x="0" y="0" width="26" height="20" fill="none" stroke="currentColor" stroke-width="1"/>\n\t\t\t\t\t\t<rect x="11" y="2" width="8" height="16" fill="currentColor"/>\n\t\t\t\t\t\t<rect x="20" y="2" width="4" height="16" fill="currentColor"/>\n\t\t\t\t\t\t<rect x="2" y="2" width="8" height="16" fill="currentColor"/>\n\t\t\t\t\t</svg>\n\t\t\t\t'), So("Tall")), Mo({
                class: "layout-option"
            }, Ao({
                type: "radio",
                name: "layout",
                value: "wide"
            }), Y('\t\t\t\t\t<svg viewBox="-1 -1 28 22">\n\t\t\t\t\t\t<rect x="0" y="0" width="26" height="20" fill="none" stroke="currentColor" stroke-width="1"/>\n\t\t\t\t\t\t<rect x="2" y="2" width="4" height="16" fill="currentColor"/>\n\t\t\t\t\t\t<rect x="18" y="2" width="2.5" height="16" fill="currentColor"/>\n\t\t\t\t\t\t<rect x="21.5" y="2" width="2.5" height="16" fill="currentColor"/>\n\t\t\t\t\t\t<rect x="7" y="2" width="10" height="16" fill="currentColor"/>\n\t\t\t\t\t</svg>\n\t\t\t\t'), So("Wide (JB)")), Mo({
                class: "layout-option"
            }, Ao({
                type: "radio",
                name: "layout",
                value: "wide long"
            }), Y('\t\t\t\t\t<svg viewBox="-1 -1 28 22">\n\t\t\t\t\t\t<rect x="0" y="0" width="26" height="20" fill="none" stroke="currentColor" stroke-width="1"/>\n\t\t\t\t\t\t<rect x="2" y="2" width="12" height="10" fill="currentColor"/>\n\t\t\t\t\t\t<rect x="15" y="2" width="4" height="16" fill="currentColor"/>\n\t\t\t\t\t\t<rect x="20" y="2" width="4" height="16" fill="currentColor"/>\n\t\t\t\t\t\t<rect x="2" y="13" width="12" height="5" fill="currentColor"/>\n\t\t\t\t\t</svg>\n\t\t\t\t'), So("Wide Long (AB)")), Mo({
                class: "layout-option"
            }, Ao({
                type: "radio",
                name: "layout",
                value: "flipped long"
            }), Y('\t\t\t\t\t<svg viewBox="-1 -1 28 22">\n\t\t\t\t\t\t<rect x="0" y="0" width="26" height="20" fill="none" stroke="currentColor" stroke-width="1"/>\n\t\t\t\t\t\t<rect x="2" y="2" width="22" height="2" fill="currentColor"/>\n\t\t\t\t\t\t<rect x="2" y="5" width="4" height="8" fill="currentColor"/>\n\t\t\t\t\t\t<rect x="7" y="5" width="17" height="8" fill="currentColor"/>\n\t\t\t\t\t\t<rect x="2" y="14" width="22" height="4" fill="currentColor"/>\n\t\t\t\t\t</svg>\n\t\t\t\t'), So("Flipped Long (AB)")), Mo({
                class: "layout-option"
            }, Ao({
                type: "radio",
                name: "layout",
                value: "focused long"
            }), Y('\t\t\t\t\t<svg viewBox="-1 -1 28 22">\n\t\t\t\t\t\t<rect x="0" y="0" width="26" height="20" fill="none" stroke="currentColor" stroke-width="1"/>\n\t\t\t\t\t\t<rect x="2" y="2" width="17" height="10" fill="currentColor"/>\n\t\t\t\t\t\t<rect x="20" y="2" width="4" height="16" fill="currentColor"/>\n\t\t\t\t\t\t<rect x="2" y="13" width="17" height="5" fill="currentColor"/>\n\t\t\t\t\t</svg>\n\t\t\t\t'), So("Focused long (AB)"))),
            this.container = So({
                class: "prompt noSelection",
                style: "width: 300px;"
            }, Co("Layout"), this.Go, So({
                style: "display: flex; flex-direction: row-reverse; justify-content: space-between;"
            }, this.Re), this.Oe),
            this.$e = () => {
                this.m.undo()
            }
            ,
            this.cleanUp = () => {
                this.Re.removeEventListener("click", this.Wo),
                this.Oe.removeEventListener("click", this.$e),
                this.container.removeEventListener("keydown", this.Ge)
            }
            ,
            this.Ge = t => {
                "BUTTON" != t.target.tagName && 13 == t.keyCode && this.Wo()
            }
            ,
            this.Wo = () => {
                this.m.prefs.layout = this.Go.elements.layout.value,
                this.m.prefs.save(),
                so.setLayout(this.m.prefs.layout),
                this.$e()
            }
            ,
            this.bn.select(),
            setTimeout(( () => this.bn.focus())),
            this.Re.addEventListener("click", this.Wo),
            this.Oe.addEventListener("click", this.$e),
            this.container.addEventListener("keydown", this.Ge),
            this.Go.elements.layout.value = this.m.prefs.layout
        }
    }
    class To {
        constructor(t) {
            this.m = t,
            this.container = J.div({
                class: "envelopeEditor"
            }),
            this.jo = [],
            this.Uo = [],
            this.Ko = [],
            this.Jo = [],
            this.Yo = 0,
            this.Qo = -1,
            this.Zo = -1,
            this.Xo = 0,
            this.ta = t => {
                const e = this.Uo.indexOf(t.target)
                  , i = this.Ko.indexOf(t.target);
                if (-1 != e) {
                    const t = parseInt(this.Uo[e].value)
                      , i = t % p.instrumentAutomationTargets.length
                      , n = t / p.instrumentAutomationTargets.length >>> 0;
                    this.m.record(new jn(this.m,e,i,n))
                } else
                    -1 != i && this.m.record(new Un(this.m,i,this.Ko[i].selectedIndex))
            }
            ,
            this.ea = t => {
                const e = this.Jo.indexOf(t.target);
                -1 != e && this.m.record(new Wn(this.m,e))
            }
            ,
            this.container.addEventListener("change", this.ta),
            this.container.addEventListener("click", this.ea)
        }
        ia(t, e) {
            let i = p.instrumentAutomationTargets[t].displayName;
            return p.instrumentAutomationTargets[t].maxCount > 1 && (-1 != i.indexOf("#") ? i = i.replace("#", String(e + 1)) : i += " " + (e + 1)),
            J.option({
                value: t + e * p.instrumentAutomationTargets.length
            }, i)
        }
        na(t, e) {
            for (let i = 0; i < t.childElementCount; i++) {
                const n = t.children[i]
                  , s = parseInt(n.value)
                  , o = s % p.instrumentAutomationTargets.length
                  , a = s / p.instrumentAutomationTargets.length >>> 0;
                n.hidden = !e.supportsEnvelopeTarget(o, a)
            }
        }
        render() {
            const t = this.m.song.channels[this.m.channel].instruments[this.m.getCurrentInstrument()];
            for (let e = this.jo.length; e < t.envelopeCount; e++) {
                const t = J.select();
                for (let e = 0; e < p.instrumentAutomationTargets.length; e++) {
                    const i = p.instrumentAutomationTargets[e].interleave;
                    for (let n = 0; n < p.instrumentAutomationTargets[e].maxCount; n++)
                        t.appendChild(this.ia(e, n)),
                        i && t.appendChild(this.ia(e + 1, n));
                    i && e++
                }
                const i = J.select();
                for (let t = 0; t < p.envelopes.length; t++)
                    i.appendChild(J.option({
                        value: t
                    }, p.envelopes[t].name));
                const n = J.button({
                    type: "button",
                    class: "delete-envelope"
                })
                  , s = J.div({
                    class: "envelope-row"
                }, J.div({
                    class: "selectContainer",
                    style: "width: 0; flex: 1;"
                }, t), J.div({
                    class: "selectContainer",
                    style: "width: 0; flex: 0.7;"
                }, i), n);
                this.container.appendChild(s),
                this.jo[e] = s,
                this.Uo[e] = t,
                this.Ko[e] = i,
                this.Jo[e] = n
            }
            for (let e = this.Yo; e < t.envelopeCount; e++)
                this.jo[e].style.display = "",
                this.na(this.Uo[e], t);
            for (let e = t.envelopeCount; e < this.Yo; e++)
                this.jo[e].style.display = "none";
            let e = t.noteFilter.controlPointCount;
            if (t.noteFilterType && (e = 1),
            this.Qo != t.eqFilter.controlPointCount || this.Zo != e || this.sa != t.type || this.Xo != t.effects)
                for (let e = 0; e < this.Yo; e++)
                    this.na(this.Uo[e], t);
            for (let e = 0; e < t.envelopeCount; e++)
                this.Uo[e].value = String(t.envelopes[e].target + t.envelopes[e].index * p.instrumentAutomationTargets.length),
                this.Ko[e].selectedIndex = t.envelopes[e].envelope;
            this.Yo = t.envelopeCount,
            this.Qo = t.eqFilter.controlPointCount,
            this.Zo = e,
            this.sa = t.type,
            this.Xo = t.effects
        }
    }
    class Po {
        constructor(t) {
            this.m = t,
            this.u = 120,
            this.v = 26,
            this.oa = Y.path({
                fill: nt.uiWidgetBackground,
                "pointer-events": "none"
            }),
            this.gi = Y.path({
                fill: "none",
                stroke: "currentColor",
                "stroke-width": 1,
                "stroke-dasharray": "3, 2",
                "pointer-events": "none"
            }),
            this.aa = Y.path({
                fill: "none",
                stroke: "currentColor",
                "stroke-width": 2,
                "pointer-events": "none"
            }),
            this.q = Y.svg({
                style: `background-color: ${nt.editorBackground}; touch-action: none; cursor: crosshair;`,
                width: "100%",
                height: "100%",
                viewBox: "0 0 " + this.u + " " + this.v,
                preserveAspectRatio: "none"
            }, this.oa, this.gi, this.aa),
            this.container = J.div({
                class: "fadeInOut",
                style: "height: 100%;"
            }, this.q),
            this.N = 0,
            this.ra = 0,
            this.O = !1,
            this.Si = !1,
            this.ha = !1,
            this.Bi = null,
            this.la = -1,
            this.ca = -1,
            this.K = t => {
                t.preventDefault();
                const e = this.q.getBoundingClientRect();
                this.N = (t.clientX || t.pageX) - e.left,
                this.Ri()
            }
            ,
            this.Y = t => {
                t.preventDefault();
                const e = this.q.getBoundingClientRect();
                this.N = t.touches[0].clientX - e.left,
                this.Ri()
            }
            ,
            this.Z = t => {
                if (null == this.container.offsetParent)
                    return;
                const e = this.q.getBoundingClientRect();
                this.N = (t.clientX || t.pageX) - e.left,
                isNaN(this.N) && (this.N = 0),
                this.X()
            }
            ,
            this.tt = t => {
                if (null == this.container.offsetParent)
                    return;
                if (!this.O)
                    return;
                t.preventDefault();
                const e = this.q.getBoundingClientRect();
                this.N = t.touches[0].clientX - e.left,
                isNaN(this.N) && (this.N = 0),
                this.X()
            }
            ,
            this.et = t => {
                if (null != this.container.offsetParent) {
                    if (this.O && this.m.lastChangeWas(this.Bi) && null != this.Bi)
                        if (this.Si)
                            this.m.record(this.Bi);
                        else {
                            const t = this.m.song.channels[this.m.channel].instruments[this.m.getCurrentInstrument()];
                            this.ha ? this.m.record(new xi(this.m,this.da(this.N),t.fadeOut)) : this.m.record(new xi(this.m,t.fadeIn,this.pa(this.N)))
                        }
                    this.Bi = null,
                    this.Si = !1,
                    this.O = !1
                }
            }
            ;
            const e = this.ma(p.fadeOutNeutral);
            this.gi.setAttribute("d", `M ${e} 0 L ${e} ${this.v}`),
            this.container.addEventListener("mousedown", this.K),
            document.addEventListener("mousemove", this.Z),
            document.addEventListener("mouseup", this.et),
            this.container.addEventListener("touchstart", this.Y),
            this.container.addEventListener("touchmove", this.tt),
            this.container.addEventListener("touchend", this.et),
            this.container.addEventListener("touchcancel", this.et)
        }
        ua(t) {
            return 1 + .4 * (this.u - 2) * t / (p.fadeInRange - 1)
        }
        da(t) {
            return yt(0, p.fadeInRange, Math.round((t - 1) * (p.fadeInRange - 1) / (.4 * this.u - 2)))
        }
        ma(t) {
            return 1 + (this.u - 2) * (.5 + .5 * t / (p.fadeOutTicks.length - 1))
        }
        pa(t) {
            return yt(0, p.fadeOutTicks.length, Math.round((p.fadeOutTicks.length - 1) * ((t - 1) / (this.u - 2) - .5) / .5))
        }
        Ri() {
            isNaN(this.N) && (this.N = 0),
            this.ra = this.N,
            this.O = !0,
            this.Si = !1;
            const t = this.m.song.channels[this.m.channel].instruments[this.m.getCurrentInstrument()]
              , e = this.ua(t.fadeIn)
              , i = this.ma(t.fadeOut);
            this.ha = this.ra < (e + i) / 2,
            this.Bi = new Xt,
            this.m.setProspectiveChange(this.Bi)
        }
        X() {
            if (null != this.Bi && this.m.lastChangeWas(this.Bi) ? this.Bi.undo() : this.O = !1,
            this.Bi = null,
            this.O) {
                const t = new Xt;
                if (this.Bi = t,
                this.m.setProspectiveChange(this.Bi),
                Math.abs(this.N - this.ra) > 4 && (this.Si = !0),
                this.Si) {
                    const e = this.m.song.channels[this.m.channel].instruments[this.m.getCurrentInstrument()];
                    this.ha ? t.append(new xi(this.m,this.da(this.ua(e.fadeIn) + this.N - this.ra),e.fadeOut)) : t.append(new xi(this.m,e.fadeIn,this.pa(this.ma(e.fadeOut) + this.N - this.ra)))
                }
            }
        }
        render() {
            const t = this.m.song.channels[this.m.channel].instruments[this.m.getCurrentInstrument()];
            if (this.la == t.fadeIn && this.ca == t.fadeOut)
                return;
            const e = this.ua(t.fadeIn)
              , i = this.ma(t.fadeOut);
            this.aa.setAttribute("d", `M ${e} 0 L ${e} ${this.v} M ${i} 0 L ${i} ${this.v}`);
            const n = this.ma(p.fadeOutNeutral);
            let s = "";
            s += `M 0 ${this.v} `,
            s += `L ${e} 0 `,
            Jt.fadeOutSettingToTicks(t.fadeOut) > 0 ? (s += `L ${n} 0 `,
            s += `L ${i} ${this.v} `) : (s += `L ${i} 0 `,
            s += `L ${n} ${this.v} `),
            s += "z",
            this.oa.setAttribute("d", s)
        }
    }
    const {button: Bo, div: Io, h2: Lo, input: Do} = J;
    class zo {
        constructor(t) {
            this.u = 200,
            this.v = 52,
            this.ni = Y.path({
                fill: nt.uiWidgetBackground,
                "pointer-events": "none"
            }),
            this.si = Y.svg({
                "pointer-events": "none"
            }),
            this.oi = Y.svg({
                "pointer-events": "none"
            }),
            this.fa = Y.path({
                fill: "none",
                stroke: nt.textSelection,
                "stroke-width": 2,
                "pointer-events": "none"
            }),
            this.ya = Y.circle({
                fill: nt.textSelection,
                stroke: "none",
                r: "3"
            }),
            this.ba = Y.path({
                fill: "none",
                stroke: nt.primaryText,
                "stroke-width": 2,
                "pointer-events": "none"
            }),
            this.ga = Y.path({
                fill: "none",
                stroke: nt.linkAccent,
                "stroke-width": 2,
                "pointer-events": "none"
            }),
            this.wa = Y.circle({
                fill: nt.linkAccent,
                stroke: "none",
                r: "3"
            }),
            this.va = Y.text({
                x: "-1.5%",
                y: "148.5%",
                "pointer-events": "none",
                "font-size": "7pt",
                fill: "var(--secondary-text)"
            }, "0"),
            this.xa = Y.text({
                x: "48.2%",
                y: "148.5%",
                "pointer-events": "none",
                "font-size": "7pt",
                fill: "var(--secondary-text)"
            }, "1"),
            this.ka = Y.text({
                x: "98.2%",
                y: "148.5%",
                "pointer-events": "none",
                "font-size": "7pt",
                fill: "var(--secondary-text)"
            }, "2"),
            this.Ma = Y.text({
                x: "-5%",
                y: "113.5%",
                "pointer-events": "none",
                "font-size": "6pt",
                fill: "var(--secondary-text)"
            }, "In"),
            this.Sa = Y.text({
                x: "-9%",
                y: "131%",
                "pointer-events": "none",
                "font-size": "6pt",
                fill: "var(--secondary-text)"
            }, "Out"),
            this.Fa = Y.text({
                x: "42%",
                y: "172%",
                "pointer-events": "none",
                "font-size": "7pt",
                fill: "var(--primary-text)"
            }, "Volume"),
            this.Ca = Y.text({
                x: "55.2%",
                y: "160%",
                "pointer-events": "none",
                "font-size": "7pt",
                transform: "rotate(-90 30,120)",
                fill: "var(--primary-text)"
            }, "Gain"),
            this.Aa = Y.rect({
                "pointer-events": "none",
                width: "100%",
                height: "6px",
                x: "0%",
                y: "105%",
                fill: nt.uiWidgetBackground
            }),
            this.Ea = Y.rect({
                "pointer-events": "none",
                width: "100%",
                height: "6px",
                x: "0%",
                y: "120%",
                fill: nt.uiWidgetBackground
            }),
            this.Ta = Y.rect({
                "pointer-events": "none",
                height: "6px",
                x: "0%",
                y: "105%",
                fill: "url('#volumeGrad')"
            }),
            this.Pa = Y.rect({
                "pointer-events": "none",
                width: "2px",
                height: "6px",
                y: "105%",
                fill: nt.uiWidgetFocus
            }),
            this.Ba = Y.rect({
                "pointer-events": "none",
                height: "6px",
                x: "0%",
                y: "120%",
                fill: "url('#volumeGrad')"
            }),
            this.Ia = Y.rect({
                "pointer-events": "none",
                width: "2px",
                height: "6px",
                y: "120%",
                fill: nt.uiWidgetFocus
            }),
            this.La = Y.stop({
                "stop-color": "lime",
                offset: "30%"
            }),
            this.Da = Y.stop({
                "stop-color": "orange",
                offset: "45%"
            }),
            this.za = Y.stop({
                "stop-color": "red",
                offset: "50%"
            }),
            this.qa = Y.linearGradient({
                id: "volumeGrad",
                gradientUnits: "userSpaceOnUse"
            }, this.La, this.Da, this.za),
            this.Na = Y.defs({}, this.qa),
            this.q = Y.svg({
                style: `background-color: ${nt.editorBackground}; touch-action: none; overflow: visible;`,
                width: "100%",
                height: "100%",
                viewBox: "0 0 " + this.u + " " + this.v,
                preserveAspectRatio: "none"
            }, this.Na, this.ni, this.si, this.oi, this.fa, this.ba, this.ga, this.ya, this.wa, this.va, this.xa, this.ka, this.Ma, this.Sa, this.Fa, this.Ca, this.Aa, this.Ea, this.Ta, this.Ba, this.Pa, this.Ia),
            this.container = J.div({
                class: "",
                style: "height: 4em; width: 80%; padding-bottom: 1.5em;"
            }, this.q);
            for (let t = 0; t <= 2; t++)
                this.si.appendChild(Y.rect({
                    fill: nt.tonic,
                    x: t * this.u / 2 - 1,
                    y: 0,
                    width: 2,
                    height: this.v
                }));
            for (let t = 1; t <= 3; t += 2)
                this.oi.appendChild(Y.rect({
                    fill: nt.fifthNote,
                    x: t * this.u / 4 - 1,
                    y: 0,
                    width: 1,
                    height: this.v
                }));
            this.Oa = t
        }
        animateVolume(t, e, i, n) {
            this.Ta.setAttribute("width", "" + Math.min(this.u, t * (this.u / 2))),
            this.Pa.setAttribute("x", "" + Math.min(this.u, e * (this.u / 2))),
            this.Ba.setAttribute("width", "" + Math.min(this.u, i * (this.u / 2))),
            this.Ia.setAttribute("x", "" + Math.min(this.u, n * (this.u / 2)))
        }
        render() {
            const t = t => Math.max(0, (1 - t / 5) * (this.v - 1) + 1);
            let e = 0
              , i = 0
              , n = -1
              , s = ""
              , o = ["", "", ""];
            for (let a = 0; a < 64; a++) {
                let r = +this.Oa.limitRatioSlider.value;
                r = r < 10 ? r / 10 : r - 9;
                let h = +this.Oa.compressionRatioSlider.value;
                h = h < 10 ? h / 10 : 1 + (h - 10) / 60;
                let l = +this.Oa.limitThresholdSlider.value
                  , c = +this.Oa.compressionThresholdSlider.value
                  , d = 2 * a / 64
                  , p = 1 / 1.05;
                d >= l ? p = 1 / (1.05 * (d + 1 - l) * r + (1 - r)) : d < c && (p = 1 / ((.8 * (d + 1 - c) + .25) * h + 1.05 * (1 - h))),
                0 == a && (s += "M 0 " + q(t(p)) + " "),
                i > n && (n >= 0 && (o[n] += "L " + q(a * this.u / 64) + " " + q(t(p)) + " "),
                o[i] += "M " + q(a * this.u / 64) + " " + q(t(p)) + " ",
                (1 == i || 0 == n && 2 == i) && (this.ya.setAttribute("cx", q(a * this.u / 64)),
                this.ya.setAttribute("cy", q(t(p)))),
                2 == i && (this.wa.setAttribute("cx", q(a * this.u / 64)),
                this.wa.setAttribute("cy", q(t(p)))),
                n = i),
                0 != e || 0 != p ? (s += "L ",
                o[i] += "L ") : (s += "M ",
                o[i] += "M "),
                s += q(a * this.u / 64) + " " + q(t(p)) + " ",
                o[i] += q(a * this.u / 64) + " " + q(t(p)) + " ",
                e = p,
                0 == i && a >= 32 * c - 2 && i++,
                1 == i && a >= 32 * l - 2 && i++
            }
            const a = t(e);
            e > 0 && (s += "L " + (this.u - 1) + " " + q(a) + " ",
            o[i] += "L " + (this.u - 1) + " " + q(a) + " "),
            this.fa.setAttribute("d", o[0]),
            this.ba.setAttribute("d", o[1]),
            this.ga.setAttribute("d", o[2]),
            this.ni.setAttribute("d", s + "L " + this.u + " " + q(a) + " L " + this.u + " " + q(this.v) + " L 0 " + q(this.v) + " z ")
        }
    }
    class qo {
        constructor(t, e) {
            this.m = t,
            this.hi = e,
            this.limiterCanvas = new zo(this),
            this.ci = Bo({
                style: "width: 55%;",
                type: "button"
            }),
            this.limitDecaySlider = Do({
                title: "limit decay",
                style: "width: 5em; flex-grow: 1; margin: 0;",
                type: "range",
                min: "1",
                max: "30",
                value: "4",
                step: "1"
            }),
            this.limitRiseSlider = Do({
                title: "limit rise",
                style: "width: 5em; flex-grow: 1; margin: 0;",
                type: "range",
                min: "2000",
                max: "10000",
                value: "4000",
                step: "250"
            }),
            this.compressionThresholdSlider = Do({
                title: "compressor threshold",
                style: "width: 100%; flex-grow: 1; margin: 0;",
                type: "range",
                min: "0",
                max: "1.1",
                value: "1",
                step: "0.05"
            }),
            this.limitThresholdSlider = Do({
                title: "limiter threshold",
                style: "width: 100%; flex-grow: 1; margin: 0;",
                type: "range",
                min: "0",
                max: "2",
                value: "1",
                step: "0.05"
            }),
            this.compressionRatioSlider = Do({
                title: "compressor ratio",
                style: "width: 100%; flex-grow: 1; margin: 0;",
                type: "range",
                min: "0",
                max: "20",
                value: "10",
                step: "1"
            }),
            this.limitRatioSlider = Do({
                title: "limiter ratio",
                style: "width: 100%; flex-grow: 1; margin: 0;",
                type: "range",
                min: "0",
                max: "20",
                value: "10",
                step: "1"
            }),
            this.masterGainSlider = Do({
                title: "master gain",
                style: "width: 5em; flex-grow: 1; margin: 0;",
                type: "range",
                min: "0",
                max: "5",
                value: "1",
                step: "0.02"
            }),
            this.inVolumeHistoricTimer = 0,
            this.inVolumeHistoricCap = 0,
            this.outVolumeHistoricTimer = 0,
            this.outVolumeHistoricCap = 0,
            this.Oe = Bo({
                class: "cancelButton"
            }),
            this.Re = Bo({
                class: "okayButton",
                style: "width:45%;"
            }, "Okay"),
            this.Ra = Bo({
                style: "width:45%;"
            }, "Reset"),
            this.container = Io({
                class: "prompt noSelection",
                style: "width: 250px;"
            }, Lo("Limiter Options"), Io({
                style: "display: flex; width: 55%; align-self: center; flex-direction: row; align-items: center; justify-content: center;"
            }, this.ci), Io({
                style: "display: flex; flex-direction: row; align-items: center; justify-content: center;"
            }, this.limiterCanvas.container), Io({
                style: "display: flex; flex-direction: row; align-items: center; height: 2em; margin-top: 1.5em; justify-content: flex-end;"
            }, Io({
                style: `text-align: right; width: 25%; margin-right: 4.5%; color: ${nt.primaryText};`
            }, ""), Io({
                style: `text-align: center; width: 33%; margin-right: 4.5%; color: ${nt.textSelection};`
            }, "Boost"), Io({
                style: `text-align: center; width: 33%; margin-right: 0%; color: ${nt.linkAccent};`
            }, "Cutoff")), Io({
                style: "display: flex; flex-direction: row; align-items: center; height: 2em; margin-top: 0.5em; justify-content: flex-end;"
            }, Io({
                style: `text-align: right; width: 25%; margin-right: 4.5%; color: ${nt.primaryText};`
            }, "Threshold:"), Io({
                style: "width: 33%; margin-right: 4.5%;"
            }, this.compressionThresholdSlider), Io({
                style: "width: 33%; margin-right: 0%;"
            }, this.limitThresholdSlider)), Io({
                style: "display: flex; flex-direction: row; align-items: center; height: 2em; justify-content: flex-end;"
            }, Io({
                style: `text-align: right; width: 25%; margin-right: 4.5%; color: ${nt.primaryText};`
            }, "Ratio:"), Io({
                style: "width: 33%; margin-right: 4.5%;"
            }, this.compressionRatioSlider), Io({
                style: "width: 33%; margin-right: 0%;"
            }, this.limitRatioSlider)), Io({
                style: "display: flex; flex-direction: row; align-items: center; height: 2em; justify-content: flex-end;"
            }, Io({
                style: `text-align: right; width: 8.5em; margin-right: 1em; color: ${nt.primaryText};`
            }, "Limit Decay:"), this.limitDecaySlider), Io({
                style: "display: flex; flex-direction: row; align-items: center; height: 2em; justify-content: flex-end;"
            }, Io({
                style: `text-align: right; width: 8.5em; margin-right: 1em; color: ${nt.primaryText};`
            }, "Limit Rise:"), this.limitRiseSlider), Io({
                style: "display: flex; flex-direction: row; align-items: center; height: 2em; justify-content: flex-end;"
            }, Io({
                style: `text-align: right; width: 8.5em; margin-right: 1em; color: ${nt.primaryText};`
            }, "Master Gain:"), this.masterGainSlider), Io({
                style: "display: flex; flex-direction: row-reverse; justify-content: space-between;"
            }, this.Re, this.Ra), this.Oe),
            this.$a = () => {
                this.inVolumeHistoricTimer--,
                this.inVolumeHistoricTimer <= 0 && (this.inVolumeHistoricCap -= .03),
                this.m.song.inVolumeCap > this.inVolumeHistoricCap && (this.inVolumeHistoricCap = this.m.song.inVolumeCap,
                this.inVolumeHistoricTimer = 50),
                this.outVolumeHistoricTimer--,
                this.outVolumeHistoricTimer <= 0 && (this.outVolumeHistoricCap -= .03),
                this.m.song.outVolumeCap > this.outVolumeHistoricCap && (this.outVolumeHistoricCap = this.m.song.outVolumeCap,
                this.outVolumeHistoricTimer = 50),
                this.limiterCanvas.animateVolume(this.m.song.inVolumeCap, this.inVolumeHistoricCap, this.m.song.outVolumeCap, this.outVolumeHistoricCap),
                window.requestAnimationFrame(this.$a)
            }
            ,
            this.di = () => {
                this.hi.togglePlay(),
                this.updatePlayButton()
            }
            ,
            this.Lo = () => {
                +this.limitThresholdSlider.value < +this.compressionThresholdSlider.value && (this.limitThresholdSlider.removeEventListener("input", this.Ha),
                this.limitThresholdSlider.value = this.compressionThresholdSlider.value,
                this.limitThresholdSlider.addEventListener("input", this.Ha)),
                this.limiterCanvas.render(),
                this._a()
            }
            ,
            this.Ha = () => {
                +this.limitThresholdSlider.value < +this.compressionThresholdSlider.value && (this.compressionThresholdSlider.removeEventListener("input", this.Lo),
                this.compressionThresholdSlider.value = this.limitThresholdSlider.value,
                this.compressionThresholdSlider.addEventListener("input", this.Lo)),
                this.limiterCanvas.render(),
                this._a()
            }
            ,
            this.$e = () => {
                this.limitRatioSlider.value = "" + this.startingLimitRatio,
                this.compressionRatioSlider.value = "" + this.startingCompressionRatio,
                this.limitThresholdSlider.value = "" + this.startingLimitThreshold,
                this.compressionThresholdSlider.value = "" + this.startingCompressionThreshold,
                this.limitDecaySlider.value = "" + this.startingLimitDecay,
                this.limitRiseSlider.value = "" + this.startingLimitRise,
                this.masterGainSlider.value = "" + this.startingMasterGain,
                this._a(),
                this.m.prompt = null
            }
            ,
            this.cleanUp = () => {
                this.Re.removeEventListener("click", this.He),
                this.Ra.removeEventListener("click", this.Va),
                this.Oe.removeEventListener("click", this.$e),
                this.container.removeEventListener("keydown", this.whenKeyPressed),
                this.limitDecaySlider.removeEventListener("input", this.Lo),
                this.limitRiseSlider.removeEventListener("input", this.Lo),
                this.limitThresholdSlider.removeEventListener("input", this.Ha),
                this.limitRatioSlider.removeEventListener("input", this.Lo),
                this.compressionRatioSlider.removeEventListener("input", this.Lo),
                this.compressionThresholdSlider.removeEventListener("input", this.Lo),
                this.masterGainSlider.removeEventListener("input", this.Lo),
                this.ci.removeEventListener("click", this.di)
            }
            ,
            this.whenKeyPressed = t => {
                "BUTTON" != t.target.tagName && 13 == t.keyCode && this.He(),
                32 == t.keyCode && (this.di(),
                t.preventDefault())
            }
            ,
            this.Va = () => {
                "10" == this.limitRatioSlider.value && "4000" == this.limitRiseSlider.value && "4" == this.limitDecaySlider.value && "1" == this.limitThresholdSlider.value && "10" == this.compressionRatioSlider.value && "1" == this.compressionThresholdSlider.value && "1" == this.masterGainSlider.value || (this.limitRatioSlider.value = "10",
                this.limitRiseSlider.value = "4000",
                this.limitDecaySlider.value = "4",
                this.limitThresholdSlider.value = "1",
                this.compressionRatioSlider.value = "10",
                this.compressionThresholdSlider.value = "1",
                this.masterGainSlider.value = "1",
                this.Lo())
            }
            ,
            this._a = () => {
                this.m.record(new Se(this.m,+this.limitRatioSlider.value < 10 ? +this.limitRatioSlider.value / 10 : +this.limitRatioSlider.value - 9,+this.compressionRatioSlider.value < 10 ? +this.compressionRatioSlider.value / 10 : 1 + (+this.compressionRatioSlider.value - 10) / 60,+this.limitThresholdSlider.value,+this.compressionThresholdSlider.value,+this.limitRiseSlider.value,+this.limitDecaySlider.value,+this.masterGainSlider.value), !0)
            }
            ,
            this.He = () => {
                this._a(),
                this.m.prompt = null
            }
            ,
            this.Re.addEventListener("click", this.He),
            this.Ra.addEventListener("click", this.Va),
            this.Oe.addEventListener("click", this.$e),
            this.container.addEventListener("keydown", this.whenKeyPressed),
            this.limitRatioSlider.value = "" + (this.m.song.limitRatio < 1 ? 10 * this.m.song.limitRatio : 9 + this.m.song.limitRatio),
            this.compressionRatioSlider.value = "" + (this.m.song.compressionRatio < 1 ? 10 * this.m.song.compressionRatio : 10 + 60 * (this.m.song.compressionRatio - 1)),
            this.limitThresholdSlider.value = "" + this.m.song.limitThreshold,
            this.compressionThresholdSlider.value = "" + this.m.song.compressionThreshold,
            this.limitDecaySlider.value = "" + this.m.song.limitDecay,
            this.limitRiseSlider.value = "" + this.m.song.limitRise,
            this.masterGainSlider.value = "" + this.m.song.masterGain,
            this.startingLimitRatio = +this.limitRatioSlider.value,
            this.startingCompressionRatio = +this.compressionRatioSlider.value,
            this.startingLimitThreshold = +this.limitThresholdSlider.value,
            this.startingCompressionThreshold = +this.compressionThresholdSlider.value,
            this.startingLimitDecay = +this.limitDecaySlider.value,
            this.startingLimitRise = +this.limitRiseSlider.value,
            this.startingMasterGain = +this.masterGainSlider.value,
            this.limitDecaySlider.addEventListener("input", this.Lo),
            this.limitRiseSlider.addEventListener("input", this.Lo),
            this.limitRatioSlider.addEventListener("input", this.Lo),
            this.limitThresholdSlider.addEventListener("input", this.Ha),
            this.compressionRatioSlider.addEventListener("input", this.Lo),
            this.compressionThresholdSlider.addEventListener("input", this.Lo),
            this.masterGainSlider.addEventListener("input", this.Lo),
            this.ci.addEventListener("click", this.di),
            window.requestAnimationFrame(this.$a),
            this.updatePlayButton(),
            setTimeout(( () => this.ci.focus())),
            this.limiterCanvas.render()
        }
        updatePlayButton() {
            this.m.synth.playing ? (this.ci.classList.remove("playButton"),
            this.ci.classList.add("pauseButton"),
            this.ci.title = "Pause (Space)",
            this.ci.innerText = "Pause") : (this.ci.classList.remove("pauseButton"),
            this.ci.classList.add("playButton"),
            this.ci.title = "Play (Space)",
            this.ci.innerText = "Play")
        }
    }
    const {button: No, div: Oo, h2: Ro, input: $o, p: Ho} = J;
    class _o {
        constructor(t) {
            this.m = t,
            this.Ga = [],
            this.Wa = [],
            this.ja = [],
            this.Oe = No({
                class: "cancelButton"
            }),
            this.Re = No({
                class: "okayButton",
                style: "width:45%;"
            }, "Okay"),
            this.$e = () => {
                this.m.undo()
            }
            ,
            this.cleanUp = () => {
                this.Re.removeEventListener("click", this.He),
                this.Oe.removeEventListener("click", this.$e),
                this.container.removeEventListener("keydown", this.whenKeyPressed)
            }
            ,
            this.whenKeyPressed = t => {
                "BUTTON" != t.target.tagName && 13 == t.keyCode && this.He()
            }
            ,
            this.He = () => {
                for (var t = 1; t < this.Wa.length; t++)
                    this.Ga[t] = this.Wa[t].checked;
                this.m.prompt = null,
                this.m.record(new Ce(this.m,this.Ga))
            }
            ,
            this.Ga = t.song.scaleCustom.slice();
            let e = Oo({});
            for (var i = 1; i < p.pitchesPerOctave; i++)
                this.Wa[i] = $o({
                    type: "checkbox",
                    style: "width: 1em; padding: 0; margin-right: 4em;",
                    checked: this.Ga[i],
                    value: i
                }),
                this.ja[i] = Oo({
                    style: "text-align: right; height: 2em;"
                }, "Note " + i + ":", this.Wa[i]),
                e.appendChild(this.ja[i]);
            this.Re.addEventListener("click", this.He),
            this.Oe.addEventListener("click", this.$e),
            this.container = Oo({
                class: "prompt noSelection",
                style: "width: 250px;"
            }, Ro("Custom Scale"), Ho('Here, you can make your own scale to use in your song. Press the checkboxes below to toggle which notes of an octave are in the scale. For this to work, you\'ll need to have the "Custom" scale selected.'), Oo({
                style: "display: flex; flex-direction: row; align-items: center; justify-content: flex-end;"
            }, e), Oo({
                style: "display: flex; flex-direction: row-reverse; justify-content: space-between;"
            }, this.Re), this.Oe),
            this.container.addEventListener("keydown", this.whenKeyPressed)
        }
    }
    class Vo {
        constructor(t, e) {
            this.m = t,
            this.Ua = e,
            this.v = 20,
            this.Ka = 0,
            this.Ja = 1,
            this.Ya = 2,
            this.Qa = 3,
            this.Za = -1,
            this.Xa = -1,
            this.tr = Y.path({
                fill: "none",
                stroke: nt.loopAccent,
                "stroke-width": 4
            }),
            this.er = Y.path({
                fill: "none",
                stroke: nt.uiWidgetFocus,
                "stroke-width": 2
            }),
            this.wi = Y.path({
                fill: nt.hoverPreview,
                "pointer-events": "none"
            }),
            this.q = Y.svg({
                style: "touch-action: pan-y; position: absolute;",
                height: this.v
            }, this.tr, this.wi, this.er),
            this.container = J.div({
                class: "loopEditor"
            }, this.q),
            this.ir = 32,
            this.Fo = null,
            this.nr = {
                startBar: -1,
                mode: -1
            },
            this.N = 0,
            this.sr = 0,
            this.ar = 0,
            this.rr = !1,
            this.hr = !1,
            this.O = !1,
            this.R = !1,
            this.lr = -1,
            this.cr = -1,
            this.dr = 0,
            this.Ho = -1,
            this.pr = -1,
            this.mr = -1,
            this.W = t => {
                this.R || (this.R = !0,
                this.j())
            }
            ,
            this.U = t => {
                this.R && (this.R = !1,
                this.j())
            }
            ,
            this.K = t => {
                t.preventDefault(),
                this.O = !0;
                const e = this.q.getBoundingClientRect();
                this.N = (t.clientX || t.pageX) - e.left,
                this.ur(),
                this.j(),
                this.Z(t)
            }
            ,
            this.Y = t => {
                this.O = !0;
                const e = this.q.getBoundingClientRect();
                this.N = t.touches[0].clientX - e.left,
                this.ur(),
                this.j(),
                this.sr = t.touches[0].clientX,
                this.ar = t.touches[0].clientY,
                this.hr = !1,
                this.rr = !1
            }
            ,
            this.Z = t => {
                const e = this.q.getBoundingClientRect();
                this.N = (t.clientX || t.pageX) - e.left,
                this.X()
            }
            ,
            this.tt = t => {
                if (!this.O)
                    return;
                const e = this.q.getBoundingClientRect();
                this.N = t.touches[0].clientX - e.left,
                this.hr || this.rr || (Math.abs(t.touches[0].clientY - this.ar) > 10 ? this.rr = !0 : Math.abs(t.touches[0].clientX - this.sr) > 10 && (this.hr = !0)),
                this.hr && (this.X(),
                t.preventDefault())
            }
            ,
            this.yr = t => {
                t.preventDefault(),
                this.rr || (this.X(),
                this.R = !1,
                this.et(t),
                this.j()),
                this.O = !1
            }
            ,
            this.et = t => {
                null != this.Fo && this.m.record(this.Fo),
                this.Fo = null,
                this.O = !1,
                this.ur(),
                this.Rs()
            }
            ,
            this.gr = () => {
                this.Rs()
            }
            ,
            this.ur(),
            this.Rs(),
            this.m.notifier.watch(this.gr),
            this.container.addEventListener("mousedown", this.K),
            document.addEventListener("mousemove", this.Z),
            document.addEventListener("mouseup", this.et),
            this.container.addEventListener("mouseover", this.W),
            this.container.addEventListener("mouseout", this.U),
            this.container.addEventListener("touchstart", this.Y),
            this.container.addEventListener("touchmove", this.tt),
            this.container.addEventListener("touchend", this.yr),
            this.container.addEventListener("touchcancel", this.yr)
        }
        ur() {
            const t = this.N / this.ir;
            this.nr.startBar = t,
            t >= this.Za && t <= this.Xa + 1 ? this.nr.mode = this.Qa : t > this.m.song.loopStart - .25 && t < this.m.song.loopStart + this.m.song.loopLength + .25 ? t - this.m.song.loopStart < .5 * this.m.song.loopLength ? this.nr.mode = this.Ka : this.nr.mode = this.Ja : this.nr.mode = this.Ya
        }
        wr(t) {
            let e = Math.round(t - this.m.song.loopLength / 2)
              , i = e + this.m.song.loopLength;
            return e < 0 && (i -= e,
            e = 0),
            i > this.m.song.barCount && (e -= i - this.m.song.barCount,
            i = this.m.song.barCount),
            {
                start: e,
                length: i - e
            }
        }
        X() {
            if (this.O) {
                let t = this.m.song.loopStart
                  , e = this.m.song.loopStart + this.m.song.loopLength;
                null != this.Fo && this.m.lastChangeWas(this.Fo) && (t = this.Fo.oldStart,
                e = t + this.Fo.oldLength);
                const i = this.N / this.ir;
                let n, s, o;
                if (this.nr.mode == this.Ka)
                    n = t + Math.round(i - this.nr.startBar),
                    s = e,
                    n < 0 && (n = 0),
                    n >= this.m.song.barCount && (n = this.m.song.barCount),
                    n == s ? n = s - 1 : n > s && (o = n,
                    n = s,
                    s = o),
                    this.Fo = new qi(this.m,t,e - t,n,s - n);
                else if (this.nr.mode == this.Ja)
                    n = t,
                    s = e + Math.round(i - this.nr.startBar),
                    s < 0 && (s = 0),
                    s >= this.m.song.barCount && (s = this.m.song.barCount),
                    s == n ? s = n + 1 : s < n && (o = n,
                    n = s,
                    s = o),
                    this.Fo = new qi(this.m,t,e - t,n,s - n);
                else if (this.nr.mode == this.Ya) {
                    const n = this.wr(i);
                    this.Fo = new qi(this.m,t,e - t,n.start,n.length)
                } else
                    this.nr.mode == this.Qa && (this.m.synth.loopBarStart = -1,
                    this.m.synth.loopBarEnd = -1,
                    this.setLoopAt(this.m.synth.loopBarStart, this.m.synth.loopBarEnd));
                this.m.synth.jumpIntoLoop(),
                this.m.prefs.autoFollow && new Pe(this.m,this.m.channel,Math.floor(this.m.synth.playhead),!0),
                this.m.setProspectiveChange(this.Fo)
            } else
                this.ur(),
                this.j()
        }
        j() {
            const t = this.R && !this.O;
            if (this.wi.style.visibility = t ? "visible" : "hidden",
            t) {
                const t = this.v / 2;
                let e = this.m.song.loopStart * this.ir
                  , i = (this.m.song.loopStart + this.m.song.loopLength) * this.ir;
                if (this.nr.mode == this.Ka)
                    i = this.m.song.loopStart * this.ir + 2 * t;
                else if (this.nr.mode == this.Ja)
                    e = (this.m.song.loopStart + this.m.song.loopLength) * this.ir - 2 * t;
                else if (this.nr.mode == this.Ya) {
                    const t = this.wr(this.nr.startBar);
                    e = t.start * this.ir,
                    i = (t.start + t.length) * this.ir
                }
                if (this.nr.mode == this.Qa) {
                    const e = (this.Za + .5) * this.ir
                      , i = (this.Xa + .5) * this.ir;
                    this.wi.setAttribute("d", `M ${e} ${1.7 * t} L ${e - 1.5 * t} ${t}L ${e} ${.3 * t}L ${i} ${.3 * t}L ${i + 1.5 * t} ${t}L ${i} ${1.7 * t}z`)
                } else
                    this.wi.setAttribute("d", `M ${e + t} 4 L ${i - t} 4 A ${t - 4} ${t - 4} 0 0 1 ${i - t} ${this.v - 4} L ${e + t} ${this.v - 4} A ${t - 4} ${t - 4} 0 0 1 ${e + t} 4 z`)
            }
        }
        setLoopAt(t, e) {
            this.Za = t,
            this.Xa = e,
            this.Ua.render(),
            this.Rs()
        }
        Rs() {
            this.ir = this.m.getBarWidth();
            const t = this.v / 2
              , e = this.m.song.loopStart * this.ir
              , i = (this.m.song.loopStart + this.m.song.loopLength) * this.ir;
            if (this.dr != this.m.song.barCount || this.Ho != this.ir) {
                this.dr = this.m.song.barCount,
                this.Ho = this.ir;
                const t = this.ir * this.m.song.barCount;
                this.container.style.width = t + "px",
                this.q.setAttribute("width", t + "")
            }
            this.lr == e && this.cr == i || (this.lr = e,
            this.cr = i,
            this.tr.setAttribute("d", `M ${e + t} 2 L ${i - t} 2 A ${t - 2} ${t - 2} 0 0 1 ${i - t} ${this.v - 2} L ${e + t} ${this.v - 2} A ${t - 2} ${t - 2} 0 0 1 ${e + t} 2 z`));
            const n = (this.Za + .5) * this.ir
              , s = (this.Xa + .5) * this.ir;
            this.pr == n && this.mr == s || (n < 0 || s < 0 ? this.er.setAttribute("d", "") : this.er.setAttribute("d", `M ${n} ${1.5 * t} L ${n - t} ${t}L ${n} ${.5 * t}L ${s} ${.5 * t}L ${s + t} ${t}L ${s} ${1.5 * t}z`),
            this.pr = n,
            this.mr = s),
            this.j()
        }
    }
    const {button: Go, div: Wo, span: jo, h2: Uo, input: Ko, br: Jo, select: Yo, option: Qo} = J;
    class Zo {
        constructor(t) {
            this.m = t,
            this.qe = Ko({
                style: "width: 3em; margin-left: 1em;",
                type: "number",
                step: "0.01",
                value: "0"
            }),
            this.Ne = Yo({
                style: "width: 100%;"
            }, Qo({
                value: "overflow"
            }, "Overflow notes across bars."), Qo({
                value: "wrapAround"
            }, "Wrap notes around within bars.")),
            this.Oe = Go({
                class: "cancelButton"
            }),
            this.Re = Go({
                class: "okayButton",
                style: "width:45%;"
            }, "Okay"),
            this.container = Wo({
                class: "prompt noSelection",
                style: "width: 250px;"
            }, Uo("Move Notes Sideways"), Wo({
                style: "display: flex; flex-direction: row; align-items: center; height: 2em; justify-content: flex-end;"
            }, Wo({
                style: "text-align: right;"
            }, "Beats to move:", Jo(), jo({
                style: `font-size: smaller; color: ${nt.secondaryText};`
            }, "(Negative is left, positive is right)")), this.qe), Wo({
                style: "display: flex; flex-direction: row; align-items: center; height: 2em; justify-content: flex-end;"
            }, Wo({
                class: "selectContainer",
                style: "width: 100%;"
            }, this.Ne)), Wo({
                style: "display: flex; flex-direction: row-reverse; justify-content: space-between;"
            }, this.Re), this.Oe),
            this.$e = () => {
                this.m.undo()
            }
            ,
            this.cleanUp = () => {
                this.Re.removeEventListener("click", this.He),
                this.Oe.removeEventListener("click", this.$e),
                this.qe.removeEventListener("blur", Zo.Ve),
                this.container.removeEventListener("keydown", this.Ge)
            }
            ,
            this.Ge = t => {
                "BUTTON" != t.target.tagName && 13 == t.keyCode && this.He()
            }
            ,
            this.He = () => {
                window.localStorage.setItem("moveNotesSidewaysStrategy", this.Ne.value),
                this.m.prompt = null,
                this.m.record(new tn(this.m,+this.qe.value,this.Ne.value), !0)
            }
            ,
            this.qe.min = -this.m.song.beatsPerBar + "",
            this.qe.max = this.m.song.beatsPerBar + "";
            const e = window.localStorage.getItem("moveNotesSidewaysStrategy");
            null != e && (this.Ne.value = e),
            this.qe.select(),
            setTimeout(( () => this.qe.focus()), 100),
            this.Re.addEventListener("click", this.He),
            this.Oe.addEventListener("click", this.$e),
            this.qe.addEventListener("blur", Zo.Ve),
            this.container.addEventListener("keydown", this.Ge)
        }
        static Ve(t) {
            const e = t.target;
            let i = +e.value;
            i = Math.round(i * p.partsPerBeat) / p.partsPerBeat,
            i = Math.round(100 * i) / 100,
            e.value = Math.max(+e.min, Math.min(+e.max, i)) + ""
        }
    }
    class Xo {
        constructor(t, e) {
            this.m = t,
            this.vr = e,
            this.kr = J.div({
                style: `background: ${nt.editorBackground}; position: sticky; bottom: 0; left: 0; width: 32px; height: 30px;`
            }),
            this.Mr = [],
            this.Sr = [],
            this.Fr = J.div({
                style: `background-color: ${nt.uiWidgetFocus}; white-space:nowrap; display: none; transform:translate(20px); width: auto; pointer-events: none; position: absolute; border-radius: 0.2em; z-index: 2;`,
                color: nt.primaryText
            }, ""),
            this.Cr = new ho(J.input({
                style: `color: ${nt.primaryText}; background-color: ${nt.uiWidgetFocus}; margin-top: -2px; display: none; width: 6em; position: absolute; border-radius: 0.2em; z-index: 2;`,
                color: nt.primaryText
            }, ""),this.m,( (t, e) => new In(this.m,t,e))),
            this.Ar = J.select({
                style: "width: 0px; left: 19px; height: 19px; position:absolute; opacity:0"
            }, J.option({
                value: "rename"
            }, "Rename..."), J.option({
                value: "chnUp"
            }, "Move Channel Up"), J.option({
                value: "chnDown"
            }, "Move Channel Down"), J.option({
                value: "chnMute"
            }, "Mute Channel"), J.option({
                value: "chnSolo"
            }, "Solo Channel"), J.option({
                value: "chnInsert"
            }, "Insert Channel Below"), J.option({
                value: "chnDelete"
            }, "Delete This Channel")),
            this.container = J.div({
                class: "muteEditor",
                style: "position: sticky; padding-top: " + p.barEditorHeight + "px;"
            }, this.Fr, this.Cr.input, this.Ar),
            this.v = 128,
            this.Er = 0,
            this.Tr = 0,
            this.Pr = -1,
            this.Br = 0,
            this.Ir = 0,
            this.Lr = !1,
            this.Dr = !1,
            this.zr = () => {
                let t = this.Cr.input.value;
                t.length > 15 && (this.Cr.input.value = t.substring(0, 15))
            }
            ,
            this.qr = t => {
                t.stopPropagation()
            }
            ,
            this.Nr = () => {
                this.Cr.input.style.setProperty("display", "none"),
                this.Fr.style.setProperty("display", "none")
            }
            ,
            this.Or = t => {
                this.Lr = !this.Dr,
                this.Rr(t)
            }
            ,
            this.$r = () => {
                this.Lr = !1,
                this.Fr.style.setProperty("display", "none")
            }
            ,
            this.Rr = t => {
                this.Dr = this.Lr,
                this.Ir = Math.floor(Math.min(this.Mr.length, Math.max(0, parseInt(this.Ar.style.getPropertyValue("top")) / xo.patternHeight))),
                this.m.muteEditorChannel = this.Ir,
                this.Fr.style.setProperty("display", ""),
                this.Ir < this.m.song.pitchChannelCount && this.m.song.pitchChannelCount == p.pitchChannelCountMax || this.Ir >= this.m.song.pitchChannelCount && this.Ir < this.m.song.pitchChannelCount + this.m.song.noiseChannelCount && this.m.song.noiseChannelCount == p.noiseChannelCountMax || this.Ir >= this.m.song.pitchChannelCount + this.m.song.noiseChannelCount && this.m.song.modChannelCount == p.modChannelCountMax ? this.Ar.options[5].disabled = !0 : this.Ar.options[5].disabled = !1,
                0 == this.Ir || this.Ir == this.m.song.pitchChannelCount || this.Ir == this.m.song.pitchChannelCount + this.m.song.noiseChannelCount ? this.Ar.options[1].disabled = !0 : this.Ar.options[1].disabled = !1,
                this.Ir == this.m.song.pitchChannelCount - 1 || this.Ir == this.m.song.pitchChannelCount + this.m.song.noiseChannelCount - 1 || this.Ir == this.m.song.getChannelCount() - 1 ? this.Ar.options[2].disabled = !0 : this.Ar.options[2].disabled = !1,
                1 == this.m.song.pitchChannelCount && 0 == this.Ir ? this.Ar.options[6].disabled = !0 : this.Ar.options[6].disabled = !1
            }
            ,
            this.Hr = t => {
                switch (this.Fr.style.setProperty("display", "none"),
                this.Ar.style.setProperty("display", "none"),
                this.Lr = !1,
                t.stopPropagation(),
                this.Ar.value) {
                case "rename":
                    this.Cr.input.style.setProperty("display", ""),
                    this.Cr.input.style.setProperty("transform", this.Fr.style.getPropertyValue("transform")),
                    null != this.Fr.textContent ? this.Cr.input.value = this.Fr.textContent : this.Cr.input.value = "",
                    this.Cr.input.select();
                    break;
                case "chnUp":
                    this.m.record(new Fe(this.m,this.Ir,this.Ir,-1));
                    break;
                case "chnDown":
                    this.m.record(new Fe(this.m,this.Ir,this.Ir,1));
                    break;
                case "chnMute":
                    this.m.song.channels[this.Ir].muted = !this.m.song.channels[this.Ir].muted,
                    this.render();
                    break;
                case "chnSolo":
                    {
                        let t = !1;
                        for (let e = 0; e < this.m.song.pitchChannelCount + this.m.song.noiseChannelCount; e++)
                            this.m.song.channels[e].muted == (e == this.Ir) && (t = !0,
                            e = this.m.song.pitchChannelCount + this.m.song.noiseChannelCount);
                        if (t)
                            for (let t = 0; t < this.m.song.pitchChannelCount + this.m.song.noiseChannelCount; t++)
                                this.m.song.channels[t].muted = t != this.Ir;
                        else
                            for (let t = 0; t < this.m.song.pitchChannelCount + this.m.song.noiseChannelCount; t++)
                                this.m.song.channels[t].muted = !1;
                        this.render();
                        break
                    }
                case "chnInsert":
                    this.m.channel = this.Ir,
                    this.m.selection.resetBoxSelection(),
                    this.m.selection.insertChannel();
                    break;
                case "chnDelete":
                    this.m.record(new Te(this.m,this.Ir,this.Ir))
                }
                "rename" != this.Ar.value && this.vr.refocusStage(),
                this.Ar.selectedIndex = -1
            }
            ,
            this.ea = t => {
                const e = this.Mr.indexOf(t.target);
                if (-1 == e)
                    return;
                t.clientX - this.Mr[0].getBoundingClientRect().left < 21 && (this.m.song.channels[e].muted = !this.m.song.channels[e].muted),
                this.m.notifier.changed()
            }
            ,
            this._r = t => {
                const e = this.Mr.indexOf(t.target);
                if (-1 == e)
                    return void (this.Lr || t.target == this.Fr || t.target == this.Ar || (this.Fr.style.setProperty("display", "none"),
                    this.Ar.style.setProperty("display", "none"),
                    this.Ar.style.setProperty("width", "0px")));
                if (this.Lr && "none" == this.Fr.style.getPropertyValue("display") && "none" == this.Cr.input.style.getPropertyValue("display") && (this.Lr = !1),
                t.clientX - this.Mr[0].getBoundingClientRect().left >= 21) {
                    if (!this.Lr) {
                        this.Ar.style.setProperty("display", "");
                        var i = xo.patternHeight;
                        this.Fr.style.setProperty("transform", "translate(20px, " + (i / 4 + i * e) + "px)"),
                        "" != this.m.song.channels[e].name ? (this.Fr.textContent = this.m.song.channels[e].name,
                        this.Fr.style.setProperty("display", "")) : (e < this.m.song.pitchChannelCount ? this.Fr.textContent = "Pitch " + (e + 1) : e < this.m.song.pitchChannelCount + this.m.song.noiseChannelCount ? this.Fr.textContent = "Noise " + (e - this.m.song.pitchChannelCount + 1) : this.Fr.textContent = "Mod " + (e - this.m.song.pitchChannelCount - this.m.song.noiseChannelCount + 1),
                        this.Fr.style.setProperty("display", "none")),
                        this.Ar.style.top = p.barEditorHeight + 2 + e * xo.patternHeight + "px",
                        this.Ar.style.setProperty("width", "15px")
                    }
                } else
                    this.Lr || (this.Fr.style.setProperty("display", "none"),
                    this.Ar.style.setProperty("display", "none"),
                    this.Ar.style.setProperty("width", "0px"))
            }
            ,
            this.Vr = t => {
                this.Lr || (this.Fr.style.setProperty("display", "none"),
                this.Ar.style.setProperty("width", "0px"))
            }
            ,
            this.container.addEventListener("click", this.ea),
            this.container.addEventListener("mousemove", this._r),
            this.container.addEventListener("mouseleave", this.Vr),
            this.Ar.selectedIndex = -1,
            this.Ar.addEventListener("change", this.Hr),
            this.Ar.addEventListener("mousedown", this.Rr),
            this.Ar.addEventListener("blur", this.$r),
            this.Ar.addEventListener("click", this.Or),
            this.Cr.input.addEventListener("change", this.Nr),
            this.Cr.input.addEventListener("blur", this.Nr),
            this.Cr.input.addEventListener("mousedown", this.qr),
            this.Cr.input.addEventListener("input", this.zr)
        }
        onKeyUp(t) {
            switch (t.keyCode) {
            case 27:
            case 13:
                this.Lr = !1,
                this.Fr.style.setProperty("display", "none")
            }
        }
        render() {
            if (!this.m.prefs.enableChannelMuting)
                return;
            let t = this.Mr.length;
            if (this.Mr.length != this.m.song.getChannelCount()) {
                for (let t = this.Mr.length; t < this.m.song.getChannelCount(); t++) {
                    const e = J.div({
                        class: "noSelection muteButtonText",
                        style: "display: table-cell; -webkit-text-stroke: 1.5px; vertical-align: middle; text-align: center; -webkit-user-select: none; -webkit-touch-callout: none; -moz-user-select: none; -ms-user-select: none; user-select: none; pointer-events: none; width: 12px; height: 20px; transform: translate(0px, 1px);"
                    })
                      , i = J.div({
                        class: "mute-button",
                        title: "Mute (M), Mute All (⇧M), Solo (S), Exclude (⇧S)",
                        style: "display: block; pointer-events: none; width: 16px; height: 20px; transform: translate(2px, 1px);"
                    })
                      , n = J.div({
                        style: "align-items: center; height: 20px; margin: 0px; display: table; flex-direction: row; justify-content: space-between;"
                    }, [i, e]);
                    this.container.appendChild(n),
                    this.Mr[t] = n,
                    this.Sr[t] = e
                }
                for (let t = this.m.song.getChannelCount(); t < this.Mr.length; t++)
                    this.container.removeChild(this.Mr[t]);
                this.Mr.length = this.m.song.getChannelCount(),
                this.container.appendChild(this.kr)
            }
            for (let t = 0; t < this.m.song.getChannelCount(); t++)
                this.m.song.channels[t].muted ? (this.Mr[t].children[0].classList.add("muted"),
                t < this.m.song.pitchChannelCount ? this.Sr[t].style.color = nt.trackEditorBgPitchDim : t < this.m.song.pitchChannelCount + this.m.song.noiseChannelCount ? this.Sr[t].style.color = nt.trackEditorBgNoiseDim : this.Sr[t].style.color = nt.trackEditorBgModDim) : (this.Mr[t].children[0].classList.remove("muted"),
                t < this.m.song.pitchChannelCount ? this.Sr[t].style.color = nt.trackEditorBgPitch : t < this.m.song.pitchChannelCount + this.m.song.noiseChannelCount ? this.Sr[t].style.color = nt.trackEditorBgNoise : this.Sr[t].style.color = nt.trackEditorBgMod);
            if (this.Pr != xo.patternHeight || t != this.Mr.length)
                for (let t = 0; t < this.m.song.getChannelCount(); t++)
                    this.Mr[t].style.marginTop = (xo.patternHeight - 20) / 2 + "px",
                    this.Mr[t].style.marginBottom = (xo.patternHeight - 20) / 2 + "px";
            if (this.Br != this.m.song.modChannelCount || t != this.Mr.length)
                for (let t = 0; t < this.m.song.getChannelCount(); t++)
                    t < this.m.song.pitchChannelCount + this.m.song.noiseChannelCount ? this.Mr[t].children[0].classList.remove("modMute") : this.Mr[t].children[0].classList.add("modMute");
            if (this.Br != this.m.song.modChannelCount || this.Er != this.m.song.pitchChannelCount || this.Tr != this.m.song.noiseChannelCount) {
                for (let t = 0; t < this.m.song.getChannelCount(); t++)
                    if (t < this.m.song.pitchChannelCount) {
                        let e = t + 1;
                        this.Sr[t].textContent = e + "",
                        this.Sr[t].style.fontSize = e >= 10 ? "xx-small" : "inherit"
                    } else if (t < this.m.song.pitchChannelCount + this.m.song.noiseChannelCount) {
                        let e = t - this.m.song.pitchChannelCount + 1;
                        this.Sr[t].textContent = e + "",
                        this.Sr[t].style.fontSize = e >= 10 ? "xx-small" : "inherit"
                    } else {
                        let e = t - this.m.song.pitchChannelCount - this.m.song.noiseChannelCount + 1;
                        this.Sr[t].textContent = e + "",
                        this.Sr[t].style.fontSize = e >= 10 ? "xx-small" : "inherit"
                    }
                this.Er = this.m.song.pitchChannelCount,
                this.Tr = this.m.song.noiseChannelCount,
                this.Br = this.m.song.modChannelCount
            }
            t == this.Mr.length && this.Pr == xo.patternHeight || (this.Pr = xo.patternHeight,
            this.v = p.barEditorHeight + this.m.song.getChannelCount() * xo.patternHeight,
            this.Fr.style.setProperty("display", "none"),
            this.container.style.height = this.v + 16 + "px",
            xo.patternHeight < 27 ? (this.Fr.style.setProperty("margin-top", "-2px"),
            this.Ar.style.setProperty("margin-top", "-4px"),
            this.Cr.input.style.setProperty("margin-top", "-4px")) : xo.patternHeight < 30 ? (this.Fr.style.setProperty("margin-top", "-1px"),
            this.Ar.style.setProperty("margin-top", "-3px"),
            this.Cr.input.style.setProperty("margin-top", "-3px")) : (this.Fr.style.setProperty("margin-top", "0px"),
            this.Ar.style.setProperty("margin-top", "0px"),
            this.Cr.input.style.setProperty("margin-top", "-2px")))
        }
    }
    class ta {
        constructor(t, e) {
            this.m = t,
            this.Gr = e,
            this.u = 20,
            this.v = 481,
            this.Wr = 4,
            this.jr = p.pitchOctaves,
            this.Ur = (this.v - this.Wr) / this.jr,
            this.S = Y.rect({
                fill: nt.uiWidgetBackground,
                x: 2,
                y: 0,
                width: this.u - 4
            }),
            this.T = Y.rect({
                fill: "none",
                stroke: nt.hoverPreview,
                "stroke-width": 2,
                "pointer-events": "none",
                x: 1,
                y: 0,
                width: this.u - 2
            }),
            this.Kr = Y.path({
                fill: nt.hoverPreview,
                "pointer-events": "none"
            }),
            this.Jr = Y.path({
                fill: nt.hoverPreview,
                "pointer-events": "none"
            }),
            this.q = Y.svg({
                style: "background-color: ${ColorConfig.editorBackground}; touch-action: pan-x; position: absolute;",
                width: this.u,
                height: "100%",
                viewBox: "0 0 20 " + this.v,
                preserveAspectRatio: "none"
            }),
            this.container = J.div({
                id: "octaveScrollBarContainer",
                style: "width: 20px; height: 100%; overflow: hidden; position: relative; flex-shrink: 0;"
            }, this.q),
            this.Ze = 0,
            this.O = !1,
            this.R = !1,
            this.$ = !1,
            this.Yr = -1,
            this.Qr = -1,
            this.Fo = null,
            this.W = t => {
                this.R || (this.R = !0,
                this.j())
            }
            ,
            this.U = t => {
                this.R && (this.R = !1,
                this.j())
            }
            ,
            this.K = t => {
                t.preventDefault(),
                this.O = !0;
                const e = this.q.getBoundingClientRect();
                this.Ze = ((t.clientY || t.pageY) - e.top) * this.v / (e.bottom - e.top),
                isNaN(this.Ze) && (this.Ze = 0),
                this.m.song.getChannelIsNoise(this.m.channel) || this.m.song.getChannelIsMod(this.m.channel) || (this.j(),
                this.Ze >= this.Zr - this.Xr && this.Ze <= this.Zr && (this.$ = !0,
                this.Fo = null,
                this.J = this.Ze))
            }
            ,
            this.Y = t => {
                t.preventDefault(),
                this.O = !0;
                const e = this.q.getBoundingClientRect();
                this.Ze = (t.touches[0].clientY - e.top) * this.v / (e.bottom - e.top),
                isNaN(this.Ze) && (this.Ze = 0),
                this.m.song.getChannelIsNoise(this.m.channel) || this.m.song.getChannelIsMod(this.m.channel) || (this.j(),
                this.Ze >= this.Zr - this.Xr && this.Ze <= this.Zr && (this.$ = !0,
                this.Fo = null,
                this.J = this.Ze))
            }
            ,
            this.Z = t => {
                const e = this.q.getBoundingClientRect();
                this.Ze = ((t.clientY || t.pageY) - e.top) * this.v / (e.bottom - e.top),
                isNaN(this.Ze) && (this.Ze = 0),
                this.X()
            }
            ,
            this.tt = t => {
                if (!this.O)
                    return;
                t.preventDefault();
                const e = this.q.getBoundingClientRect();
                this.Ze = (t.touches[0].clientY - e.top) * this.v / (e.bottom - e.top),
                isNaN(this.Ze) && (this.Ze = 0),
                this.X()
            }
            ,
            this.et = t => {
                if (!this.m.song.getChannelIsNoise(this.m.channel) && !this.m.song.getChannelIsMod(this.m.channel) && this.O)
                    if (this.$)
                        null != this.Fo && this.m.record(this.Fo);
                    else {
                        const t = this.m.getVisibleOctaveCount()
                          , e = p.pitchOctaves - t
                          , i = this.m.lastChangeWas(this.Fo)
                          , n = i ? this.Fo.oldValue : this.m.song.channels[this.m.channel].octave
                          , s = this.m.getBaseVisibleOctave(this.m.channel);
                        this.Ze < this.Zr - .5 * this.Xr ? s < e && (this.Fo = new Oi(this.m,n,Math.floor(s + 1 + .5 * t)),
                        this.m.record(this.Fo, i)) : s > 0 && (this.Fo = new Oi(this.m,n,Math.floor(s - 1 + .5 * t)),
                        this.m.record(this.Fo, i))
                    }
                this.O = !1,
                this.$ = !1,
                this.j()
            }
            ,
            this.gr = () => {
                this.Zr = this.v - this.Ur * this.m.getBaseVisibleOctave(this.m.channel),
                this.q.style.visibility = this.m.song.getChannelIsNoise(this.m.channel) || this.m.song.getChannelIsMod(this.m.channel) ? "hidden" : "visible";
                const t = this.m.getVisibleOctaveCount();
                this.Yr == this.Zr && this.Qr == t || (this.Yr = this.Zr,
                this.Qr = t,
                this.Xr = this.Ur * t + this.Wr,
                this.S.setAttribute("height", String(this.Xr)),
                this.T.setAttribute("height", String(this.Xr)),
                this.S.setAttribute("y", String(this.Zr - this.Xr)),
                this.T.setAttribute("y", String(this.Zr - this.Xr)),
                this.Gr.forceRender()),
                this.j()
            }
            ,
            this.m.notifier.watch(this.gr),
            this.gr(),
            this.q.appendChild(this.S);
            for (let t = 0; t <= this.jr; t++)
                this.q.appendChild(Y.rect({
                    fill: nt.tonic,
                    x: 0,
                    y: t * this.Ur,
                    width: this.u,
                    height: this.Wr
                }));
            this.q.appendChild(this.T),
            this.q.appendChild(this.Kr),
            this.q.appendChild(this.Jr);
            const i = .5 * this.u;
            this.Kr.setAttribute("d", `M ${i} 9 L ${i + 6} 20 L ${i - 6} 20 z`),
            this.Jr.setAttribute("d", `M ${i} ${this.v - 9} L ${i + 6} ${this.v - 20} L ${i - 6} ${this.v - 20} z`),
            this.container.addEventListener("mousedown", this.K),
            document.addEventListener("mousemove", this.Z),
            document.addEventListener("mouseup", this.et),
            this.container.addEventListener("mouseover", this.W),
            this.container.addEventListener("mouseout", this.U),
            this.container.addEventListener("touchstart", this.Y),
            this.container.addEventListener("touchmove", this.tt),
            this.container.addEventListener("touchend", this.et),
            this.container.addEventListener("touchcancel", this.et)
        }
        X() {
            if (!this.m.song.getChannelIsNoise(this.m.channel) && !this.m.song.getChannelIsMod(this.m.channel)) {
                if (this.$) {
                    const t = this.m.getVisibleOctaveCount()
                      , e = p.pitchOctaves - t
                      , i = this.m.lastChangeWas(this.Fo) ? this.Fo.oldValue : this.m.song.channels[this.m.channel].octave;
                    let n = this.m.getBaseVisibleOctave(this.m.channel);
                    for (; this.Ze - this.J < .5 * -this.Ur && n < e; )
                        n++,
                        this.J -= this.Ur;
                    for (; this.Ze - this.J > .5 * this.Ur && n > 0; )
                        n--,
                        this.J += this.Ur;
                    this.Fo = new Oi(this.m,i,Math.floor(n + .5 * t)),
                    this.m.setProspectiveChange(this.Fo)
                }
                this.R && this.j()
            }
        }
        j() {
            let t = !1
              , e = !1
              , i = !1;
            this.R && !this.O && (this.Ze < this.Zr - this.Xr ? t = !0 : this.Ze > this.Zr ? e = !0 : i = !0),
            this.Kr.style.visibility = t ? "inherit" : "hidden",
            this.Jr.style.visibility = e ? "inherit" : "hidden",
            this.T.style.visibility = i ? "inherit" : "hidden"
        }
    }
    var ea = t && t.t || function(t, e, i, n) {
        return new (i || (i = Promise))((function(s, o) {
            function a(t) {
                try {
                    h(n.next(t))
                } catch (t) {
                    o(t)
                }
            }
            function r(t) {
                try {
                    h(n.throw(t))
                } catch (t) {
                    o(t)
                }
            }
            function h(t) {
                var e;
                t.done ? s(t.value) : (e = t.value,
                e instanceof i ? e : new i((function(t) {
                    t(e)
                }
                ))).then(a, r)
            }
            h((n = n.apply(t, e || [])).next())
        }
        ))
    }
    ;
    const ia = (4294967295 * Math.random() >>> 0).toString(16);
    class na {
        constructor(t) {
            this.m = t,
            this.th = t => {
                localStorage.setItem("midiHandlerId", ia)
            }
            ,
            this.eh = t => {
                if ("input" === t.port.type)
                    switch (t.port.state) {
                    case "connected":
                        this.ih(t.port);
                        break;
                    case "disconnected":
                        this.nh(t.port)
                    }
            }
            ,
            this.ih = t => {
                t.addEventListener("midimessage", this.sh)
            }
            ,
            this.nh = t => {
                t.removeEventListener("midimessage", this.sh),
                this.m.performance.clearAllPitches()
            }
            ,
            this.sh = t => {
                if (!this.m.prefs.enableMidi || localStorage.getItem("midiHandlerId") != ia)
                    return;
                const e = this.m.song.getChannelIsNoise(this.m.channel);
                let[i,n,s] = t.data;
                if (i &= 240,
                e) {
                    const t = Us[n];
                    if (null == t)
                        return;
                    n = t.frequency
                } else if (n -= p.keys[this.m.song.key].basePitch,
                n < 0 || n > p.maxPitch)
                    return;
                switch (144 == i && 0 == s && (i = 128),
                i) {
                case 144:
                    this.m.synth.preferLowerLatency = !0,
                    this.m.performance.addPerformedPitch(n);
                    break;
                case 128:
                    this.m.performance.removePerformedPitch(n)
                }
            }
            ,
            this.registerMidiAccessHandler()
        }
        registerMidiAccessHandler() {
            return ea(this, void 0, void 0, (function*() {
                if (null != navigator.requestMIDIAccess)
                    try {
                        const t = yield navigator.requestMIDIAccess();
                        t.inputs.forEach(this.ih),
                        t.addEventListener("statechange", this.eh),
                        this.th(),
                        window.addEventListener("focus", this.th)
                    } catch (t) {
                        console.error("Failed to get MIDI access", t)
                    }
            }
            ))
        }
    }
    class sa {
        static keyPosToPitch(t, e, i, n) {
            let s = null
              , o = null;
            switch (n) {
            case "wickiHayden":
                s = 5 * i + 2 * e - 2;
                break;
            case "songScale":
                const n = p.scales[t.song.scale].flags.map(( (t, e) => t ? e : null)).filter((t => null != t));
                s = (i - 1 + Math.floor(e / n.length)) * p.pitchesPerOctave + n[(e + n.length) % n.length];
                break;
            case "pianoAtC":
                s = sa.oh[i][e],
                o = p.keys.dictionary.C.basePitch;
                break;
            case "pianoAtA":
                s = sa.ah[i][e],
                o = p.keys.dictionary.A.basePitch;
                break;
            case "pianoTransposingC":
                s = sa.oh[i][e];
                break;
            case "pianoTransposingA":
                s = sa.ah[i][e]
            }
            if (null == s)
                return null;
            const a = Math.max(0, t.song.channels[t.channel].octave - 1) * p.pitchesPerOctave;
            let r = 0;
            if (null != o) {
                r = (o - p.keys[t.song.key].basePitch + 144) % 12
            }
            const h = a + r + s;
            return h < 0 || h > p.maxPitch ? null : h
        }
        constructor(t) {
            this.m = t,
            this.rh = !1,
            this.hh = t => {
                this.rh && (this.m.performance.clearAllPitches(),
                this.rh = !1)
            }
            ,
            window.addEventListener("blur", this.hh)
        }
        handleKeyEvent(t, e) {
            switch (t.code) {
            case "Backquote":
                this.handleKey(-1, 3, e);
                break;
            case "Digit1":
                this.handleKey(0, 3, e);
                break;
            case "Digit2":
                this.handleKey(1, 3, e);
                break;
            case "Digit3":
                this.handleKey(2, 3, e);
                break;
            case "Digit4":
                this.handleKey(3, 3, e);
                break;
            case "Digit5":
                this.handleKey(4, 3, e);
                break;
            case "Digit6":
                this.handleKey(5, 3, e);
                break;
            case "Digit7":
                this.handleKey(6, 3, e);
                break;
            case "Digit8":
                this.handleKey(7, 3, e);
                break;
            case "Digit9":
                this.handleKey(8, 3, e);
                break;
            case "Digit0":
                this.handleKey(9, 3, e);
                break;
            case "Minus":
                this.handleKey(10, 3, e);
                break;
            case "Equal":
                this.handleKey(11, 3, e);
                break;
            case "IntlYen":
                this.handleKey(12, 3, e);
                break;
            case "KeyQ":
                this.handleKey(0, 2, e);
                break;
            case "KeyW":
                this.handleKey(1, 2, e);
                break;
            case "KeyE":
                this.handleKey(2, 2, e);
                break;
            case "KeyR":
                this.handleKey(3, 2, e);
                break;
            case "KeyT":
                this.handleKey(4, 2, e);
                break;
            case "KeyY":
                this.handleKey(5, 2, e);
                break;
            case "KeyU":
                this.handleKey(6, 2, e);
                break;
            case "KeyI":
                this.handleKey(7, 2, e);
                break;
            case "KeyO":
                this.handleKey(8, 2, e);
                break;
            case "KeyP":
                this.handleKey(9, 2, e);
                break;
            case "BracketLeft":
                this.handleKey(10, 2, e);
                break;
            case "BracketRight":
                this.handleKey(11, 2, e);
                break;
            case "Backslash":
                "\\" == t.key || "|" == t.key ? this.handleKey(12, 2, e) : this.handleKey(11, 1, e);
                break;
            case "KeyA":
                this.handleKey(0, 1, e);
                break;
            case "KeyS":
                this.handleKey(1, 1, e);
                break;
            case "KeyD":
                this.handleKey(2, 1, e);
                break;
            case "KeyF":
                this.handleKey(3, 1, e);
                break;
            case "KeyG":
                this.handleKey(4, 1, e);
                break;
            case "KeyH":
                this.handleKey(5, 1, e);
                break;
            case "KeyJ":
                this.handleKey(6, 1, e);
                break;
            case "KeyK":
                this.handleKey(7, 1, e);
                break;
            case "KeyL":
                this.handleKey(8, 1, e);
                break;
            case "Semicolon":
                this.handleKey(9, 1, e);
                break;
            case "Quote":
                this.handleKey(10, 1, e);
                break;
            case "IntlHash":
                this.handleKey(11, 1, e);
                break;
            case "IntlBackslash":
                this.handleKey(-1, 0, e);
                break;
            case "KeyZ":
                this.handleKey(0, 0, e);
                break;
            case "KeyX":
                this.handleKey(1, 0, e);
                break;
            case "KeyC":
                this.handleKey(2, 0, e);
                break;
            case "KeyV":
                this.handleKey(3, 0, e);
                break;
            case "KeyB":
                this.handleKey(4, 0, e);
                break;
            case "KeyN":
                this.handleKey(5, 0, e);
                break;
            case "KeyM":
                this.handleKey(6, 0, e);
                break;
            case "Comma":
                this.handleKey(7, 0, e);
                break;
            case "Period":
                this.handleKey(8, 0, e);
                break;
            case "Slash":
                this.handleKey(9, 0, e);
                break;
            case "IntlRo":
                this.handleKey(10, 0, e);
                break;
            default:
                return
            }
            t.preventDefault()
        }
        handleKey(t, e, i) {
            if (this.m.song.getChannelIsNoise(this.m.channel))
                return void (t >= 0 && t < p.drumCount && (i ? (this.m.synth.preferLowerLatency = !0,
                this.m.performance.addPerformedPitch(t),
                this.rh = !0) : this.m.performance.removePerformedPitch(t)));
            const n = sa.keyPosToPitch(this.m, t, e, this.m.prefs.keyboardLayout);
            null != n && (i ? (this.m.synth.preferLowerLatency = !0,
            this.m.performance.addPerformedPitch(n),
            this.rh = !0) : this.m.performance.removePerformedPitch(n))
        }
    }
    sa.oh = [[0, 2, 4, 5, 7, 9, 11, 12, 14, 16, 17], [null, 1, 3, null, 6, 8, 10, null, 13, 15, null, 18], [12, 14, 16, 17, 19, 21, 23, 24, 26, 28, 29, 31, 33], [null, 13, 15, null, 18, 20, 22, null, 25, 27, null, 30, 32]],
    sa.ah = [[0, 2, 3, 5, 7, 8, 10, 12, 14, 15, 17], [-1, 1, null, 4, 6, null, 9, 11, 13, null, 16, 18], [12, 14, 15, 17, 19, 20, 22, 24, 26, 27, 29, 31, 32], [11, 13, null, 16, 18, null, 21, 23, 25, null, 28, 30, null]];
    class oa {
        constructor() {
            this.valid = !1,
            this.prevNote = null,
            this.curNote = null,
            this.nextNote = null,
            this.pitch = 0,
            this.pitchIndex = -1,
            this.curIndex = 0,
            this.start = 0,
            this.end = 0,
            this.part = 0,
            this.exactPart = 0,
            this.nearPinIndex = 0,
            this.pins = []
        }
    }
    class aa {
        constructor(t, e, i) {
            this.m = t,
            this.lh = e,
            this.dh = i,
            this.controlMode = !1,
            this.shiftMode = !1,
            this.ph = Y.pattern({
                id: "patternEditorNoteBackground" + this.dh,
                x: "0",
                y: "0",
                patternUnits: "userSpaceOnUse"
            }),
            this.mh = Y.pattern({
                id: "patternEditorDrumBackground" + this.dh,
                x: "0",
                y: "0",
                patternUnits: "userSpaceOnUse"
            }),
            this.uh = Y.pattern({
                id: "patternEditorModBackground" + this.dh,
                x: "0",
                y: "0",
                patternUnits: "userSpaceOnUse"
            }),
            this.fh = Y.rect({
                x: "0",
                y: "0",
                "pointer-events": "none",
                fill: "url(#patternEditorNoteBackground" + this.dh + ")"
            }),
            this.yh = Y.svg(),
            this.bh = Y.rect({
                x: "0",
                y: "0",
                width: "4",
                fill: nt.playhead,
                "pointer-events": "none"
            }),
            this.gh = Y.rect({
                class: "dashed-line dash-move",
                fill: nt.boxSelectionFill,
                stroke: nt.hoverPreview,
                "stroke-width": 2,
                "stroke-dasharray": "5, 3",
                "fill-opacity": "0.4",
                "pointer-events": "none",
                visibility: "hidden"
            }),
            this.wh = Y.path({
                fill: "none",
                stroke: nt.hoverPreview,
                "stroke-width": "2",
                "pointer-events": "none"
            }),
            this.modDragValueLabel = J.div({
                width: "90",
                "text-anchor": "start",
                contenteditable: "true",
                style: "display: flex, justify-content: center; align-items:center; position:absolute; pointer-events: none;",
                "dominant-baseline": "central"
            }),
            this.q = Y.svg({
                id: "firstImage",
                style: `background-image: url(${l("customTheme", "")}); background-repeat: no-repeat; background-size: 100% 100%; background-color: ${nt.editorBackground}; touch-action: none; position: absolute;`,
                width: "100%",
                height: "100%"
            }, Y.defs(this.ph, this.mh, this.uh), this.fh, this.gh, this.yh, this.wh, this.bh),
            this.container = J.div({
                style: "height: 100%; overflow:hidden; position: relative; flex-grow: 1;"
            }, this.q, this.modDragValueLabel),
            this.xh = 34,
            this.kh = [],
            this.Mh = Y.rect(),
            this.Sh = Y.rect(),
            this.Fh = 0,
            this.Ch = 0,
            this.Ah = 0,
            this.editingModLabel = !1,
            this.Eh = 0,
            this.Th = 0,
            this.Ph = 6,
            this.Bh = -1,
            this.N = 0,
            this.Ze = 0,
            this.O = !1,
            this.R = !1,
            this.Si = !1,
            this.Ih = !1,
            this.Lh = !1,
            this.Dh = [],
            this.ra = 0,
            this.zh = 0,
            this.qh = 0,
            this.Nh = !1,
            this.Oh = !1,
            this.Rh = !1,
            this.$h = !1,
            this.Hh = !1,
            this._h = 0,
            this.Vh = 0,
            this.Gh = 0,
            this.Wh = !1,
            this.Bi = null,
            this.jh = null,
            this.Uh = !1,
            this.nr = new oa,
            this.Kh = [],
            this.Le = null,
            this.Jh = 0,
            this.Yh = 0,
            this.Qh = -1,
            this.Zh = -1,
            this.Xh = -1,
            this.tl = -1,
            this.Ao = !1,
            this.el = !1,
            this.il = !1,
            this.nl = -1,
            this.sl = -1,
            this.ol = -1,
            this.al = -1,
            this.rl = -1,
            this.hl = t => {
                const e = t.target;
                let i = Number(e.innerText);
                if (!(!isNaN(i) && i >= 0 && i < this.Th) && "" != e.innerText && "-" != e.innerText) {
                    isNaN(i) && (i = this.Th,
                    e.innerText = "" + this.Th);
                    let t = Math.floor(Math.max(Number(this.Th), Math.min(Number(this.Ph), i)));
                    e.innerText != t + "" && (e.innerText = t + "");
                    let n = +(t >= 10) + +(t >= 100) + +(t < 0) + +(t <= -10);
                    this.Fh = +q(Math.max(Math.min(this.u - 10 - 8 * n, this.ll * (this.cl.start + this.dl.time) - 4 - 4 * n), 2)),
                    this.modDragValueLabel.style.setProperty("left", this.Fh + "px");
                    const s = new Xt;
                    this.Bi = s,
                    this.m.setProspectiveChange(this.Bi),
                    s.append(new zn(this.m,this.cl,this.dl.time,t - p.modulators[this.pl].convertRealFactor,this.dl.interval,this.shiftMode))
                }
            }
            ,
            this.resetCopiedPins = () => {
                const t = this.ml();
                let e = this.m.song.getVolumeCap(!1);
                this.Dh.length = this.m.song.getChannelCount(),
                this.Kh.length = this.m.song.getChannelCount();
                for (let i = 0; i < this.m.song.pitchChannelCount; i++)
                    this.Dh[i] = [Et(0, 0, e), Et(0, t, e)],
                    this.Kh[i] = [e, e];
                for (let i = this.m.song.pitchChannelCount; i < this.m.song.pitchChannelCount + this.m.song.noiseChannelCount; i++)
                    this.Dh[i] = [Et(0, 0, e), Et(0, t, 0)],
                    this.Kh[i] = [e, 0];
                for (let i = this.m.song.pitchChannelCount + this.m.song.noiseChannelCount; i < this.m.song.getChannelCount(); i++)
                    this.Dh[i] = [Et(0, 0, e), Et(0, t, 0)],
                    this.Kh[i] = [e, 0]
            }
            ,
            this.fl = t => {
                this.Lh && !this.shiftMode && !this.Si && this.O && performance.now() > this.qh + 1e3 && this.nr.valid && this.m.lastChangeWas(this.Bi) && (this.Bi.undo(),
                this.Nh = !0,
                this.Oh = !1,
                this.Ri(),
                this.m.notifier.notifyWatchers());
                const e = Math.floor(this.m.synth.playhead)
                  , i = this.yh.querySelectorAll(".note-flash");
                if (this.m.synth.playing && (null != this.Le && this.m.song.getPattern(this.m.channel, Math.floor(this.m.synth.playhead)) == this.Le || Math.floor(this.m.synth.playhead) == this.m.bar + this.dh)) {
                    this.bh.setAttribute("visibility", "visible");
                    const t = this.m.synth.playhead - e;
                    for (var n = 0; n < i.length; n++) {
                        var s = i[n];
                        const e = Number(s.getAttribute("note-start")) / (this.m.song.beatsPerBar * p.partsPerBeat)
                          , o = Number(s.getAttribute("note-end")) / (this.m.song.beatsPerBar * p.partsPerBeat);
                        if (t >= e && this.m.prefs.notesFlashWhenPlayed) {
                            const i = o - e;
                            s.style.opacity = String(1 - (t - e - i / 2) / (i / 2))
                        } else
                            s.style.opacity = "0"
                    }
                    Math.abs(t - this.Jh) > .1 ? this.Jh = t : this.Jh += .2 * (t - this.Jh),
                    this.bh.setAttribute("x", "" + q(this.Jh * this.u - 2))
                } else {
                    this.bh.setAttribute("visibility", "hidden");
                    for (n = 0; n < i.length; n++) {
                        (s = i[n]).style.opacity = "0"
                    }
                }
                this.m.synth.playing && (this.m.synth.recording || this.m.prefs.autoFollow) && this.rl != e && (new Pe(this.m,this.m.channel,e),
                this.m.notifier.notifyWatchers()),
                this.rl = e,
                this.m.currentPatternIsDirty && this.yl(),
                window.requestAnimationFrame(this.fl)
            }
            ,
            this.W = t => {
                this.R || (this.R = !0,
                this.Lh = !1)
            }
            ,
            this.U = t => {
                this.R && (this.R = !1)
            }
            ,
            this.K = t => {
                t.preventDefault();
                const e = this.q.getBoundingClientRect();
                this.N = ((t.clientX || t.pageX) - e.left) * this.u / (e.right - e.left),
                this.Ze = ((t.clientY || t.pageY) - e.top) * this.v / (e.bottom - e.top),
                isNaN(this.N) && (this.N = 0),
                isNaN(this.Ze) && (this.Ze = 0),
                this.Lh = !1,
                this.Nh = t.shiftKey,
                this.Oh = !1,
                this.Ri()
            }
            ,
            this.Y = t => {
                t.preventDefault();
                const e = this.q.getBoundingClientRect();
                this.N = (t.touches[0].clientX - e.left) * this.u / (e.right - e.left),
                this.Ze = (t.touches[0].clientY - e.top) * this.v / (e.bottom - e.top),
                isNaN(this.N) && (this.N = 0),
                isNaN(this.Ze) && (this.Ze = 0),
                this.Lh = !0,
                this.Nh = t.shiftKey,
                this.Oh = !1,
                this.qh = performance.now(),
                this.Ri()
            }
            ,
            this.Z = t => {
                this.controlMode = t.ctrlKey,
                this.shiftMode = t.shiftKey;
                const e = this.q.getBoundingClientRect();
                this.N = ((t.clientX || t.pageX) - e.left) * this.u / (e.right - e.left),
                this.Ze = ((t.clientY || t.pageY) - e.top) * this.v / (e.bottom - e.top),
                isNaN(this.N) && (this.N = 0),
                isNaN(this.Ze) && (this.Ze = 0),
                this.Lh = !1,
                this.X()
            }
            ,
            this.tt = t => {
                if (!this.O)
                    return;
                t.preventDefault();
                const e = this.q.getBoundingClientRect();
                this.N = (t.touches[0].clientX - e.left) * this.u / (e.right - e.left),
                this.Ze = (t.touches[0].clientY - e.top) * this.v / (e.bottom - e.top),
                isNaN(this.N) && (this.N = 0),
                isNaN(this.Ze) && (this.Ze = 0),
                this.X()
            }
            ,
            this.et = t => {
                if (!this.nr.valid)
                    return;
                const e = this.m.lastChangeWas(this.Bi);
                if (this.O && e && null != this.Bi)
                    if (this.Hh)
                        this.m.record(this.Bi),
                        this.Bi = null,
                        null != this.Le && this.m.song.getChannelIsMod(this.m.channel) && this.Le.notes.sort((function(t, e) {
                            return t.start == e.start ? t.pitches[0] - e.pitches[0] : t.start - e.start
                        }
                        ));
                    else if (this.Rh || this.$h || this.Nh)
                        this.bl(this.Bi),
                        this.Bi = null;
                    else if (this.Si || null == this.nr.curNote || !this.Bi.isNoop() || this.Rh || this.$h || this.Hh || this.Nh)
                        this.m.record(this.Bi),
                        this.Bi = null,
                        null != this.Le && this.m.song.getChannelIsMod(this.m.channel) && this.Le.notes.sort((function(t, e) {
                            return t.start == e.start ? t.pitches[0] - e.pitches[0] : t.start - e.start
                        }
                        ));
                    else {
                        if (null == this.Le)
                            throw new Error;
                        const t = new Xt;
                        if (t.append(new Fn(this.m,0,0)),
                        -1 == this.nr.pitchIndex) {
                            if (this.nr.curNote.pitches.length == p.maxChordSize && t.append(new Ni(this.m,this.nr.curNote,this.nr.curNote.pitches[0],0,!0)),
                            t.append(new Ni(this.m,this.nr.curNote,this.nr.pitch,this.nr.curNote.pitches.length)),
                            this.gl(this.nr.curNote),
                            this.m.prefs.enableNotePreview && !this.m.synth.playing) {
                                const t = Math.min(p.partsPerBeat, this.nr.end - this.nr.start);
                                this.m.performance.setTemporaryPitches(this.nr.curNote.pitches, t)
                            }
                        } else
                            1 == this.nr.curNote.pitches.length ? t.append(new gn(this.m,this.Le,this.nr.curNote,this.nr.curIndex,!0)) : t.append(new Ni(this.m,this.nr.curNote,this.nr.pitch,this.nr.curNote.pitches.indexOf(this.nr.pitch),!0));
                        this.m.record(t)
                    }
                this.O = !1,
                this.Si = !1,
                this.Rh = !1,
                this.$h = !1,
                this.Hh = !1,
                this.Uh = !1,
                this.modDragValueLabel.setAttribute("fill", nt.secondaryText),
                this.ur(),
                this.j()
            }
            ;
            for (let t = 0; t < p.pitchesPerOctave; t++) {
                const e = Y.rect();
                e.setAttribute("x", "1"),
                e.setAttribute("fill", 0 == t ? nt.tonic : nt.pitchBackground),
                this.ph.appendChild(e),
                this.kh[t] = e
            }
            this.Mh.setAttribute("x", "1"),
            this.Mh.setAttribute("y", "1"),
            this.Mh.setAttribute("fill", nt.pitchBackground),
            this.mh.appendChild(this.Mh),
            this.Sh.setAttribute("fill", nt.pitchBackground),
            this.uh.appendChild(this.Sh),
            this.lh ? (this.ur(),
            this.j(),
            window.requestAnimationFrame(this.fl),
            this.q.addEventListener("mousedown", this.K),
            document.addEventListener("mousemove", this.Z),
            document.addEventListener("mouseup", this.et),
            this.q.addEventListener("mouseover", this.W),
            this.q.addEventListener("mouseout", this.U),
            this.q.addEventListener("touchstart", this.Y),
            this.q.addEventListener("touchmove", this.tt),
            this.q.addEventListener("touchend", this.et),
            this.q.addEventListener("touchcancel", this.et),
            this.modDragValueLabel.addEventListener("input", this.hl)) : (this.bh.style.display = "none",
            this.q.appendChild(Y.rect({
                x: 0,
                y: 0,
                width: 1e4,
                height: 1e4,
                fill: nt.editorBackground,
                style: "opacity: 0.5;"
            }))),
            this.resetCopiedPins()
        }
        wl() {
            return this.m.song.getChannelIsMod(this.m.channel) ? p.modCount - 1 : this.m.song.getChannelIsNoise(this.m.channel) ? p.drumCount - 1 : p.maxPitch
        }
        ml() {
            if (this.controlMode && this.Ih)
                return p.partsPerBeat;
            const t = p.rhythms[this.m.song.rhythm].stepsPerBeat;
            return t % 4 == 0 ? p.partsPerBeat / 2 : t % 3 == 0 ? p.partsPerBeat / 3 : t % 2 == 0 ? p.partsPerBeat / 2 : p.partsPerBeat
        }
        vl() {
            return this.controlMode && this.Ih ? 1 : p.partsPerBeat / p.rhythms[this.m.song.rhythm].stepsPerBeat
        }
        xl(t) {
            const e = this.vl();
            return Math.floor(t / e) * e
        }
        ur() {
            if (this.nr = new oa,
            this.N < 0 || this.N > this.u || this.Ze < 0 || this.Ze > this.v || this.Bh <= 0)
                return;
            const t = this.vl();
            this.nr.exactPart = this.N / this.ll,
            this.nr.part = Math.floor(Math.max(0, Math.min(this.m.song.beatsPerBar * p.partsPerBeat - t, this.nr.exactPart)) / t) * t;
            let e = !1;
            if (null != this.Le) {
                for (const t of this.Le.notes)
                    if (t.end <= this.nr.exactPart)
                        this.m.song.getChannelIsMod(this.m.channel) ? (t.pitches[0] == Math.floor(this.kl(this.Ze)) && (this.nr.prevNote = t),
                        e || this.nr.curIndex++) : (this.nr.prevNote = t,
                        this.nr.curIndex++);
                    else if (t.start <= this.nr.exactPart && t.end > this.nr.exactPart)
                        this.m.song.getChannelIsMod(this.m.channel) ? t.pitches[0] == Math.floor(this.kl(this.Ze)) ? (this.nr.curNote = t,
                        e = !0) : (!e || null != this.nr.curNote && t.start < this.nr.curNote.start) && this.nr.curIndex++ : this.nr.curNote = t;
                    else if (t.start > this.nr.exactPart) {
                        if (!this.m.song.getChannelIsMod(this.m.channel)) {
                            this.nr.nextNote = t;
                            break
                        }
                        if (t.pitches[0] == Math.floor(this.kl(this.Ze))) {
                            this.nr.nextNote = t;
                            break
                        }
                    }
                if (this.m.song.getChannelIsMod(this.m.channel) && !this.editingModLabel)
                    if (null != this.Le.notes[this.nr.curIndex] && null != this.nr.curNote) {
                        let t = 0;
                        for (; this.nr.curNote.start + this.nr.curNote.pins[t].time < this.nr.exactPart && t < this.nr.curNote.pins.length; )
                            t++;
                        t > 0 && this.nr.curNote.start + this.nr.curNote.pins[t].time - this.nr.exactPart > this.nr.exactPart - (this.nr.curNote.start + this.nr.curNote.pins[t - 1].time) && t--,
                        this.modDragValueLabel.style.setProperty("color", "#666688"),
                        this.modDragValueLabel.style.setProperty("display", "");
                        const e = Math.max(0, p.modCount - 1 - this.nr.curNote.pitches[0]);
                        let i = this.m.song.channels[this.m.channel].instruments[this.m.getCurrentInstrument(this.dh)].modulators[e]
                          , n = this.nr.curNote.pins[t].size + p.modulators[i].convertRealFactor
                          , s = +(n >= 10) + +(n >= 100) + +(n < 0) + +(n <= -10);
                        this.Ah = 8 + 8 * s,
                        this.Fh = +q(Math.max(Math.min(this.u - 10 - 8 * s, this.ll * (this.nr.curNote.start + this.nr.curNote.pins[t].time) - 4 - 4 * s), 2)),
                        this.Ch = +q(this.Ml(this.nr.curNote.pitches[0] - this.Yh) - 17 - (this.Bh - this.Sl) / 2),
                        this.Eh = this.nr.curNote.pins[t].size,
                        this.cl = this.nr.curNote,
                        this.dl = this.nr.curNote.pins[t],
                        this.Th = p.modulators[i].convertRealFactor,
                        this.Ph = p.modulators[i].convertRealFactor + p.modulators[i].maxRawVol,
                        this.pl = i,
                        this.modDragValueLabel.style.setProperty("left", this.Fh + "px"),
                        this.modDragValueLabel.style.setProperty("top", this.Ch + "px"),
                        this.modDragValueLabel.textContent = "" + n
                    } else
                        this.modDragValueLabel.style.setProperty("display", "none"),
                        this.modDragValueLabel.style.setProperty("pointer-events", "none"),
                        this.modDragValueLabel.setAttribute("contenteditable", "false");
                else
                    this.editingModLabel || (this.modDragValueLabel.style.setProperty("display", "none"),
                    this.modDragValueLabel.style.setProperty("pointer-events", "none"),
                    this.modDragValueLabel.setAttribute("contenteditable", "false"))
            } else
                this.modDragValueLabel.style.setProperty("display", "none"),
                this.modDragValueLabel.style.setProperty("pointer-events", "none"),
                this.modDragValueLabel.setAttribute("contenteditable", "false");
            let i = this.kl(this.Ze);
            if (null != this.nr.curNote) {
                this.nr.start = this.nr.curNote.start,
                this.nr.end = this.nr.curNote.end,
                this.nr.pins = this.nr.curNote.pins;
                let t, e = 0, n = 0, s = this.nr.curNote.pins[0];
                for (let i = 1; i < this.nr.curNote.pins.length; i++) {
                    t = s,
                    s = this.nr.curNote.pins[i];
                    const o = this.ll * (this.nr.curNote.start + t.time)
                      , a = this.ll * (this.nr.curNote.start + s.time);
                    if (this.N > a)
                        continue;
                    if (this.N < o)
                        throw new Error;
                    const r = (this.N - o) / (a - o)
                      , h = Math.sqrt(1 / Math.sqrt(4) - Math.pow(r - .5, 2)) - .5
                      , l = Math.abs(s.interval - t.interval);
                    e = t.interval * (1 - r) + s.interval * r,
                    n = h * l + .95;
                    break
                }
                let o = Number.MAX_VALUE
                  , a = -Number.MAX_VALUE
                  , r = Number.MAX_VALUE;
                for (const t of this.nr.curNote.pins) {
                    o > t.interval && (o = t.interval),
                    a < t.interval && (a = t.interval);
                    const e = Math.abs(this.nr.curNote.start + t.time - this.N / this.ll);
                    r > e && (r = e,
                    this.nr.nearPinIndex = this.nr.curNote.pins.indexOf(t))
                }
                if (i -= e,
                this.nr.pitch = this.Fl(i, -o, this.wl() - a),
                !this.m.song.getChannelIsNoise(this.m.channel) && !this.m.song.getChannelIsMod(this.m.channel)) {
                    let t = n;
                    for (let e = 0; e < this.nr.curNote.pitches.length; e++) {
                        const n = Math.abs(this.nr.curNote.pitches[e] - i + .5);
                        n > t || (t = n,
                        this.nr.pitch = this.nr.curNote.pitches[e])
                    }
                }
                for (let t = 0; t < this.nr.curNote.pitches.length; t++)
                    if (this.nr.curNote.pitches[t] == this.nr.pitch) {
                        this.nr.pitchIndex = t;
                        break
                    }
            } else {
                this.nr.pitch = this.Fl(i, 0, this.wl());
                const t = this.Cl[this.Cl.length - 1].time
                  , e = Math.floor(this.nr.part / p.partsPerBeat)
                  , n = this.ml()
                  , s = this.nr.part % p.partsPerBeat;
                if (1 == t)
                    this.nr.start = this.nr.part;
                else if (t > p.partsPerBeat)
                    this.nr.start = e * p.partsPerBeat;
                else if (t == p.partsPerBeat)
                    this.nr.start = e * p.partsPerBeat,
                    n < p.partsPerBeat && s > n && (this.nr.start += Math.floor(s / n) * n);
                else {
                    this.nr.start = e * p.partsPerBeat;
                    let i = p.partsPerBeat % t == 0 ? t : Math.min(t, n);
                    for (; i < n && p.partsPerBeat % i != 0; )
                        i++;
                    this.nr.start += Math.floor(s / i) * i
                }
                this.nr.end = this.nr.start + t;
                let o = 0
                  , a = this.m.song.beatsPerBar * p.partsPerBeat;
                if (null != this.nr.prevNote && (o = this.nr.prevNote.end),
                null != this.nr.nextNote && (a = this.nr.nextNote.start),
                this.nr.start < o ? (this.nr.start = o,
                this.nr.end = this.nr.start + t,
                this.nr.end > a && (this.nr.end = a)) : this.nr.end > a && (this.nr.end = a,
                this.nr.start = this.nr.end - t,
                this.nr.start < o && (this.nr.start = o)),
                this.nr.end - this.nr.start == t)
                    if (this.Dh.length > this.m.channel)
                        this.Cl = this.Dh[this.m.channel],
                        this.nr.pins = this.Cl;
                    else {
                        const t = this.m.song.getVolumeCap(!1);
                        this.nr.pins = [Et(0, 0, t), Et(0, n, t)]
                    }
                else {
                    this.nr.pins = [];
                    for (const t of this.Cl) {
                        if (!(t.time <= this.nr.end - this.nr.start)) {
                            this.nr.pins.push(Et(0, this.nr.end - this.nr.start, t.size));
                            break
                        }
                        if (this.nr.pins.push(Et(0, t.time, t.size)),
                        t.time == this.nr.end - this.nr.start)
                            break
                    }
                }
                if (this.m.song.getChannelIsMod(this.m.channel)) {
                    if (this.nr.pitch = Math.max(0, Math.min(p.modCount - 1, this.nr.pitch)),
                    null != this.Kh && null != this.Kh[this.m.channel])
                        for (let t = 0; t < this.nr.pins.length; t++)
                            this.nr.pins[t].size = this.Kh[this.m.channel][t];
                    let t = this.m.song.getVolumeCap(this.m.song.getChannelIsMod(this.m.channel), this.m.channel, this.m.getCurrentInstrument(this.dh), this.nr.pitch)
                      , e = 0;
                    for (const t of this.nr.pins)
                        t.size > e && (e = t.size);
                    if (e > t)
                        for (const i of this.nr.pins)
                            i.size = Math.round(i.size * (t / e))
                }
            }
            this.nr.valid = !0
        }
        Al() {
            return this.nr.valid && this.m.selection.patternSelectionActive && this.m.selection.patternSelectionStart <= this.nr.exactPart && this.nr.exactPart <= this.m.selection.patternSelectionEnd
        }
        El() {
            return this.nr.valid && this.m.selection.patternSelectionActive && -1 == this.nr.pitchIndex && this.m.selection.patternSelectionStart - 3 <= this.nr.exactPart && this.nr.exactPart <= this.m.selection.patternSelectionStart + 1.25
        }
        Tl() {
            return this.nr.valid && this.m.selection.patternSelectionActive && -1 == this.nr.pitchIndex && this.m.selection.patternSelectionEnd - 1.25 <= this.nr.exactPart && this.nr.exactPart <= this.m.selection.patternSelectionEnd + 3
        }
        kl(t) {
            return Math.max(0, Math.min(this.Pl - 1, this.Pl - t / this.Bh)) + this.Yh
        }
        Fl(t, e, i) {
            t < e && (t = e),
            t > i && (t = i);
            const n = this.m.prefs.notesOutsideScale ? p.scales.dictionary.Free.flags : this.m.song.scale == p.scales.dictionary.Custom.index ? this.m.song.scaleCustom : p.scales[this.m.song.scale].flags;
            if (n[Math.floor(t) % p.pitchesPerOctave] || this.m.song.getChannelIsNoise(this.m.channel) || this.m.song.getChannelIsMod(this.m.channel))
                return Math.floor(t);
            {
                let s = Math.floor(t) + 1
                  , o = Math.floor(t) - 1;
                for (; !n[s % p.pitchesPerOctave]; )
                    s++;
                for (; !n[o % p.pitchesPerOctave]; )
                    o--;
                if (s > i)
                    return o < e ? e : o;
                if (o < e)
                    return s;
                let a = s
                  , r = o + 1;
                return s % p.pitchesPerOctave != 0 && s % p.pitchesPerOctave != 7 || (a -= .5),
                o % p.pitchesPerOctave != 0 && o % p.pitchesPerOctave != 7 || (r += .5),
                t - r > a - t ? s : o
            }
        }
        gl(t) {
            this.Cl = [];
            for (const e of t.pins)
                this.Cl.push(Et(0, e.time, e.size));
            for (let t = 1; t < this.Cl.length - 1; )
                this.Cl[t - 1].size == this.Cl[t].size && this.Cl[t].size == this.Cl[t + 1].size ? this.Cl.splice(t, 1) : t++;
            this.Dh[this.m.channel] = this.Cl,
            this.Kh[this.m.channel] = [];
            for (let t = 0; t < this.Cl.length; t++)
                this.Kh[this.m.channel].push(this.Cl[t].size)
        }
        movePlayheadToMouse() {
            return !!this.R && (this.m.synth.playhead = this.m.bar + this.dh + this.N / this.u,
            !0)
        }
        setModSettingsForChange(t, e) {
            const i = this
              , n = Math.max(4, p.partsPerBeat / p.rhythms[this.m.song.rhythm].stepsPerBeat)
              , s = Math.floor(this.m.synth.playhead)
              , o = this.m.synth.getCurrentPart();
            let a = !1;
            const r = o < n / 2 ? 0 : Math.ceil(o / n) * n;
            function h(t, e, n, s) {
                let o = null == n ? 0 : n
                  , a = null == n ? e.instruments.length - 1 : n;
                for (let n = o; n <= a; n++) {
                    let o = e.instruments[n];
                    for (let e = 0; e < p.modCount; e++)
                        if (o.modulators[e] != t || p.modulators[o.modulators[e]].forSong || o.modChannels[e] != i.m.channel) {
                            if (o.modulators[e] == t && p.modulators[o.modulators[e]].forSong && -1 == o.modChannels[e])
                                return [n, e]
                        } else if (i.m.getCurrentInstrument() == o.modInstruments[e] || o.modInstruments[e] >= i.m.song.channels[i.m.channel].instruments.length) {
                            if (null == s || t != p.modulators.dictionary["eq filter"].index && t != p.modulators.dictionary["note filter"].index)
                                return [n, e];
                            if (o.modFilterTypes[e] == s)
                                return [n, e]
                        }
                }
                return [-1, -1]
            }
            function l(t, e, i, n, s, o) {
                if (!(e >= i))
                    for (let a = 0; a < n.notes.length; a++) {
                        const r = n.notes[a];
                        if (r.pitches[0] == s && (r.start < i && r.end > e)) {
                            let s = !1
                              , h = !1
                              , l = -1
                              , c = 0;
                            if (r.start <= e && r.end >= i) {
                                for (let t = 0; t < r.pins.length; t++) {
                                    const n = r.pins[t];
                                    r.start + n.time > e && r.start + n.time < i && (l < 0 && (l = t),
                                    c++)
                                }
                                return void (c > 0 && r.pins.splice(l, c))
                            }
                            for (let t = 0; t < r.pins.length; t++) {
                                const n = r.pins[t];
                                r.start + n.time >= e && r.start + n.time <= i ? (l < 0 && (l = t),
                                c++) : (0 == c && (s = !0),
                                c > 0 && (h = !0))
                            }
                            if (s && c > 0 && (r.pins[l].time = e - r.start,
                            l++,
                            c--),
                            h && c > 0 && (r.pins[l + c - 1].time = i - r.start,
                            c--),
                            r.pins.splice(l, c),
                            r.pins.length < 2) {
                                o.append(new gn(t,n,r,a,!0)),
                                a--;
                                continue
                            }
                            let d = 0;
                            d = r.pins[0].time,
                            r.start += d;
                            for (let t = 0; t < r.pins.length; t++)
                                r.pins[t].time -= d;
                            r.end = r.start + r.pins[r.pins.length - 1].time,
                            r.end <= r.start && (o.append(new gn(t,n,r,a,!0)),
                            a--)
                        }
                    }
            }
            const c = new Xt
              , d = this.m.song.channels[this.m.channel].instruments[this.m.getCurrentInstrument()];
            let m = []
              , u = []
              , f = []
              , y = !0
              , b = null;
            if (null == t) {
                var g = p.modulators.dictionary["song volume"];
                m.push(g.index),
                y && f.push(this.m.prefs.volume - g.convertRealFactor)
            } else if (null != this.m.continuingModRecordingChange && null == this.m.continuingModRecordingChange.storedChange && null == this.m.continuingModRecordingChange.storedSlider) {
                g = p.modulators.dictionary["song volume"];
                m.push(g.index),
                y && f.push(this.m.continuingModRecordingChange.storedValues[0])
            } else if (t instanceof mn) {
                g = p.modulators.dictionary.tempo;
                m.push(g.index),
                y && f.push(this.m.song.tempo - g.convertRealFactor),
                b = e.getSliderForModSetting(g.index),
                null != b && (this.m.song.tempo = b.getValueBeforeProspectiveChange())
            } else if (t instanceof Pn) {
                g = p.modulators.dictionary["mix volume"];
                m.push(g.index),
                y && f.push(d.volume - g.convertRealFactor),
                b = e.getSliderForModSetting(g.index),
                null != b && (d.volume = b.getValueBeforeProspectiveChange())
            } else if (t instanceof Ln) {
                g = p.modulators.dictionary.pan;
                m.push(g.index),
                y && f.push(d.pan - g.convertRealFactor),
                b = e.getSliderForModSetting(g.index),
                null != b && (d.pan = b.getValueBeforeProspectiveChange())
            } else if (t instanceof bn) {
                g = p.modulators.dictionary.reverb;
                m.push(g.index),
                y && f.push(d.reverb - g.convertRealFactor),
                b = e.getSliderForModSetting(g.index),
                null != b && (d.reverb = b.getValueBeforeProspectiveChange())
            } else if (t instanceof ai) {
                g = p.modulators.dictionary.distortion;
                m.push(g.index),
                y && f.push(d.distortion - g.convertRealFactor),
                b = e.getSliderForModSetting(g.index),
                null != b && (d.distortion = b.getValueBeforeProspectiveChange())
            } else if (t instanceof Ti) {
                g = p.modulators.dictionary["fm slider " + (t.operatorIndex + 1)];
                m.push(g.index),
                y && f.push(d.operators[t.operatorIndex].amplitude - g.convertRealFactor),
                b = e.getSliderForModSetting(g.index),
                null != b && (d.operators[t.operatorIndex].amplitude = b.getValueBeforeProspectiveChange())
            } else if (t instanceof Pi) {
                g = p.modulators.dictionary["fm feedback"];
                m.push(g.index),
                y && f.push(d.feedbackAmplitude - g.convertRealFactor),
                b = e.getSliderForModSetting(g.index),
                null != b && (d.feedbackAmplitude = b.getValueBeforeProspectiveChange())
            } else if (t instanceof Xe) {
                g = p.modulators.dictionary["pulse width"];
                m.push(g.index),
                y && f.push(d.pulseWidth - g.convertRealFactor),
                b = e.getSliderForModSetting(g.index),
                null != b && (d.pulseWidth = b.getValueBeforeProspectiveChange())
            } else if (t instanceof ti) {
                g = p.modulators.dictionary["decimal offset"];
                m.push(g.index),
                y && f.push(d.decimalOffset - g.convertRealFactor),
                b = e.getSliderForModSetting(g.index),
                null != b && (d.decimalOffset = b.getValueBeforeProspectiveChange())
            } else if (t instanceof oi) {
                g = p.modulators.dictionary.detune;
                m.push(g.index),
                y && f.push(d.detune - g.convertRealFactor - p.detuneCenter),
                b = e.getSliderForModSetting(g.index),
                null != b && (d.detune = b.getValueBeforeProspectiveChange() + p.detuneCenter)
            } else if (t instanceof Re) {
                g = p.modulators.dictionary["vibrato depth"];
                m.push(g.index),
                y && f.push(25 * d.vibratoDepth - g.convertRealFactor),
                b = e.getSliderForModSetting(g.index),
                null != b && (d.vibratoDepth = b.getValueBeforeProspectiveChange() / 25)
            } else if (t instanceof He) {
                g = p.modulators.dictionary["vibrato speed"];
                m.push(g.index),
                y && f.push(d.vibratoSpeed - g.convertRealFactor),
                b = e.getSliderForModSetting(g.index),
                null != b && (d.vibratoSpeed = b.getValueBeforeProspectiveChange())
            } else if (t instanceof _e) {
                g = p.modulators.dictionary["vibrato delay"];
                m.push(g.index),
                y && f.push(d.vibratoDelay - g.convertRealFactor),
                b = e.getSliderForModSetting(g.index),
                null != b && (d.vibratoDelay = b.getValueBeforeProspectiveChange())
            } else if (t instanceof Ge) {
                g = p.modulators.dictionary["arp speed"];
                m.push(g.index),
                y && f.push(d.arpeggioSpeed - g.convertRealFactor),
                b = e.getSliderForModSetting(g.index),
                null != b && (d.arpeggioSpeed = b.getValueBeforeProspectiveChange())
            } else if (t instanceof Dn) {
                g = p.modulators.dictionary["pan delay"];
                m.push(g.index),
                y && f.push(d.panDelay - g.convertRealFactor),
                b = e.getSliderForModSetting(g.index),
                null != b && (d.panDelay = b.getValueBeforeProspectiveChange())
            } else if (t instanceof Xt && t.checkFirst()instanceof wi && !t.isCommitted()) {
                const e = t.checkFirst()
                  , i = e.getMoveData(!0)
                  , n = e.getMoveData(!1);
                let s = d.eqFilter;
                var w;
                if (e.useNoteFilter) {
                    w = p.modulators.dictionary["note filter"].index,
                    s = d.noteFilter,
                    null == d.tmpNoteFilterEnd && (d.tmpNoteFilterStart = new Rt,
                    d.tmpNoteFilterStart.fromJsonObject(d.noteFilter.toJsonObject()),
                    d.tmpNoteFilterEnd = d.tmpNoteFilterStart);
                    const t = d.tmpNoteFilterEnd.controlPoints[e.pointIndex];
                    null != t && t.type == e.pointType && (t.freq = n.freq,
                    t.gain = n.gain)
                } else {
                    w = p.modulators.dictionary["eq filter"].index,
                    null == d.tmpEqFilterEnd && (d.tmpEqFilterStart = new Rt,
                    d.tmpEqFilterStart.fromJsonObject(d.eqFilter.toJsonObject()),
                    d.tmpEqFilterEnd = d.tmpEqFilterStart);
                    const t = d.tmpEqFilterEnd.controlPoints[e.pointIndex];
                    null != t && t.type == e.pointType && (t.freq = n.freq,
                    t.gain = n.gain)
                }
                m.push(w),
                m.push(w),
                y && f.push(n.freq),
                y && f.push(n.gain),
                u.push(1 + 2 * e.pointIndex),
                u.push(1 + 2 * e.pointIndex + 1);
                for (let t = 0; t < s.controlPointCount; t++) {
                    var v = s.controlPoints[t];
                    Object.is(v, i.point) && (v.freq = i.freq,
                    v.gain = i.gain)
                }
            } else if (t instanceof hi) {
                g = p.modulators.dictionary["bit crush"];
                m.push(g.index),
                y && f.push(d.bitcrusherQuantization - g.convertRealFactor),
                b = e.getSliderForModSetting(g.index),
                null != b && (d.bitcrusherQuantization = b.getValueBeforeProspectiveChange())
            } else if (t instanceof ri) {
                g = p.modulators.dictionary["freq crush"];
                m.push(g.index),
                y && f.push(d.bitcrusherFreq - g.convertRealFactor),
                b = e.getSliderForModSetting(g.index),
                null != b && (d.bitcrusherFreq = b.getValueBeforeProspectiveChange())
            } else if (t instanceof fn) {
                g = p.modulators.dictionary.echo;
                m.push(g.index),
                y && f.push(d.echoSustain - g.convertRealFactor),
                b = e.getSliderForModSetting(g.index),
                null != b && (d.echoSustain = b.getValueBeforeProspectiveChange())
            } else if (t instanceof yn) {
                g = p.modulators.dictionary.chorus;
                m.push(g.index),
                y && f.push(d.chorus - g.convertRealFactor),
                b = e.getSliderForModSetting(g.index),
                null != b && (d.chorus = b.getValueBeforeProspectiveChange())
            } else if (t instanceof mi) {
                g = p.modulators.dictionary["eq filt cut"];
                m.push(g.index),
                y && f.push(d.eqFilterSimpleCut - g.convertRealFactor),
                b = e.getSliderForModSetting(g.index),
                null != b && (d.eqFilterSimpleCut = b.getValueBeforeProspectiveChange())
            } else if (t instanceof ui) {
                g = p.modulators.dictionary["eq filt peak"];
                m.push(g.index),
                y && f.push(d.eqFilterSimplePeak - g.convertRealFactor),
                b = e.getSliderForModSetting(g.index),
                null != b && (d.eqFilterSimplePeak = b.getValueBeforeProspectiveChange())
            } else if (t instanceof fi) {
                g = p.modulators.dictionary["note filt cut"];
                m.push(g.index),
                y && f.push(d.noteFilterSimpleCut - g.convertRealFactor),
                b = e.getSliderForModSetting(g.index),
                null != b && (d.noteFilterSimpleCut = b.getValueBeforeProspectiveChange())
            } else if (t instanceof yi) {
                g = p.modulators.dictionary["note filt peak"];
                m.push(g.index),
                y && f.push(d.noteFilterSimplePeak - g.convertRealFactor),
                b = e.getSliderForModSetting(g.index),
                null != b && (d.noteFilterSimplePeak = b.getValueBeforeProspectiveChange())
            } else if (t instanceof si) {
                g = p.modulators.dictionary["pitch shift"];
                m.push(g.index),
                y && f.push(d.pitchShift - p.pitchShiftCenter - g.convertRealFactor),
                b = e.getSliderForModSetting(g.index),
                null != b && (d.pitchShift = b.getValueBeforeProspectiveChange())
            } else if (t instanceof li) {
                g = p.modulators.dictionary.sustain;
                m.push(g.index),
                y && f.push(d.stringSustain - g.convertRealFactor),
                b = e.getSliderForModSetting(g.index),
                null != b && (d.stringSustain = b.getValueBeforeProspectiveChange())
            } else if (t instanceof $e) {
                g = p.modulators.dictionary["envelope speed"];
                m.push(g.index),
                y && f.push(d.envelopeSpeed - g.convertRealFactor),
                b = e.getSliderForModSetting(g.index),
                null != b && (d.envelopeSpeed = b.getValueBeforeProspectiveChange())
            } else if (t instanceof ei) {
                g = p.modulators.dictionary.dynamism;
                m.push(g.index),
                y && f.push(d.supersawDynamism - g.convertRealFactor),
                b = e.getSliderForModSetting(g.index),
                null != b && (d.supersawDynamism = b.getValueBeforeProspectiveChange())
            } else if (t instanceof ii) {
                g = p.modulators.dictionary.spread;
                m.push(g.index),
                y && f.push(d.supersawSpread - g.convertRealFactor),
                b = e.getSliderForModSetting(g.index),
                null != b && (d.supersawSpread = b.getValueBeforeProspectiveChange())
            } else if (t instanceof ni) {
                g = p.modulators.dictionary["saw shape"];
                m.push(g.index),
                y && f.push(d.supersawShape - g.convertRealFactor),
                b = e.getSliderForModSetting(g.index),
                null != b && (d.supersawShape = b.getValueBeforeProspectiveChange())
            }
            for (let t = 0; t < f.length; t++)
                f[t] = Math.round(f[t]);
            null != this.m.continuingModRecordingChange && 0 == u.length && (null == b && null != this.m.continuingModRecordingChange.storedSlider && (b = this.m.continuingModRecordingChange.storedSlider),
            null != b && +b.input.value == b.getValueBeforeProspectiveChange() && (f = this.m.continuingModRecordingChange.storedValues,
            y = !1),
            this.m.continuingModRecordingChange = null),
            null != b && b.updateValue(b.getValueBeforeProspectiveChange());
            for (let t = 0; t < m.length; t++) {
                let e = []
                  , i = []
                  , o = []
                  , d = [];
                for (let n = this.m.song.pitchChannelCount + this.m.song.noiseChannelCount; n < this.m.song.getChannelCount(); n++) {
                    const r = this.m.song.channels[n];
                    let l = this.m.song.getPattern(n, s)
                      , p = 0
                      , f = 0;
                    var x;
                    if (null == l)
                        p = (x = u.length > t ? h(m[t], r, void 0, u[t]) : h(m[t], r))[0],
                        f = x[1],
                        -1 != p && (c.append(new Ji(this.m,n,s)),
                        new En(this.m,s,1,n,1),
                        l = this.m.song.getPattern(n, s),
                        l.instruments[0] = p,
                        a = !0);
                    else
                        p = (x = u.length > t ? h(m[t], r, l.instruments[0], u[t]) : h(m[t], r, l.instruments[0]))[0],
                        f = x[1],
                        -1 != p && (new En(this.m,s,1,n,1),
                        l = this.m.song.getPattern(n, s),
                        a = !0);
                    -1 != p && (e.push(l),
                    o.push(p),
                    i.push(r.instruments[p]),
                    d.push(f))
                }
                if (0 == o.length)
                    for (let n = this.m.song.pitchChannelCount + this.m.song.noiseChannelCount; n < this.m.song.getChannelCount(); n++) {
                        const r = this.m.song.channels[n];
                        let h = this.m.song.getPattern(n, s)
                          , l = -1;
                        if (null != h)
                            l = h.instruments[0];
                        else
                            for (let t = 0; t < r.instruments.length; t++)
                                for (let e = 0; e < p.modCount; e++)
                                    r.instruments[t].modulators[e] == p.modulators.dictionary.none.index && (l = t,
                                    c.append(new Ji(this.m,n,s)),
                                    h = this.m.song.getPattern(n, s),
                                    h.instruments[0] = t,
                                    e = p.modCount,
                                    t = r.instruments.length,
                                    n = this.m.song.getChannelCount(),
                                    a = !0);
                        if (-1 != l) {
                            let s = r.instruments[l];
                            for (let a = 0; a < p.modCount; a++)
                                s.modulators[a] == p.modulators.dictionary.none.index && (s.modulators[a] = m[t],
                                p.modulators[m[t]].forSong ? s.modChannels[a] = -1 : (s.modChannels[a] = this.m.channel,
                                this.m.song.channels[this.m.channel].instruments.length > 1 ? this.controlMode && this.shiftMode ? s.modInstruments[a] = this.m.getCurrentInstrument() : s.modInstruments[a] = this.m.song.channels[this.m.channel].instruments.length + 1 : s.modInstruments[a] = 0,
                                u.length > t && (s.modFilterTypes[a] = u[t])),
                                e.push(h),
                                o.push(l),
                                i.push(s),
                                d.push(a),
                                a = p.modCount,
                                n = this.m.song.getChannelCount())
                        }
                    }
                for (let o = 0; o < e.length; o++) {
                    const a = 0 == u.length ? 0 : 24
                      , h = 6 * +(n >= 6) + 12;
                    let b = -1
                      , g = null
                      , w = null
                      , v = -1
                      , x = -1
                      , k = null;
                    const M = p.modCount - 1 - d[o]
                      , S = i[o];
                    if (S.modChannels[d[o]] >= -1) {
                        let e = [];
                        if (p.modulators[m[t]].forSong)
                            e.push(0);
                        else if (S.modInstruments[d[o]] == this.m.synth.song.channels[S.modChannels[d[o]]].instruments.length)
                            for (let t = 0; t < this.m.synth.song.channels[S.modChannels[d[o]]].instruments.length; t++)
                                e.push(t);
                        else
                            S.modInstruments[d[o]] > this.m.synth.song.channels[S.modChannels[d[o]]].instruments.length ? null != this.m.synth.song.getPattern(S.modChannels[d[o]], s) && (e = this.m.synth.song.getPattern(S.modChannels[d[o]], s).instruments) : e.push(S.modInstruments[d[o]]);
                        for (let n = 0; n < e.length; n++)
                            this.m.synth.setModValue(f[t], f[t], i[o].modChannels[d[o]], e[n], m[t]),
                            this.m.synth.forceHoldMods(f[t], i[o].modChannels[d[o]], e[n], m[t])
                    }
                    for (let t = 0; t < e[o].notes.length; t++) {
                        const i = e[o].notes[t];
                        if (i.pitches[0] == M && i.start <= r)
                            for (let t = 0; t < i.pins.length; t++) {
                                const e = i.pins[t];
                                i.start + e.time <= r && (i.start + e.time > b || i.start == b) && (b = i.start + e.time,
                                w = e,
                                v = t,
                                g = i)
                            }
                        i.pitches[0] == M && i.end <= r && i.end > x && (x = i.end,
                        k = i)
                    }
                    let F = Math.max(0, r - n)
                      , C = Math.min(r + n + a, p.partsPerBeat * this.m.song.beatsPerBar)
                      , A = 0 == y;
                    if (null == g || r - g.end >= h) {
                        if (r == C)
                            continue;
                        l(this.m, r, C, e[o], M, c),
                        g = new Tt(M,r,C,f[t],this.m.song.getChannelIsNoise(this.m.channel)),
                        c.append(new gn(this.m,e[o],g,e[o].notes.length))
                    } else if (b == r) {
                        if (l(this.m, F, r, e[o], M, c),
                        l(this.m, r, C, e[o], M, c),
                        w.size = f[t],
                        A)
                            for (let e = 0; e < g.pins.length; e++)
                                g.pins[e].time >= F && g.pins[e].time <= r && (g.pins[e].size = f[t]);
                        if (null != k && k.pins.length >= 2)
                            if (k.end == r) {
                                if (k.pins[k.pins.length - 1].size = f[t],
                                A)
                                    for (let e = 0; e < k.pins.length; e++)
                                        k.pins[e].time + k.start >= F && (k.pins[e].size = f[t])
                            } else
                                k.end == F && g.start == r && (k.pins.push(Et(0, r - k.start, f[t])),
                                k.end = r)
                    } else if (r - b < 8 && g.pins[v].size == f[t]) {
                        if (A)
                            for (let e = 0; e < g.pins.length; e++)
                                g.pins[e].time >= F && g.pins[e].time <= r && (g.pins[e].size = f[t])
                    } else {
                        if (g.pins.length - 1 > v) {
                            let i;
                            l(this.m, F, r, e[o], M, c),
                            l(this.m, r, C, e[o], M, c);
                            let n = null;
                            for (i = 0; i < g.pins.length; i++) {
                                if (g.pins[i].time == r - g.start) {
                                    n = g.pins[i];
                                    break
                                }
                                if (g.pins[i].time > r - g.start)
                                    break
                            }
                            null != n ? n.size = f[t] : g.pins.splice(i, 0, Et(0, r - g.start, f[t]))
                        } else
                            l(this.m, F, r, e[o], M, c),
                            l(this.m, r, C, e[o], M, c),
                            g.pins.push(Et(0, r - g.start, f[t])),
                            g.end = r;
                        if (A)
                            for (let e = 0; e < g.pins.length; e++)
                                g.pins[e].time >= F && g.pins[e].time <= r && (g.pins[e].size = f[t])
                    }
                    let E = [-1, -1, -1, -1, -1, -1];
                    e[o].notes.sort((function(t, e) {
                        return t.start == e.start ? t.pitches[0] - e.pitches[0] : t.start - e.start
                    }
                    ));
                    for (let t = 0; t < e[o].notes.length; t++) {
                        const i = e[o].notes[t];
                        if (i.start < E[i.pitches[0]])
                            throw new Error("Error in mod note recording!");
                        if (E[i.pitches[0]] = i.end,
                        i.pins.length < 2 || i.pins[0].time > 0 || i.start == i.end || i.pins[i.pins.length - 1].time != i.end - i.start)
                            throw new Error("Error in mod note recording!");
                        let n = -1;
                        for (let t = 0; t < i.pins.length; t++) {
                            if (i.pins[t].time <= n)
                                throw new Error("Error in mod note recording!");
                            n = i.pins[t].time
                        }
                    }
                }
            }
            return this.m.channel >= this.m.song.pitchChannelCount + this.m.song.noiseChannelCount && (this.m.currentPatternIsDirty = !0),
            f.length > 0 && (this.m.continuingModRecordingChange = new An(this.m,t,f,b)),
            a
        }
        stopEditingModLabel(t) {
            if (this.editingModLabel) {
                if (this.editingModLabel = !1,
                this.modDragValueLabel.style.setProperty("pointer-events", "none"),
                window.getSelection) {
                    let t = window.getSelection();
                    null != t && t.removeAllRanges()
                }
                if (t) {
                    this.dl.size = this.Eh;
                    let t = this.Eh + p.modulators[this.pl].convertRealFactor
                      , e = +(t >= 10) + +(t >= 100) + +(t < 0) + +(t <= -10);
                    this.Fh = +q(Math.max(Math.min(this.u - 10 - 8 * e, this.ll * (this.cl.start + this.dl.time) - 4 - 4 * e), 2)),
                    this.modDragValueLabel.style.setProperty("left", this.Fh + "px");
                    const i = new Xt;
                    this.Bi = i,
                    this.m.setProspectiveChange(this.Bi),
                    i.append(new zn(this.m,this.cl,this.dl.time,this.Eh,this.dl.interval,this.shiftMode)),
                    this.Bi = null
                }
                this.m.lastChangeWas(this.Bi) && null != this.Bi && (this.m.record(this.Bi),
                this.Bi = null)
            }
        }
        Ri() {
            if (this.m.song.getChannelIsMod(this.m.channel) && "none" != this.modDragValueLabel.style.getPropertyValue("display") && this.N > +this.Fh - 6 && this.N < +this.Fh + this.Ah + 6 && this.Ze > +this.Ch - 8 && this.Ze < +this.Ch + 11) {
                if (this.modDragValueLabel.style.setProperty("pointer-events", "fill"),
                this.modDragValueLabel.setAttribute("contenteditable", "true"),
                window.getSelection) {
                    let t = window.getSelection();
                    null != t && t.selectAllChildren(this.modDragValueLabel)
                }
                window.setTimeout(( () => {
                    this.modDragValueLabel.focus()
                }
                )),
                this.editingModLabel = !0
            } else {
                this.stopEditingModLabel(!1),
                this.m.prefs.enableNotePreview && this.m.synth.maintainLiveInput(),
                this.O = !0,
                this.ra = this.N,
                this.zh = this.Ze,
                this.ur(),
                this.j();
                const t = new Xt;
                if (this.Bi = t,
                this.Uh = this.m.lastChangeWas(this.jh),
                this.m.setProspectiveChange(this.Bi),
                this.El())
                    this.Rh = !0;
                else if (this.Tl())
                    this.$h = !0;
                else if (this.Nh)
                    if (this.m.selection.patternSelectionActive && -1 == this.nr.pitchIndex || this.Al())
                        t.append(new Fn(this.m,0,0));
                    else if (null != this.nr.curNote)
                        t.append(new Fn(this.m,this.nr.curNote.start,this.nr.curNote.end));
                    else {
                        const e = Math.max(0, Math.min((this.m.song.beatsPerBar - 1) * p.partsPerBeat, Math.floor(this.nr.exactPart / p.partsPerBeat) * p.partsPerBeat))
                          , i = e + p.partsPerBeat;
                        t.append(new Fn(this.m,e,i))
                    }
                else if (this.Al())
                    this.Hh = !0;
                else if (this.nr.valid && null == this.nr.curNote) {
                    t.append(new Fn(this.m,0,0));
                    const e = new Tt(this.nr.pitch,this.nr.start,this.nr.end,p.noteSizeMax,this.m.song.getChannelIsNoise(this.m.channel));
                    e.pins = [];
                    for (const t of this.nr.pins)
                        e.pins.push(Et(0, t.time, t.size));
                    t.append(new Ji(this.m,this.m.channel,this.m.bar));
                    const i = this.m.getCurrentPattern(this.dh);
                    if (null == i)
                        throw new Error;
                    if (t.append(new gn(this.m,i,e,this.nr.curIndex)),
                    this.m.prefs.enableNotePreview && !this.m.synth.playing) {
                        const t = Math.min(p.partsPerBeat, this.nr.end - this.nr.start);
                        this.m.performance.setTemporaryPitches([this.nr.pitch], t)
                    }
                }
                this.Bl()
            }
        }
        X() {
            this.m.prefs.enableNotePreview && this.R && this.m.synth.maintainLiveInput();
            const t = this.m.lastChangeWas(this.Bi);
            if (!this.Si && this.O && this.nr.valid && t) {
                const t = this.N - this.ra
                  , e = this.Ze - this.zh;
                Math.sqrt(t * t + e * e) > 5 && (this.Si = !0,
                this.Ih = Math.abs(t) >= Math.abs(e))
            }
            if (this.Nh && this.Ih && Math.abs(this.ra - this.N) > 5 && (this.Oh = !0),
            this.Si && this.O && this.nr.valid && t) {
                this.Bi.undo();
                const t = new Xt;
                this.Bi = t,
                this.m.setProspectiveChange(this.Bi);
                const e = this.vl()
                  , i = this.xl(this.N / this.ll);
                if (this.Rh)
                    t.append(new Fn(this.m,Math.max(0, Math.min(this.m.song.beatsPerBar * p.partsPerBeat, i)),this.m.selection.patternSelectionEnd)),
                    this.Bl();
                else if (this.$h)
                    t.append(new Fn(this.m,this.m.selection.patternSelectionStart,Math.max(0, Math.min(this.m.song.beatsPerBar * p.partsPerBeat, i)))),
                    this.Bl();
                else if (this.Hh) {
                    const t = this.m.getCurrentPattern(this.dh);
                    if (this.Si && null != t) {
                        this.Bi.undo();
                        const i = new Xt;
                        this.Bi = i,
                        this.m.setProspectiveChange(this.Bi);
                        const n = (this.m.song.scale == p.scales.dictionary.Custom.index ? this.m.song.scaleCustom : p.scales[this.m.song.scale].flags).filter((t => t)).length
                          , s = this.m.song.getChannelIsNoise(this.m.channel) ? 1 : 12 / n
                          , o = Math.round((this.N - this.ra) / (this.ll * e)) * e
                          , a = Math.round((this.zh - this.Ze) / (this.Bh * s));
                        i.append(new Cn(this.m,this.m.channel,t,o,a))
                    }
                } else if (this.Nh && this.Oh) {
                    if (this.Si) {
                        let e = Math.max(0, Math.min((this.m.song.beatsPerBar - 1) * p.partsPerBeat, Math.floor(this.nr.exactPart / p.partsPerBeat) * p.partsPerBeat))
                          , n = e + p.partsPerBeat;
                        if (null != this.nr.curNote && (e = Math.max(e, this.nr.curNote.start),
                        n = Math.min(n, this.nr.curNote.end)),
                        i < e) {
                            e = 0;
                            const t = this.m.getCurrentPattern(this.dh);
                            if (null != t)
                                for (let n = 0; n < t.notes.length; n++)
                                    t.notes[n].start <= i && (e = t.notes[n].start),
                                    t.notes[n].end <= i && (e = t.notes[n].end);
                            for (let t = 0; t <= this.m.song.beatsPerBar; t++) {
                                const n = t * p.partsPerBeat;
                                e <= n && n <= i && (e = n)
                            }
                        }
                        if (i > n) {
                            n = p.partsPerBeat * this.m.song.beatsPerBar;
                            const t = this.m.getCurrentPattern(this.dh);
                            if (null != t)
                                for (let e = 0; e < t.notes.length; e++) {
                                    if (t.notes[e].start >= i) {
                                        n = t.notes[e].start;
                                        break
                                    }
                                    if (t.notes[e].end >= i) {
                                        n = t.notes[e].end;
                                        break
                                    }
                                }
                            for (let t = 0; t <= this.m.song.beatsPerBar; t++) {
                                const e = t * p.partsPerBeat;
                                i < e && e < n && (n = e)
                            }
                        }
                        t.append(new Fn(this.m,e,n)),
                        this.Bl()
                    }
                } else if (null == this.nr.curNote) {
                    let n, s;
                    t.append(new Fn(this.m,0,0)),
                    i < this.nr.start ? (n = !0,
                    s = this.nr.start - i) : (n = !1,
                    s = i - this.nr.start + e);
                    let o, a, r = e;
                    for (let t = e; t <= this.m.song.beatsPerBar * p.partsPerBeat; t += e) {
                        if (1 == e) {
                            if (t < 5)
                                ;
                            else if (t <= p.partsPerBeat / 2) {
                                if (t % 3 != 0 && t % 4 != 0)
                                    continue
                            } else if (t <= 1.5 * p.partsPerBeat) {
                                if (t % 6 != 0 && t % 8 != 0)
                                    continue
                            } else if (t % p.partsPerBeat != 0)
                                continue
                        } else if (t >= 5 * e && t % p.partsPerBeat != 0 && t != 3 * p.partsPerBeat / 4 && t != 3 * p.partsPerBeat / 2 && t != 4 * p.partsPerBeat / 3)
                            continue;
                        const i = t;
                        if (i == s) {
                            r = i;
                            break
                        }
                        if (i < s && (r = i),
                        i > s) {
                            r < s - e && (r = i);
                            break
                        }
                    }
                    n ? (a = this.nr.start,
                    o = a - r) : (o = this.nr.start,
                    a = o + r);
                    const h = o < 0 && this.m.channel < this.m.song.pitchChannelCount + this.m.song.noiseChannelCount;
                    if (o < 0 && (o = 0),
                    a > this.m.song.beatsPerBar * p.partsPerBeat && (a = this.m.song.beatsPerBar * p.partsPerBeat),
                    o < a) {
                        t.append(new Ji(this.m,this.m.channel,this.m.bar));
                        const e = this.m.getCurrentPattern(this.dh);
                        if (null == e)
                            throw new Error;
                        let i;
                        for (t.append(new vn(this.m,e,o,a,new Tt(this.nr.pitch,0,0,0))),
                        i = 0; i < e.notes.length && !(e.notes[i].start >= a); i++)
                            ;
                        const s = new Tt(this.nr.pitch,o,a,this.m.song.getNewNoteVolume(this.m.song.getChannelIsMod(this.m.channel), this.m.channel, this.m.getCurrentInstrument(this.dh), this.nr.pitch),this.m.song.getChannelIsNoise(this.m.channel));
                        s.continuesLastPattern = h,
                        t.append(new gn(this.m,e,s,i)),
                        this.gl(s),
                        this._h = n ? o : a,
                        this.Vh = this.nr.pitch,
                        this.Gh = s.pins[n ? 0 : 1].size,
                        this.Wh = !0
                    }
                    let l = this.Le;
                    this.Le = this.m.getCurrentPattern(this.dh),
                    null != this.Le && this.m.song.getChannelIsMod(this.m.channel) && this.lh && l != this.Le && this.Le.notes.sort((function(t, e) {
                        return t.start == e.start ? t.pitches[0] - e.pitches[0] : t.start - e.start
                    }
                    ))
                } else if (this.Ih) {
                    t.append(new Fn(this.m,0,0));
                    const i = (this.N - this.ra) / this.ll
                      , n = this.nr.curNote.pins[this.nr.nearPinIndex];
                    let s = Math.round((this.nr.curNote.start + n.time + i) / e) * e;
                    const o = s < 0 && this.m.channel < this.m.song.pitchChannelCount + this.m.song.noiseChannelCount;
                    if (s < 0 && (s = 0),
                    s > this.m.song.beatsPerBar * p.partsPerBeat && (s = this.m.song.beatsPerBar * p.partsPerBeat),
                    null == this.Le)
                        throw new Error;
                    if (s <= this.nr.curNote.start && this.nr.nearPinIndex == this.nr.curNote.pins.length - 1 || s >= this.nr.curNote.end && 0 == this.nr.nearPinIndex)
                        t.append(new gn(this.m,this.Le,this.nr.curNote,this.nr.curIndex,!0)),
                        this.Wh = !1;
                    else {
                        const e = Math.min(this.nr.curNote.start, s)
                          , i = Math.max(this.nr.curNote.end, s);
                        this._h = s,
                        this.Vh = this.nr.curNote.pitches[-1 == this.nr.pitchIndex ? 0 : this.nr.pitchIndex] + this.nr.curNote.pins[this.nr.nearPinIndex].interval,
                        this.Gh = this.nr.curNote.pins[this.nr.nearPinIndex].size,
                        this.Wh = !0,
                        t.append(new vn(this.m,this.Le,e,i,this.nr.curNote)),
                        t.append(new Yi(this.m,this.nr.curNote,this.nr.nearPinIndex,s,o)),
                        this.gl(this.nr.curNote)
                    }
                } else if (-1 == this.nr.pitchIndex || this.m.song.getChannelIsMod(this.m.channel)) {
                    this.Si || t.append(new Fn(this.m,0,0));
                    const i = Math.max(this.nr.curNote.start, Math.min(this.nr.curNote.end, Math.round(this.N / (this.ll * e)) * e)) - this.nr.curNote.start;
                    let n, s = this.nr.curNote.pins[0], o = 0, a = 0, r = this.m.song.getVolumeCap(this.m.song.getChannelIsMod(this.m.channel), this.m.channel, this.m.getCurrentInstrument(this.dh), this.nr.pitch), h = 25 / Math.pow(r, .4), l = 22 / Math.pow(r, .5), c = this.zh > this.Ze ? 1 : -1, d = Math.min(Math.abs(this.zh - this.Ze) / h, 8) + Math.max(0, Math.abs(this.zh - this.Ze) / l - 8);
                    d > 0 && (this.Nh = !1);
                    for (let t = 1; t < this.nr.curNote.pins.length; t++) {
                        if (n = s,
                        s = this.nr.curNote.pins[t],
                        i > s.time)
                            continue;
                        if (i < n.time)
                            throw new Error;
                        const e = (i - n.time) / (s.time - n.time);
                        o = Math.round(n.size * (1 - e) + s.size * e + c * d),
                        this.controlMode || this.m.prefs.alwaysFineNoteVol || this.m.song.getChannelIsMod(this.m.channel) || (o = 2 * Math.floor(o / 2)),
                        o < 0 && (o = 0),
                        o > r && (o = r),
                        a = this.Fl(n.interval * (1 - e) + s.interval * e + this.nr.curNote.pitches[0], 0, this.wl()) - this.nr.curNote.pitches[0];
                        break
                    }
                    if (this.m.song.getChannelIsMod(this.m.channel) && this.controlMode)
                        if (i >= this.nr.curNote.pins[this.nr.curNote.pins.length - 1].time)
                            if (this.nr.curNote.start + this.nr.curNote.pins[this.nr.curNote.pins.length - 1].time < this.m.song.beatsPerBar * p.partsPerBeat)
                                for (const e of this.Le.notes)
                                    e.start == this.nr.curNote.start + this.nr.curNote.pins[this.nr.curNote.pins.length - 1].time && e.pitches[0] == this.nr.curNote.pitches[0] && t.append(new zn(this.m,e,e.pins[0].time,o,a,this.shiftMode));
                            else {
                                const e = this.m.getCurrentPattern(1);
                                if (null != e && e.instruments[0] == this.Le.instruments[0])
                                    for (const i of e.notes)
                                        0 == i.start && i.pitches[0] == this.nr.curNote.pitches[0] && t.append(new zn(this.m,i,i.pins[0].time,o,a,this.shiftMode))
                            }
                        else if (i <= this.nr.curNote.pins[0].time)
                            if (this.nr.curNote.start > 0)
                                for (const e of this.Le.notes)
                                    e.end == this.nr.curNote.start && e.pitches[0] == this.nr.curNote.pitches[0] && t.append(new zn(this.m,e,e.pins[e.pins.length - 1].time,o,a,this.shiftMode));
                            else {
                                const e = this.m.getCurrentPattern(-1);
                                if (null != e && e.instruments[0] == this.Le.instruments[0])
                                    for (const i of e.notes)
                                        i.end == this.m.song.beatsPerBar * p.partsPerBeat && i.pitches[0] == this.nr.curNote.pitches[0] && t.append(new zn(this.m,i,i.pins[i.pins.length - 1].time,o,a,this.shiftMode))
                            }
                    this._h = this.nr.curNote.start + i,
                    this.Vh = this.nr.curNote.pitches[-1 == this.nr.pitchIndex ? 0 : this.nr.pitchIndex] + a,
                    this.Gh = o,
                    this.Wh = !0,
                    t.append(new zn(this.m,this.nr.curNote,i,o,a,this.shiftMode)),
                    this.gl(this.nr.curNote)
                } else {
                    if (t.append(new Fn(this.m,0,0)),
                    this.Gh = this.nr.curNote.pins[this.nr.nearPinIndex].size,
                    null == this.Le)
                        throw new Error;
                    let n, s;
                    this.N >= this.ra ? (n = Math.max(this.nr.curNote.start, this.nr.part),
                    s = i + e) : (n = Math.min(this.nr.curNote.end, this.nr.part + e),
                    s = i),
                    s < 0 && (s = 0),
                    s > this.m.song.beatsPerBar * p.partsPerBeat && (s = this.m.song.beatsPerBar * p.partsPerBeat),
                    s > this.nr.curNote.end && t.append(new vn(this.m,this.Le,this.nr.curNote.start,s,this.nr.curNote)),
                    s < this.nr.curNote.start && t.append(new vn(this.m,this.Le,s,this.nr.curNote.end,this.nr.curNote));
                    let o = Number.MAX_VALUE
                      , a = -Number.MAX_VALUE;
                    for (const t of this.nr.curNote.pitches)
                        o > t && (o = t),
                        a < t && (a = t);
                    if (o -= this.nr.curNote.pitches[this.nr.pitchIndex],
                    a -= this.nr.curNote.pitches[this.nr.pitchIndex],
                    this.m.song.getChannelIsMod(this.m.channel)) {
                        const e = this.Fl(this.Vh, -o, p.modCount - 1);
                        t.append(new Qi(this.m,this.nr.curNote,n,s,e,this.nr.pitchIndex)),
                        this.Vh = e
                    } else {
                        const e = this.Fl(this.kl(this.Ze), -o, this.wl() - a);
                        t.append(new Qi(this.m,this.nr.curNote,n,s,e,this.nr.pitchIndex)),
                        this.Vh = e
                    }
                    this.gl(this.nr.curNote),
                    this._h = s,
                    this.Wh = !0
                }
            }
            this.O && this.nr.valid && t || (this.ur(),
            this.j())
        }
        bl(t) {
            this.jh = t,
            this.m.record(this.jh, this.Uh)
        }
        j() {
            if (this.Lh)
                if (!this.O || !this.nr.valid || !this.Si || !this.Wh || this.Nh || this.Rh || this.$h || this.Hh)
                    this.wh.setAttribute("visibility", "hidden"),
                    this.editingModLabel || (this.modDragValueLabel.style.setProperty("display", "none"),
                    this.modDragValueLabel.style.setProperty("pointer-events", "none"),
                    this.modDragValueLabel.setAttribute("contenteditable", "false"));
                else {
                    this.wh.setAttribute("visibility", "visible");
                    const t = this.ll * this._h
                      , e = this.Ml(this.Vh - this.Yh)
                      , i = (this.Bh - this.Sl) / 2
                      , n = 80
                      , s = 60
                      , o = this.m.song.getVolumeCap(this.m.song.getChannelIsMod(this.m.channel), this.m.channel, this.m.getCurrentInstrument(this.dh), this.nr.pitch);
                    let a = "";
                    a += "M " + q(t) + " " + q(e - i * (this.Gh / o)) + " ",
                    a += "L " + q(t) + " " + q(e - i * (this.Gh / o) - s) + " ",
                    a += "M " + q(t) + " " + q(e + i * (this.Gh / o)) + " ",
                    a += "L " + q(t) + " " + q(e + i * (this.Gh / o) + s) + " ",
                    a += "M " + q(t) + " " + q(e - i * (this.Gh / o)) + " ",
                    a += "L " + q(t + n) + " " + q(e - i * (this.Gh / o)) + " ",
                    a += "M " + q(t) + " " + q(e + i * (this.Gh / o)) + " ",
                    a += "L " + q(t + n) + " " + q(e + i * (this.Gh / o)) + " ",
                    a += "M " + q(t) + " " + q(e - i * (this.Gh / o)) + " ",
                    a += "L " + q(t - n) + " " + q(e - i * (this.Gh / o)) + " ",
                    a += "M " + q(t) + " " + q(e + i * (this.Gh / o)) + " ",
                    a += "L " + q(t - n) + " " + q(e + i * (this.Gh / o)) + " ",
                    this.wh.setAttribute("d", a)
                }
            else if (this.R && !this.O && this.nr.valid)
                if (this.wh.setAttribute("visibility", "visible"),
                this.El()) {
                    const t = this.ll * this.m.selection.patternSelectionStart
                      , e = q(t - 4)
                      , i = q(t + 4)
                      , n = this.Ml(-.5);
                    this.wh.setAttribute("d", "M " + e + " 0 L " + e + " " + n + " L " + i + " " + n + " L " + i + " 0 z")
                } else if (this.Tl()) {
                    const t = this.ll * this.m.selection.patternSelectionEnd
                      , e = q(t - 4)
                      , i = q(t + 4)
                      , n = this.Ml(-.5);
                    this.wh.setAttribute("d", "M " + e + " 0 L " + e + " " + n + " L " + i + " " + n + " L " + i + " 0 z")
                } else if (this.Al()) {
                    const t = q(this.ll * this.m.selection.patternSelectionStart - 2)
                      , e = q(this.ll * this.m.selection.patternSelectionEnd + 2)
                      , i = this.Ml(-.5);
                    this.wh.setAttribute("d", "M " + t + " 0 L " + t + " " + i + " L " + e + " " + i + " L " + e + " 0 z")
                } else
                    this.Il(this.wh, this.nr.pitch, this.nr.start, this.nr.pins, (this.Bh - this.Sl) / 2 + 1, !0, this.Yh);
            else
                this.wh.setAttribute("visibility", "hidden"),
                this.editingModLabel || (this.modDragValueLabel.style.setProperty("display", "none"),
                this.modDragValueLabel.style.setProperty("pointer-events", "none"),
                this.modDragValueLabel.setAttribute("contenteditable", "false"))
        }
        Bl() {
            this.m.selection.patternSelectionActive ? (this.gh.setAttribute("visibility", "visible"),
            this.gh.setAttribute("x", String(this.ll * this.m.selection.patternSelectionStart)),
            this.gh.setAttribute("width", String(this.ll * (this.m.selection.patternSelectionEnd - this.m.selection.patternSelectionStart)))) : this.gh.setAttribute("visibility", "hidden")
        }
        render() {
            const t = this.m.getCurrentPattern(this.dh);
            if (this.Le != t && (this.m.song.getChannelIsMod(this.m.channel) && this.lh && null != t && t.notes.sort((function(t, e) {
                return t.start == e.start ? t.pitches[0] - e.pitches[0] : t.start - e.start
            }
            )),
            null != this.Le && (this.Bi = null,
            this.et(null))),
            this.Le = t,
            this.u = this.container.clientWidth,
            this.v = this.container.clientHeight,
            this.ll = this.u / (this.m.song.beatsPerBar * p.partsPerBeat),
            this.Yh = this.m.channel >= this.m.song.pitchChannelCount ? 0 : this.m.song.channels[this.m.channel].octave * p.pitchesPerOctave,
            this.m.song.getChannelIsNoise(this.m.channel))
                this.Sl = 0,
                this.Pl = p.drumCount;
            else if (this.m.song.getChannelIsMod(this.m.channel)) {
                if (this.Sl = this.xh,
                this.Pl = p.modCount,
                null != this.Le)
                    for (const t of this.Le.notes) {
                        let e = t.pitches[0]
                          , i = this.m.song.getVolumeCap(!0, this.m.channel, this.m.getCurrentInstrument(this.dh), e)
                          , n = 0;
                        for (const e of t.pins)
                            e.size > n && (n = e.size);
                        if (n > i)
                            for (const e of t.pins)
                                e.size = Math.round(e.size * (i / n))
                    }
            } else
                this.Sl = 0,
                this.Pl = this.m.getVisiblePitchCount();
            this.Bh = this.v / this.Pl,
            this.Yh = this.m.channel >= this.m.song.pitchChannelCount ? 0 : this.m.getBaseVisibleOctave(this.m.channel) * p.pitchesPerOctave,
            this.nl == this.m.song.rhythm && this.sl == this.m.song.pitchChannelCount && this.ol == this.m.song.noiseChannelCount && this.al == this.m.song.modChannelCount || (this.nl = this.m.song.rhythm,
            this.sl = this.m.song.pitchChannelCount,
            this.ol = this.m.song.noiseChannelCount,
            this.al = this.m.song.modChannelCount,
            this.resetCopiedPins()),
            this.Cl = this.Dh[this.m.channel],
            this.Qh == this.u && this.Zh == this.v || (this.Qh = this.u,
            this.Zh = this.v,
            this.fh.setAttribute("width", "" + this.u),
            this.fh.setAttribute("height", "" + this.v),
            this.bh.setAttribute("height", "" + this.v),
            this.gh.setAttribute("y", "0"),
            this.gh.setAttribute("height", "" + this.v));
            const e = this.u / this.m.song.beatsPerBar;
            if (this.Xh != e || this.tl != this.Bh) {
                this.Xh = e,
                this.tl = this.Bh,
                this.ph.setAttribute("width", "" + e),
                this.ph.setAttribute("height", "" + this.Bh * p.pitchesPerOctave),
                this.mh.setAttribute("width", "" + e),
                this.mh.setAttribute("height", "" + this.Bh),
                this.uh.setAttribute("width", "" + e),
                this.uh.setAttribute("height", "" + this.Bh),
                this.uh.setAttribute("y", "" + this.Sl / 2),
                this.Mh.setAttribute("width", "" + (e - 2)),
                this.Mh.setAttribute("height", "" + (this.Bh - 2)),
                this.Bh > this.Sl && (this.Sh.setAttribute("width", "" + (e - 2)),
                this.Sh.setAttribute("height", "" + (this.Bh - this.Sl)));
                for (let t = 0; t < p.pitchesPerOctave; t++) {
                    const i = this.kh[t]
                      , n = (p.pitchesPerOctave - t) % p.pitchesPerOctave;
                    i.setAttribute("width", "" + (e - 2)),
                    i.setAttribute("y", "" + (n * this.Bh + 1)),
                    i.setAttribute("height", "" + (this.Bh - 2))
                }
            }
            this.lh && (this.O || this.ur(),
            this.j(),
            this.Bl()),
            this.Ao != this.m.prefs.showFifth && (this.Ao = this.m.prefs.showFifth,
            this.kh[7].setAttribute("fill", this.m.prefs.showFifth ? nt.fifthNote : nt.pitchBackground));
            for (let t = 0; t < p.pitchesPerOctave; t++) {
                let e = this.m.song.scale == p.scales.dictionary.Custom.index ? this.m.song.scaleCustom : p.scales[this.m.song.scale].flags;
                this.kh[t].style.visibility = e[t] ? "visible" : "hidden"
            }
            this.m.song.getChannelIsNoise(this.m.channel) ? this.el || (this.el = !0,
            this.il = !1,
            this.fh.setAttribute("fill", "url(#patternEditorDrumBackground" + this.dh + ")")) : this.m.song.getChannelIsMod(this.m.channel) ? this.il || (this.el = !1,
            this.il = !0,
            this.fh.setAttribute("fill", "url(#patternEditorModBackground" + this.dh + ")")) : (this.el || this.il) && (this.el = !1,
            this.il = !1,
            this.fh.setAttribute("fill", "url(#patternEditorNoteBackground" + this.dh + ")")),
            this.yl()
        }
        yl() {
            if (this.yh = function(t) {
                const e = t.cloneNode(!1);
                return t.parentNode.replaceChild(e, t),
                e
            }(this.yh),
            this.m.prefs.showChannels && !this.m.song.getChannelIsMod(this.m.channel)) {
                let t = "#ffffff77";
                this.m.prefs.notesFlashWhenPlayed && (t = nt.getComputed("--note-flash-secondary"));
                for (let e = this.m.song.pitchChannelCount + this.m.song.noiseChannelCount - 1; e >= 0; e--) {
                    if (e == this.m.channel)
                        continue;
                    if (this.m.song.getChannelIsNoise(e) != this.m.song.getChannelIsNoise(this.m.channel))
                        continue;
                    const i = this.m.song.getPattern(e, this.m.bar + this.dh);
                    if (null == i)
                        continue;
                    const n = this.m.getBaseVisibleOctave(e) * p.pitchesPerOctave;
                    for (const s of i.notes)
                        for (const i of s.pitches) {
                            let o = Y.path();
                            o.setAttribute("fill", nt.getChannelColor(this.m.song, e).secondaryNote),
                            o.setAttribute("pointer-events", "none"),
                            this.Il(o, i, s.start, s.pins, .19 * this.Bh, !1, n),
                            this.yh.appendChild(o),
                            this.m.prefs.notesFlashWhenPlayed && (o = Y.path(),
                            o.setAttribute("fill", t),
                            o.setAttribute("pointer-events", "none"),
                            this.Il(o, i, s.start, s.pins, .19 * this.Bh, !1, n),
                            this.yh.appendChild(o),
                            o.classList.add("note-flash"),
                            o.style.opacity = "0",
                            o.setAttribute("note-start", String(s.start)),
                            o.setAttribute("note-end", String(s.end)))
                        }
                }
            }
            if (null != this.Le) {
                const t = this.m.song.channels[this.m.channel].instruments[this.m.getCurrentInstrument(this.dh)]
                  , e = t.getChord()
                  , i = t.getTransition()
                  , n = e.customInterval || e.arpeggiates || e.strumParts > 0 || i.slides;
                let s = "#ffffff";
                this.m.prefs.notesFlashWhenPlayed && (s = nt.getComputed("--note-flash"));
                for (const e of this.Le.notes) {
                    let i = !1;
                    if (this.m.song.getChannelIsMod(this.m.channel)) {
                        (t.modulators[p.modCount - 1 - e.pitches[0]] == p.modulators.dictionary.none.index || t.invalidModulators[p.modCount - 1 - e.pitches[0]]) && (i = !0)
                    }
                    for (let t = 0; t < e.pitches.length; t++) {
                        const o = e.pitches[t];
                        let a = Y.path()
                          , r = i ? nt.disabledNotePrimary : nt.getChannelColor(this.m.song, this.m.channel).primaryNote
                          , h = i ? nt.disabledNoteSecondary : nt.getChannelColor(this.m.song, this.m.channel).secondaryNote;
                        a.setAttribute("fill", h),
                        a.setAttribute("pointer-events", "none"),
                        this.Il(a, o, e.start, e.pins, (this.Bh - this.Sl) / 2 + 1, !1, this.Yh),
                        this.yh.appendChild(a),
                        a = Y.path(),
                        a.setAttribute("fill", r),
                        a.setAttribute("pointer-events", "none"),
                        this.Il(a, o, e.start, e.pins, (this.Bh - this.Sl) / 2 + 1, !0, this.Yh),
                        this.yh.appendChild(a),
                        this.m.prefs.notesFlashWhenPlayed && !i && (a = Y.path(),
                        a.setAttribute("fill", s),
                        a.setAttribute("pointer-events", "none"),
                        this.Il(a, o, e.start, e.pins, (this.Bh - this.Sl) / 2 + 1, !0, this.Yh),
                        this.yh.appendChild(a),
                        a.classList.add("note-flash"),
                        a.style.opacity = "0",
                        a.setAttribute("note-start", String(e.start)),
                        a.setAttribute("note-end", String(e.end)));
                        let l = 2;
                        if (e.continuesLastPattern) {
                            const t = Math.min(this.Bh, 20);
                            let i;
                            i = "M " + q(this.ll * e.start + l) + " " + q(this.Ml(o - this.Yh) - .1 * t),
                            i += "L " + q(this.ll * e.start + l) + " " + q(this.Ml(o - this.Yh) + .1 * t),
                            i += "L " + q(this.ll * e.start + l + 4) + " " + q(this.Ml(o - this.Yh) + .1 * t),
                            i += "L " + q(this.ll * e.start + l + 4) + " " + q(this.Ml(o - this.Yh) + .3 * t),
                            i += "L " + q(this.ll * e.start + l + 12) + " " + q(this.Ml(o - this.Yh)),
                            i += "L " + q(this.ll * e.start + l + 4) + " " + q(this.Ml(o - this.Yh) - .3 * t),
                            i += "L " + q(this.ll * e.start + l + 4) + " " + q(this.Ml(o - this.Yh) - .1 * t);
                            const n = Y.path();
                            n.setAttribute("d", i),
                            n.setAttribute("fill", nt.invertedText),
                            this.yh.appendChild(n),
                            l += 12
                        }
                        if (e.pitches.length > 1 && n) {
                            const i = Y.text();
                            i.setAttribute("x", "" + q(this.ll * e.start + l)),
                            i.setAttribute("y", "" + q(this.Ml(o - this.Yh))),
                            i.setAttribute("width", "30"),
                            i.setAttribute("fill", nt.invertedText),
                            i.setAttribute("text-anchor", "start"),
                            i.setAttribute("dominant-baseline", "central"),
                            i.setAttribute("pointer-events", "none"),
                            i.textContent = "" + (t + 1),
                            this.yh.appendChild(i)
                        }
                    }
                    if (this.m.song.getChannelIsMod(this.m.channel) && this.Si && !this.Ih && e == this.nr.curNote) {
                        this.modDragValueLabel.style.setProperty("display", ""),
                        this.modDragValueLabel.style.setProperty("pointer-events", "none"),
                        this.modDragValueLabel.setAttribute("contenteditable", "false"),
                        this.modDragValueLabel.style.setProperty("color", "#FFFFFF");
                        let t = this.m.song.channels[this.m.channel].instruments[this.m.getCurrentInstrument(this.dh)].modulators[p.modCount - 1 - e.pitches[0]]
                          , i = this.Gh + p.modulators[t].convertRealFactor
                          , n = +(i >= 10) + +(i >= 100) + +(i < 0) + +(i <= -10);
                        this.Ah = 8 + 8 * n,
                        this.Fh = +q(Math.max(Math.min(this.u - 10 - 8 * n, this.ll * this._h - 4 - 4 * n), 2)),
                        this.Ch = +q(this.Ml(e.pitches[0] - this.Yh) - 17 - (this.Bh - this.Sl) / 2),
                        this.modDragValueLabel.style.setProperty("left", this.Fh + "px"),
                        this.modDragValueLabel.style.setProperty("top", this.Ch + "px"),
                        this.modDragValueLabel.textContent = "" + i
                    }
                }
            }
            this.m.currentPatternIsDirty = !1
        }
        Il(t, e, i, n, s, o, a) {
            const r = this.ll * (n[n.length - 1].time + n[0].time)
              , h = .5 * Math.min(2, r - 1);
            let l = n[0];
            const c = this.m.song.getVolumeCap(this.m.song.getChannelIsMod(this.m.channel), this.m.channel, this.m.getCurrentInstrument(this.dh), e);
            let d = "M " + q(this.ll * (i + l.time) + h) + " " + q(this.Ml(e - a) + s * (o ? l.size / c : 1)) + " ";
            for (let t = 1; t < n.length; t++) {
                let r = l;
                l = n[t];
                let p = this.ll * (i + r.time) + (1 == t ? h : 0)
                  , m = this.ll * (i + l.time) - (t == n.length - 1 ? h : 0)
                  , u = this.Ml(e + r.interval - a)
                  , f = this.Ml(e + l.interval - a)
                  , y = o ? r.size / c : 1
                  , b = o ? l.size / c : 1;
                d += "L " + q(p) + " " + q(u - s * y) + " ",
                r.interval > l.interval && (d += "L " + q(p + 1) + " " + q(u - s * y) + " "),
                r.interval < l.interval && (d += "L " + q(m - 1) + " " + q(f - s * b) + " "),
                d += "L " + q(m) + " " + q(f - s * b) + " "
            }
            for (let t = n.length - 2; t >= 0; t--) {
                let r = l;
                l = n[t];
                let p = this.ll * (i + r.time) - (t == n.length - 2 ? h : 0)
                  , m = this.ll * (i + l.time) + (0 == t ? h : 0)
                  , u = this.Ml(e + r.interval - a)
                  , f = this.Ml(e + l.interval - a)
                  , y = o ? r.size / c : 1
                  , b = o ? l.size / c : 1;
                d += "L " + q(p) + " " + q(u + s * y) + " ",
                r.interval < l.interval && (d += "L " + q(p - 1) + " " + q(u + s * y) + " "),
                r.interval > l.interval && (d += "L " + q(m + 1) + " " + q(f + s * b) + " "),
                d += "L " + q(m) + " " + q(f + s * b) + " "
            }
            d += "z",
            t.setAttribute("d", d)
        }
        Ml(t) {
            return this.Bh * (this.Pl - t - .5)
        }
    }
    class ra {
        forceRender() {
            this.Ll = -1,
            this.gr()
        }
        static getBassCutoffPitch(t) {
            return t.getBaseVisibleOctave(t.channel) * p.pitchesPerOctave + Math.floor(t.getVisiblePitchCount() / (2 * p.pitchesPerOctave)) * p.pitchesPerOctave
        }
        constructor(t) {
            this.m = t,
            this.Dl = J.div({
                style: "width: 100%; height: 100%; display: flex; flex-direction: column-reverse; align-items: stretch;"
            }),
            this.zl = J.div({
                style: "width: 100%; height: 100%; display: flex; flex-direction: column-reverse; align-items: stretch;"
            }),
            this.ql = J.div({
                style: "width: 100%; height: 100%; display: flex; flex-direction: column-reverse; align-items: stretch;"
            }),
            this.Nl = J.div({
                style: `width: 100%; height: 40px; border: 2px solid ${nt.primaryText}; position: absolute; box-sizing: border-box; pointer-events: none;`
            }),
            this.container = J.div({
                style: "width: 32px; height: 100%; overflow: hidden; position: relative; flex-shrink: 0; touch-action: none;"
            }, this.Dl, this.zl, this.ql, this.Nl),
            this.v = 481,
            this.Ol = [],
            this.Rl = [],
            this.$l = [],
            this.Hl = [],
            this._l = [],
            this.Vl = [],
            this.Ze = 0,
            this.O = !1,
            this.R = !1,
            this.Gl = -1,
            this.Ll = -1,
            this.el = !1,
            this.il = !1,
            this.Wl = -1,
            this.jl = -1,
            this.Ul = [],
            this.W = t => {
                this.R || (this.R = !0,
                this.j())
            }
            ,
            this.U = t => {
                this.R && (this.R = !1,
                this.j())
            }
            ,
            this.K = t => {
                t.preventDefault(),
                this.m.synth.maintainLiveInput(),
                this.O = !0;
                const e = this.container.getBoundingClientRect();
                this.Ze = ((t.clientY || t.pageY) - e.top) * this.v / (e.bottom - e.top),
                isNaN(this.Ze) && (this.Ze = 0),
                this.Kl(),
                this.Jl(),
                this.j()
            }
            ,
            this.Z = t => {
                (this.O || this.R) && this.m.synth.maintainLiveInput();
                const e = this.container.getBoundingClientRect();
                this.Ze = ((t.clientY || t.pageY) - e.top) * this.v / (e.bottom - e.top),
                isNaN(this.Ze) && (this.Ze = 0),
                this.Kl(),
                this.O && this.Jl(),
                this.j()
            }
            ,
            this.Yl = t => {
                this.O && this.Ql(),
                this.O = !1,
                this.j()
            }
            ,
            this.Y = t => {
                t.preventDefault(),
                this.m.synth.maintainLiveInput(),
                this.O = !0;
                const e = this.container.getBoundingClientRect();
                this.Ze = (t.touches[0].clientY - e.top) * this.v / (e.bottom - e.top),
                isNaN(this.Ze) && (this.Ze = 0),
                this.Kl(),
                this.Jl()
            }
            ,
            this.tt = t => {
                t.preventDefault(),
                this.m.synth.maintainLiveInput();
                const e = this.container.getBoundingClientRect();
                this.Ze = (t.touches[0].clientY - e.top) * this.v / (e.bottom - e.top),
                isNaN(this.Ze) && (this.Ze = 0),
                this.Kl(),
                this.O && this.Jl()
            }
            ,
            this.yr = t => {
                t.preventDefault(),
                this.O = !1,
                this.Ql()
            }
            ,
            this.Zl = () => {
                window.requestAnimationFrame(this.Zl);
                let t = !1
                  , e = this.m.performance.pitchesAreTemporary() ? 0 : this.m.synth.liveInputPitches.length;
                e += this.m.performance.bassPitchesAreTemporary() ? 0 : this.m.synth.liveBassInputPitches.length,
                this.Ul.length != e && (t = !0);
                for (let e = 0; e < this.m.synth.liveInputPitches.length; e++)
                    this.Ul[e] != this.m.synth.liveInputPitches[e] && (this.Ul[e] = this.m.synth.liveInputPitches[e],
                    t = !0);
                for (let i = this.m.synth.liveInputPitches.length; i < e; i++)
                    this.Ul[i] != this.m.synth.liveBassInputPitches[i - this.m.synth.liveInputPitches.length] && (this.Ul[i] = this.m.synth.liveBassInputPitches[i - this.m.synth.liveInputPitches.length],
                    t = !0);
                this.Ul.length = e,
                t && this.j()
            }
            ,
            this.gr = () => {
                const t = this.m.song.getChannelIsNoise(this.m.channel)
                  , e = this.m.song.getChannelIsMod(this.m.channel);
                if (this.Pl = e ? p.modCount : t ? p.drumCount : this.m.getVisiblePitchCount(),
                this.Bh = this.v / this.Pl,
                this.Kl(),
                this.O && this.Jl(),
                !this.m.prefs.showLetters)
                    return;
                if (this.Ll == this.m.song.scale && this.m.song.scale != p.scales.dictionary.Custom.index && this.Wl == this.m.song.key && this.el == t && this.il == e && this.jl == this.Pl)
                    return;
                this.Ll = this.m.song.scale,
                this.Wl = this.m.song.key,
                this.el = t,
                this.il = e;
                const i = this.m.song.channels[this.m.channel].instruments[this.m.getCurrentInstrument()];
                if (this.Dl.style.display = t || e ? "none" : "flex",
                this.zl.style.display = t ? "flex" : "none",
                this.ql.style.display = e ? "flex" : "none",
                t || e) {
                    if (e) {
                        let t = ""
                          , e = ""
                          , a = nt.modLabelPrimaryText
                          , r = nt.modLabelSecondaryText;
                        for (let h = 0; h < p.modCount; h++) {
                            let l = !0
                              , c = !0
                              , d = i.modInstruments[p.modCount - h - 1] + 1
                              , m = i.modChannels[p.modCount - h - 1] + 1
                              , u = i.modulators[p.modCount - h - 1]
                              , f = +(m - 1 >= this.m.song.pitchChannelCount) + 1;
                            -2 == i.modChannels[p.modCount - h - 1] ? f = 0 : -1 == i.modChannels[p.modCount - h - 1] && (f = 3);
                            let y = this.m.song.channels[Math.max(0, m - 1)].instruments.length;
                            switch (f) {
                            case 0:
                                t = "Mod",
                                l = !1,
                                r = nt.modLabelSecondaryText,
                                c = !1;
                                break;
                            case 1:
                                if ("" == this.m.song.channels[m - 1].name)
                                    y > 1 ? m >= 10 || d >= 10 ? (t = "P" + m,
                                    t += d - 1 == y ? " All" : d - 1 > y ? " Act" : " I" + d) : (t = "Pitch" + m,
                                    t += d - 1 == y ? " All" : d - 1 > y ? " Act" : " Ins" + d) : t = "Pitch " + m;
                                else {
                                    let e;
                                    e = d - 1 == y ? " All" : d - 1 > y ? " Act" : " I" + d,
                                    t = y > 1 ? "P" + m + " " + this.m.song.channels[m - 1].name + e : "P" + m + " " + this.m.song.channels[m - 1].name
                                }
                                break;
                            case 2:
                                const e = i.modChannels[p.modCount - h - 1]
                                  , n = e - this.m.song.pitchChannelCount;
                                if ("" == this.m.song.channels[e].name)
                                    y > 1 ? n + 1 >= 10 || d >= 10 ? (t = "N" + (n + 1),
                                    t += d - 1 == y ? " All" : d - 1 > y ? " Act" : " I" + d) : (t = "Noise" + (n + 1),
                                    t += d - 1 == y ? " All" : d - 1 > y ? " Act" : " Ins" + d) : t = "Noise " + (n + 1);
                                else if (y > 1) {
                                    let i;
                                    i = d - 1 == y ? " All" : d - 1 > y ? " Act" : " I" + d,
                                    t = "N" + (n + 1) + " " + this.m.song.channels[e].name + i
                                } else
                                    t = "N" + (n + 1) + " " + this.m.song.channels[e].name;
                                break;
                            case 3:
                                t = "Song"
                            }
                            if (l)
                                if (e = p.modulators[u].pianoName,
                                u == p.modulators.dictionary.none.index)
                                    r = nt.modLabelSecondaryText,
                                    c = !1;
                                else if (u == p.modulators.dictionary["eq filter"].index || u == p.modulators.dictionary["note filter"].index) {
                                    var n = " Morph"
                                      , s = i.modFilterTypes[p.modCount - h - 1];
                                    s > 0 && s % 2 ? n = " Dot" + Math.ceil(s / 2) + "X" : s > 0 && (n = " Dot" + Math.ceil(s / 2) + "Y"),
                                    e += n
                                }
                            const b = this.$l[h]
                              , g = this.Hl[h]
                              , w = this._l[h]
                              , v = this.Vl[h];
                            if (b.style.fill = a,
                            b.textContent = t,
                            g.style.fill = r,
                            g.textContent = l ? e : "Not set",
                            w.textContent = "" + (p.modCount - h),
                            v.style.fill = c ? nt.indicatorPrimary : nt.modLabelSecondaryText,
                            "" != this.m.song.channels[Math.max(0, i.modChannels[p.modCount - h - 1])].name) {
                                let t = "1"
                                  , e = b.parentElement.parentElement.getBoundingClientRect().height
                                  , i = b.getComputedTextLength()
                                  , n = 0;
                                for (i > e - 8 ? (t = "0.65",
                                n = 2) : i > e - 24 && (t = "0.8",
                                n = 1),
                                b.style.transform = "rotate(-90deg) translate(" + (-20 - n - Math.round(Math.max(0, (e - 80) / 2))) + "px, 39px) scale(" + t + ", 1)"; "0.65" == t && b.getComputedTextLength() > e + 8; ) {
                                    var o = 4 + (d >= 10 ? 1 : 0);
                                    b.textContent = b.textContent.substr(0, b.textContent.length - o) + b.textContent.substr(b.textContent.length - o + 1)
                                }
                            } else {
                                let t = b.parentElement.parentElement.getBoundingClientRect().height;
                                b.style.transform = "rotate(-90deg) translate(" + (-20 - Math.round(Math.max(0, (t - 80) / 2))) + "px, 39px) scale(1, 1)"
                            }
                        }
                    }
                } else {
                    if (this.jl != this.Pl) {
                        this.Dl.innerHTML = "";
                        for (let t = 0; t < this.Pl; t++) {
                            const e = J.div({
                                class: "piano-label",
                                style: "font-weight: bold; -webkit-text-stroke-width: 0; font-size: 11px; font-family: sans-serif; position: absolute; padding-left: 15px; white-space: nowrap;"
                            })
                              , i = J.div({
                                class: "piano-button",
                                style: "background: gray;"
                            }, e);
                            this.Dl.appendChild(i),
                            this.Rl[t] = e,
                            this.Ol[t] = i
                        }
                        this.Rl.length = this.Pl,
                        this.Ol.length = this.Pl,
                        this.jl = this.Pl
                    }
                    for (let t = 0; t < this.Pl; t++) {
                        const e = (t + p.keys[this.m.song.key].basePitch) % p.pitchesPerOctave
                          , i = p.keys[e].isWhiteKey;
                        if (this.Ol[t].style.background = i ? nt.whitePianoKey : nt.blackPianoKey,
                        (this.m.song.scale == p.scales.dictionary.Custom.index ? this.m.song.scaleCustom : p.scales[this.m.song.scale].flags)[t % p.pitchesPerOctave]) {
                            this.Ol[t].classList.remove("disabled"),
                            this.Rl[t].style.display = "";
                            const i = this.Rl[t];
                            i.style.transform = t % 12 == 0 ? "translate(-5px, 0px)" : "translate(0px, 0px)",
                            i.style.color = p.keys[e].isWhiteKey ? nt.whitePianoKeyText : nt.blackPianoKeyText,
                            i.textContent = ra.getPitchName(e, t, this.m.getBaseVisibleOctave(this.m.channel) + this.m.song.octave)
                        } else
                            this.Ol[t].classList.add("disabled"),
                            this.Rl[t].style.display = "none"
                    }
                }
                this.j()
            }
            ;
            for (let t = 0; t < p.drumCount; t++) {
                const e = 100 * (1 - t / p.drumCount * .35);
                this.zl.appendChild(J.div({
                    class: "drum-button",
                    style: `background-size: ${e}% ${e}%;`
                }))
            }
            for (let t = 0; t < p.modCount; t++) {
                const t = Y.text({
                    class: "modulator-label",
                    "text-anchor": "left",
                    fill: nt.modLabelPrimaryText,
                    style: "font-weight: bold; align-self: flex-start; transform-origin: center; transform: rotate(-90deg) translate(-19px, 39px); font-size: 11px; font-family: sans-serif;"
                })
                  , e = Y.text({
                    class: "modulator-label",
                    "text-anchor": "left",
                    fill: nt.modLabelPrimaryText,
                    style: "font-weight: bold; align-self: flex-end; transform-origin: center; transform: rotate(-90deg) translate(-26px, 42px); font-size: 11px; font-family: sans-serif;"
                })
                  , i = Y.text({
                    class: "modulator-inverse-label",
                    fill: nt.modLabelPrimary,
                    style: "font-weight: bold; align-self: flex-start; transform-origin: center; transform: rotate(-90deg) translate(4px, 13px); font-size: 11px; font-family: sans-serif;"
                })
                  , n = Y.rect({
                    width: "12px",
                    height: "9px",
                    fill: nt.indicatorPrimary,
                    style: "pointer-events: none; transform: translate(4px, 4px);"
                })
                  , s = Y.svg({
                    viewBox: "0 0 16 66",
                    width: "16px",
                    style: "pointer-events: none; flex-grow: 1;"
                }, [t])
                  , o = Y.svg({
                    viewBox: "0 0 16 14",
                    width: "16px",
                    style: "pointer-events: none;"
                }, [n, i])
                  , a = Y.svg({
                    viewBox: "0 0 16 80",
                    width: "16px",
                    style: "pointer-events: none;"
                }, [e])
                  , r = J.div({
                    style: "display: flex; flex-direction: column; justify-content: space-between; pointer-events: none;"
                }, [o, s])
                  , h = J.div({
                    style: "display: flex; flex-direction: column-reverse; justify-content: space-between; pointer-events: none;"
                }, [a])
                  , l = J.div({
                    style: "display: flex; flex-direction: row; justify-content: space-between; padding: 0px; width: 32px; height: 100%; overflow: hidden; pointer-events: none;"
                }, [r, h])
                  , c = J.div({
                    class: "modulator-button",
                    style: "background: " + nt.modLabelPrimary + ";"
                }, l);
                this.ql.appendChild(c),
                this.$l.push(t),
                this.Hl.push(e),
                this._l.push(i),
                this.Vl.push(n)
            }
            this.container.addEventListener("mousedown", this.K),
            document.addEventListener("mousemove", this.Z),
            document.addEventListener("mouseup", this.Yl),
            this.container.addEventListener("mouseover", this.W),
            this.container.addEventListener("mouseout", this.U),
            this.container.addEventListener("touchstart", this.Y),
            this.container.addEventListener("touchmove", this.tt),
            this.container.addEventListener("touchend", this.yr),
            this.container.addEventListener("touchcancel", this.yr),
            this.m.notifier.watch(this.gr),
            this.gr(),
            window.requestAnimationFrame(this.Zl)
        }
        Kl() {
            const t = this.m.song.scale == p.scales.dictionary.Custom.index ? this.m.song.scaleCustom : p.scales[this.m.song.scale].flags
              , e = Math.max(0, Math.min(this.Pl - 1, this.Pl - this.Ze / this.Bh));
            if (t[Math.floor(e) % p.pitchesPerOctave] || this.m.song.getChannelIsNoise(this.m.channel))
                this.Xl = Math.floor(e);
            else {
                let i = Math.floor(e) + 1
                  , n = Math.floor(e) - 1;
                for (; !t[i % p.pitchesPerOctave]; )
                    i++;
                for (; !t[n % p.pitchesPerOctave]; )
                    n--;
                let s = i
                  , o = n + 1;
                i % p.pitchesPerOctave != 0 && i % p.pitchesPerOctave != 7 || (s -= .5),
                n % p.pitchesPerOctave != 0 && n % p.pitchesPerOctave != 7 || (o += .5),
                this.Xl = e - o > s - e ? i : n
            }
        }
        Jl() {
            const t = this.m.getBaseVisibleOctave(this.m.channel) * p.pitchesPerOctave
              , e = this.Xl + t;
            this.Gl != e && (this.m.performance.removePerformedPitch(this.Gl),
            this.Gl = e,
            this.m.performance.addPerformedPitch(e))
        }
        Ql() {
            this.m.performance.removePerformedPitch(this.Gl),
            this.Gl = -1
        }
        j() {
            if (this.Nl.style.visibility = !this.R || this.O ? "hidden" : "visible",
            this.R && !this.O) {
                const t = this.container.getBoundingClientRect()
                  , e = this.Bh / (this.v / (t.bottom - t.top));
                this.Nl.style.left = "0px",
                this.Nl.style.top = e * (this.Pl - this.Xl - 1) + "px",
                this.Nl.style.height = e + "px"
            }
            const t = this.m.getBaseVisibleOctave(this.m.channel) * p.pitchesPerOctave
              , e = (this.m.song.getChannelIsNoise(this.m.channel) ? this.zl : this.Dl).children;
            for (let i = 0; i < e.length; i++) {
                const n = e[i];
                -1 == this.Ul.indexOf(i + t) ? n.classList.remove("pressed") : n.classList.add("pressed")
            }
        }
        static getPitchName(t, e, i) {
            let n;
            if (p.keys[t].isWhiteKey)
                n = p.keys[t].name;
            else {
                const i = p.blackKeyNameParents[e % p.pitchesPerOctave];
                n = p.keys[(t + p.pitchesPerOctave + i) % p.pitchesPerOctave].name,
                1 == i ? n += "♭" : -1 == i && (n += "♯")
            }
            return e % 12 == 0 && (n += Math.floor(e / 12) + i),
            n
        }
    }
    const {button: ha, div: la, span: ca, h2: da, input: pa, br: ma, select: ua, option: fa} = J;
    class ya {
        constructor(t) {
            this.m = t,
            this.tc = pa({
                style: "width: 3em; margin-left: 1em;",
                type: "number",
                step: "1"
            }),
            this.ec = ua({
                style: "width: 100%;"
            }, fa({
                value: "end"
            }, "Apply change at end of song."), fa({
                value: "beginning"
            }, "Apply change at beginning of song.")),
            this.Oe = ha({
                class: "cancelButton"
            }),
            this.Re = ha({
                class: "okayButton",
                style: "width:45%;"
            }, "Okay"),
            this.container = la({
                class: "prompt noSelection",
                style: "width: 250px;"
            }, da("Song Length"), la({
                style: "display: flex; flex-direction: row; align-items: center; height: 2em; justify-content: flex-end;"
            }, la({
                style: "display: inline-block; text-align: right;"
            }, "Bars per song:", ma(), ca({
                style: `font-size: smaller; color: ${nt.secondaryText};`
            }, "(Multiples of 4 are recommended)")), this.tc), la({
                style: "display: flex; flex-direction: row; align-items: center; height: 2em; justify-content: flex-end;"
            }, la({
                class: "selectContainer",
                style: "width: 100%;"
            }, this.ec)), la({
                style: "display: flex; flex-direction: row-reverse; justify-content: space-between;"
            }, this.Re), this.Oe),
            this.$e = () => {
                this.m.undo()
            }
            ,
            this.cleanUp = () => {
                this.Re.removeEventListener("click", this.He),
                this.Oe.removeEventListener("click", this.$e),
                this.tc.removeEventListener("keypress", ya._e),
                this.tc.removeEventListener("blur", ya.Ve),
                this.container.removeEventListener("keydown", this.Ge)
            }
            ,
            this.Ge = t => {
                "BUTTON" != t.target.tagName && 13 == t.keyCode && this.He()
            }
            ,
            this.He = () => {
                window.localStorage.setItem("barCountPosition", this.ec.value);
                const t = new Zt;
                t.append(new xe(this.m,ya.We(this.tc),"beginning" == this.ec.value)),
                this.m.prompt = null,
                this.m.record(t, !0)
            }
            ,
            this.tc.value = this.m.song.barCount + "",
            this.tc.min = p.barCountMin + "",
            this.tc.max = p.barCountMax + "";
            const e = window.localStorage.getItem("barCountPosition");
            null != e && (this.ec.value = e),
            this.tc.select(),
            setTimeout(( () => this.tc.focus())),
            this.Re.addEventListener("click", this.He),
            this.Oe.addEventListener("click", this.$e),
            this.tc.addEventListener("keypress", ya._e),
            this.tc.addEventListener("blur", ya.Ve),
            this.container.addEventListener("keydown", this.Ge)
        }
        static _e(t) {
            const e = t.which ? t.which : t.keyCode;
            return 46 != e && e > 31 && (e < 48 || e > 57) && (t.preventDefault(),
            !0)
        }
        static Ve(t) {
            const e = t.target;
            e.value = String(ya.We(e))
        }
        static We(t) {
            return Math.floor(Math.max(Number(t.min), Math.min(Number(t.max), Number(t.value))))
        }
    }
    const {button: ba, div: ga, h2: wa, p: va, select: xa, option: ka} = J;
    class Ma {
        constructor(t) {
            this.m = t,
            this.ic = xa({
                style: "width: 100%;"
            }, ka({
                value: "acoustic"
            }, "(A) Acoustic"), ka({
                value: "bright"
            }, "(B) Bright")),
            this.Oe = ba({
                class: "cancelButton"
            }),
            this.Re = ba({
                class: "okayButton",
                style: "width:45%;"
            }, "Okay"),
            this.container = ga({
                class: "prompt",
                style: "width: 300px;"
            }, ga(wa("String Sustain"), va("This setting controls how quickly the picked string vibration decays."), va('Unlike most of BeepBox\'s instrument synthesizer features, a picked string cannot change frequency suddenly while maintaining its decay. If a tone\'s pitch changes suddenly (e.g. if the chord type is set to "arpeggio" or the transition type is set to "continues") then the string will be re-picked and start decaying from the beginning again, even if the envelopes don\'t otherwise restart.')), ga({
                style: {
                    display: p.enableAcousticSustain ? void 0 : "none"
                }
            }, va('BeepBox comes with two slightly different sustain designs. You can select one here and press "Okay" to confirm it.'), ga({
                class: "selectContainer",
                style: "width: 100%;"
            }, this.ic)), ga({
                style: {
                    display: p.enableAcousticSustain ? "flex" : "none",
                    "flex-direction": "row-reverse",
                    "justify-content": "space-between"
                }
            }, this.Re), this.Oe),
            this.$e = () => {
                this.m.undo()
            }
            ,
            this.cleanUp = () => {
                this.Re.removeEventListener("click", this.He),
                this.Oe.removeEventListener("click", this.$e),
                this.container.removeEventListener("keydown", this.Ge)
            }
            ,
            this.Ge = t => {
                "BUTTON" != t.target.tagName && 13 == t.keyCode && this.He()
            }
            ,
            this.He = () => {
                if (p.enableAcousticSustain) {
                    const t = new Zt;
                    t.append(new ci(this.m,p.sustainTypeNames.indexOf(this.ic.value))),
                    this.m.prompt = null,
                    this.m.record(t, !0)
                } else
                    this.$e()
            }
            ;
            const e = this.m.song.channels[this.m.channel].instruments[this.m.getCurrentInstrument()];
            this.ic.value = p.sustainTypeNames[e.stringSustainType],
            setTimeout(( () => this.Oe.focus())),
            this.Re.addEventListener("click", this.He),
            this.Oe.addEventListener("click", this.$e),
            this.container.addEventListener("keydown", this.Ge)
        }
    }
    const Sa = "songVersion: ";
    function Fa(t) {
        return JSON.parse(t.substring(13))
    }
    function Ca(t) {
        return Sa + JSON.stringify(t)
    }
    function Aa() {
        return (Math.random() * (-1 >>> 0) >>> 0).toString(32)
    }
    function Ea(t, e) {
        return e.versions[0].time - t.versions[0].time
    }
    function Ta(t) {
        console.warn(t),
        window.alert('Whoops, the song data appears to have been corrupted! Please try to recover the last working version of the song from the "Recover Recent Song..." option in BeepBox\'s "File" menu.')
    }
    function Pa(t, e) {
        return e.time - t.time
    }
    class Ba {
        constructor() {
            this.nc = new Vt
        }
        static getAllRecoveredSongs() {
            const t = []
              , e = {};
            for (let i = 0; i < localStorage.length; i++) {
                const n = localStorage.key(i);
                if (0 == n.indexOf(Sa)) {
                    const i = Fa(n);
                    let s = e[i.uid];
                    null == s && (s = {
                        versions: []
                    },
                    e[i.uid] = s,
                    t.push(s)),
                    s.versions.push(i)
                }
            }
            for (const e of t)
                e.versions.sort(Pa);
            return t.sort(Ea),
            t
        }
        saveVersion(t, e, i) {
            const n = e
              , s = Math.round(Date.now());
            clearTimeout(this.sc),
            this.sc = setTimeout(( () => {
                try {
                    this.nc.fromBase64String(i)
                } catch (t) {
                    return void Ta(t)
                }
                const e = Ba.getAllRecoveredSongs();
                let o = null;
                for (const i of e)
                    i.versions[0].uid == t && (o = i);
                null == o && (o = {
                    versions: []
                },
                e.unshift(o));
                let a = o.versions
                  , r = 1e3;
                if (a.length > 0) {
                    const t = a[0].time;
                    r = a[0].work + Math.min(18e4, s - t)
                }
                const h = {
                    uid: t,
                    name: n,
                    time: s,
                    work: r
                }
                  , l = Ca(h);
                a.unshift(h),
                localStorage.setItem(l, i);
                let c = 6e4;
                const d = Math.pow(2, .5);
                for (var p = 1; p < a.length; p++) {
                    if (a[p].work - (p == a.length - 1 ? 0 : a[p + 1].work) < c) {
                        let t = p;
                        if (p < a.length - 1) {
                            const e = a[p].time
                              , i = a[p - 1].time;
                            e - a[p + 1].time < .5 * (i - e) && (t = p + 1)
                        }
                        localStorage.removeItem(Ca(a[t]));
                        break
                    }
                    c *= d
                }
                for (; e.length > 8; ) {
                    let t = null
                      , i = Number.POSITIVE_INFINITY;
                    for (let n = Math.round(4); n < e.length; n++) {
                        const o = e[n]
                          , a = 1 / ((s - o.versions[0].time) / 432e5 + 1)
                          , r = (o.versions[0].work + 3e5) * a;
                        i > r && (i = r,
                        t = o)
                    }
                    for (const e of t.versions)
                        localStorage.removeItem(Ca(e));
                    e.splice(e.indexOf(t), 1)
                }
            }
            ), 750)
        }
    }
    const {button: Ia, div: La, h2: Da, p: za, select: qa, option: Na, iframe: Oa} = J;
    class Ra {
        constructor(t) {
            this.m = t,
            this.oc = La(),
            this.Oe = Ia({
                class: "cancelButton"
            }),
            this.container = La({
                class: "prompt",
                style: "width: 300px;"
            }, Da("Song Recovery"), La({
                style: "max-height: 385px; overflow-y: auto;"
            }, za("This is a TEMPORARY list of songs you have recently modified. Please keep your own backups of songs you care about! SONGS THAT USE SAMPLES WILL TAKE A WHILE TO LOAD, so be patient!"), this.oc, za('(If "Display Song Data in URL" is enabled in your preferences, then you may also be able to find song versions in your browser history. However, song recovery won\'t work if you were browsing in private/incognito mode.)')), this.Oe),
            this.$e = () => {
                this.m.undo()
            }
            ,
            this.cleanUp = () => {
                this.Oe.removeEventListener("click", this.$e)
            }
            ,
            this.Oe.addEventListener("click", this.$e);
            const e = Ba.getAllRecoveredSongs();
            0 == e.length && this.oc.appendChild(za("There are no recovered songs available yet. Try making a song!"));
            for (const t of e) {
                const e = qa({
                    style: "width: 100%;"
                });
                for (const i of t.versions)
                    e.appendChild(Na({
                        value: i.time
                    }, i.name + ": " + new Date(i.time).toLocaleString()));
                const i = Oa({
                    style: "width: 100%; height: 60px; border: none; display: block;"
                });
                i.src = "player/#song=" + window.localStorage.getItem(Ca(t.versions[0]));
                const n = La({
                    style: "margin: 4px 0;"
                }, La({
                    class: "selectContainer",
                    style: "width: 100%; margin: 2px 0;"
                }, e), i);
                this.oc.appendChild(n),
                e.addEventListener("change", ( () => {
                    const n = t.versions[e.selectedIndex];
                    i.contentWindow.location.replace("player/#song=" + window.localStorage.getItem(Ca(n))),
                    i.contentWindow.dispatchEvent(new Event("hashchange"))
                }
                ))
            }
        }
    }
    const {button: $a, label: Ha, div: _a, p: Va, a: Ga, h2: Wa, input: ja, select: Ua, option: Ka} = J;
    class Ja {
        constructor(t) {
            this.m = t,
            this.ac = Ua({
                style: "width: 100%;"
            }, Ka({
                value: "useCapsLockForNotes"
            }, "simple shortcuts, use caps lock to play notes"), Ka({
                value: "pressControlForShortcuts"
            }, "simple notes, press " + N.ctrlName + " for shortcuts")),
            this.rc = Ua({
                style: "width: 100%;"
            }, Ka({
                value: "wickiHayden"
            }, "Wicki-Hayden"), Ka({
                value: "songScale"
            }, "selected song scale"), Ka({
                value: "pianoAtC"
            }, "piano starting at C :)"), Ka({
                value: "pianoAtA"
            }, "piano starting at A :("), Ka({
                value: "pianoTransposingC"
            }, "piano transposing C :) to song key"), Ka({
                value: "pianoTransposingA"
            }, "piano transposing A :( to song key")),
            this.hc = Ua({
                style: "width: 100%;"
            }, Ka({
                value: "0"
            }, "disabled"), Ka({
                value: "-1"
            }, "before"), Ka({
                value: "1"
            }, "after")),
            this.lc = _a({
                style: "display: grid; row-gap: 4px; margin: 4px auto; font-size: 10px;"
            }),
            this.cc = ja({
                style: "width: 2em; margin-left: 1em;",
                type: "checkbox"
            }),
            this.dc = ja({
                style: "width: 2em; margin-left: 1em;",
                type: "checkbox"
            }),
            this.mc = ja({
                style: "width: 2em; margin-left: 1em;",
                type: "checkbox"
            }),
            this.uc = ja({
                style: "width: 2em; margin-left: 1em;",
                type: "checkbox"
            }),
            this.fc = ja({
                style: "width: 2em; margin-left: 1em;",
                type: "checkbox"
            }),
            this.yc = ja({
                style: "width: 2em; margin-left: 1em;",
                type: "checkbox"
            }),
            this.Re = $a({
                class: "okayButton",
                style: "width:45%;"
            }, "Okay"),
            this.Oe = $a({
                class: "cancelButton"
            }),
            this.container = _a({
                class: "prompt noSelection recordingSetupPrompt",
                style: "width: 600px; text-align: right; max-height: 90%;"
            }, Wa({
                style: "align-self: center;"
            }, "Note Recording Setup"), _a({
                style: "display: grid; overflow-y: auto; overflow-x: hidden; flex-shrink: 1;"
            }, Va("UltraBox can record notes as you perform them. You can start recording by pressing Ctrl+Space (or " + N.ctrlSymbol + "P)."), Ha({
                style: "display: flex; flex-direction: row; align-items: center; height: 2em; justify-content: center;"
            }, "Add ● record button next to ▶ play button:", this.dc), Ha({
                style: "display: flex; flex-direction: row; align-items: center; height: 2em; justify-content: center;"
            }, "Snap recorded notes to the song's rhythm:", this.mc), Ha({
                style: "display: flex; flex-direction: row; align-items: center; height: 2em; justify-content: center;"
            }, "Ignore notes not in the song's scale:", this.uc), Va("While recording, you can perform notes on your keyboard!"), Ha({
                style: "display: flex; flex-direction: row; align-items: center; margin-top: 0.5em; margin-bottom: 0.5em; height: 2em; justify-content: center;"
            }, "Keyboard layout:", _a({
                class: "selectContainer",
                style: "width: 50%; margin-left: 1em;"
            }, this.rc)), this.lc, Va("When not recording, you can use the computer keyboard either for shortcuts (like C and V for copy and paste) or for performing notes, depending on this mode:"), Ha({
                style: "display: flex; margin-top: 0.5em; margin-bottom: 0.5em; flex-direction: row; align-items: center; height: 2em; justify-content: center;"
            }, _a({
                class: "selectContainer",
                style: "width: 50%;"
            }, this.ac)), Va("Performing music takes practice! Try slowing the tempo and using this metronome to help you keep a rhythm."), Ha({
                style: "display: flex; flex-direction: row; align-items: center; height: 2em; justify-content: center;"
            }, "Hear metronome while recording:", this.yc), Ha({
                style: "display: flex; flex-direction: row; align-items: center; height: 2em; justify-content: center;"
            }, "Count-in 1 bar of metronome before recording:", this.fc), Va("If you have a ", Ga({
                href: "https://caniuse.com/midi",
                target: "_blank"
            }, "compatible browser"), " on a device connected to a MIDI keyboard, you can use it to perform notes in UltraBox! (Or you could buy ", Ga({
                href: "https://imitone.com/",
                target: "_blank"
            }, "Imitone"), " or ", Ga({
                href: "https://vochlea.com/",
                target: "_blank"
            }, "Dubler"), " to hum notes into a microphone while wearing headphones!)"), Ha({
                style: "display: flex; flex-direction: row; align-items: center; margin-top: 0.5em; height: 2em; justify-content: center;"
            }, "Enable MIDI performance:", this.cc), Va("The range of pitches available to play via your computer keyboard is affected by the octave scrollbar of the currently selected channel."), Va("If you set the channel offset below to 'before' or 'after', notes below the middle octave in the view will be 'bass' notes, and placed in the channel before or after the viewed one. Using this, you can play bass and lead at the same time!"), Ha({
                style: "display: flex; flex-direction: row; align-items: center; margin-top: 0.5em; margin-bottom: 0.5em; height: 2em; justify-content: center;"
            }, "Bass Offset:", _a({
                class: "selectContainer",
                style: "width: 50%; margin-left: 1em;"
            }, this.hc)), Va("Once you enable the setting, the keyboard layout above will darken to denote the new bass notes. The notes will be recorded with independent timing and this works with MIDI devices, too. Be aware that the octave offset of both used channels will impact how high/low the bass/lead are relative to one another."), Va('Recorded notes often overlap such that one note ends after the next note already started. In UltraBox, these notes get split into multiple notes which may sound different when re-played than they did when you were recording. To fix the sound, you can either manually clean up the notes in the pattern editor, or you could try enabling the "transition type" effect on the instrument and setting it to "continue".'), _a({
                style: `width: 100%; height: 80px; background: linear-gradient(rgba(0,0,0,0), ${nt.editorBackground}); position: sticky; bottom: 0; pointer-events: none;`
            })), _a({
                style: "display: flex; flex-direction: row-reverse; justify-content: space-between;"
            }, this.Re), this.Oe),
            this.$e = () => {
                this.m.undo()
            }
            ,
            this.cleanUp = () => {
                this.Re.removeEventListener("click", this.Wo),
                this.Oe.removeEventListener("click", this.$e),
                this.container.removeEventListener("keydown", this.Ge)
            }
            ,
            this.Ge = t => {
                "BUTTON" != t.target.tagName && 13 == t.keyCode && this.Wo()
            }
            ,
            this.Wo = () => {
                this.m.prefs.pressControlForShortcuts = "pressControlForShortcuts" == this.ac.value,
                this.m.prefs.keyboardLayout = this.rc.value,
                this.m.prefs.bassOffset = Number(this.hc.value),
                this.m.prefs.enableMidi = this.cc.checked,
                this.m.prefs.showRecordButton = this.dc.checked,
                this.m.prefs.snapRecordedNotesToRhythm = this.mc.checked,
                this.m.prefs.ignorePerformedNotesNotInScale = this.uc.checked,
                this.m.prefs.metronomeCountIn = this.fc.checked,
                this.m.prefs.metronomeWhileRecording = this.yc.checked,
                this.m.prefs.save(),
                this.$e()
            }
            ,
            this.bc = () => {
                for (; this.lc.firstChild; )
                    this.lc.removeChild(this.lc.firstChild);
                const t = [12, 12, 11, 10]
                  , e = p.scales[this.m.song.scale].flags;
                for (let i = 0; i < 4; i++) {
                    const n = _a({
                        style: "display: flex;"
                    });
                    this.lc.appendChild(n);
                    const s = _a({
                        style: "width: " + 12 * i + "px; height: 20px; flex-shrink: 0;"
                    });
                    n.appendChild(s);
                    for (let s = 0; s < t[i]; s++) {
                        const t = _a({
                            style: "width: 20px; height: 20px; margin: 0 2px; box-sizing: border-box; flex-shrink: 0; display: flex; justify-content: center; align-items: center;"
                        });
                        n.appendChild(t);
                        const o = sa.keyPosToPitch(this.m, s, 3 - i, this.rc.value);
                        if (null != o) {
                            const i = o % 12;
                            e[i] ? 0 == i ? t.style.background = nt.tonic : 7 == i && this.m.prefs.showFifth ? t.style.background = nt.fifthNote : t.style.background = nt.pitchBackground : t.style.border = "2px solid " + nt.pitchBackground,
                            0 != this.hc.selectedIndex && o <= ra.getBassCutoffPitch(this.m) ? t.style.setProperty("filter", "hue-rotate(60deg) brightness(0.5)") : t.style.setProperty("filter", "");
                            const n = (i + p.keys[this.m.song.key].basePitch) % p.pitchesPerOctave;
                            t.textContent = ra.getPitchName(n, i, Math.floor(o / 12))
                        }
                    }
                }
            }
            ,
            this.ac.value = this.m.prefs.pressControlForShortcuts ? "pressControlForShortcuts" : "useCapsLockForNotes",
            this.rc.value = this.m.prefs.keyboardLayout,
            this.hc.value = String(this.m.prefs.bassOffset),
            this.cc.checked = this.m.prefs.enableMidi,
            this.dc.checked = this.m.prefs.showRecordButton,
            this.mc.checked = this.m.prefs.snapRecordedNotesToRhythm,
            this.uc.checked = this.m.prefs.ignorePerformedNotesNotInScale,
            this.fc.checked = this.m.prefs.metronomeCountIn,
            this.yc.checked = this.m.prefs.metronomeWhileRecording,
            setTimeout(( () => this.dc.focus())),
            this.Re.addEventListener("click", this.Wo),
            this.Oe.addEventListener("click", this.$e),
            this.container.addEventListener("keydown", this.Ge),
            this.bc(),
            this.rc.addEventListener("change", this.bc),
            this.hc.addEventListener("change", this.bc)
        }
    }
    class Ya {
        constructor(t, e, i=!1) {
            this.m = t,
            this.gc = e,
            this.yo = i,
            this.u = 120,
            this.v = 26,
            this.ni = Y.path({
                fill: nt.uiWidgetBackground,
                "pointer-events": "none"
            }),
            this.bo = Y.svg({
                "pointer-events": "none"
            }),
            this.wo = Y.svg({
                "pointer-events": "none"
            }),
            this.vo = Y.path({
                fill: "none",
                stroke: "currentColor",
                "stroke-width": 2,
                "pointer-events": "none"
            }),
            this.wc = Y.path({
                fill: "currentColor",
                "pointer-events": "none"
            }),
            this.q = Y.svg({
                style: `background-color: ${nt.editorBackground}; touch-action: none; cursor: crosshair;`,
                width: "100%",
                height: "100%",
                viewBox: "0 0 " + this.u + " " + this.v,
                preserveAspectRatio: "none"
            }, this.ni, this.bo, this.wo, this.vo, this.wc),
            this.container = J.div({
                class: "spectrum",
                style: "height: 100%;"
            }, this.q),
            this.N = 0,
            this.Ze = 0,
            this.Mo = 0,
            this.So = 0,
            this.O = !1,
            this.Fo = null,
            this.Co = "",
            this.Ao = !0,
            this.instrument = this.m.song.channels[this.m.channel].instruments[this.m.getCurrentInstrument()],
            this.Eo = new Dt(null != this.gc),
            this.ei = 0,
            this.ii = [],
            this.storeChange = () => {
                var t = !0;
                if (this.ii.length > 0)
                    for (var e = 0; e < p.spectrumControlPoints; e++)
                        this.ii[this.ei][e] != this.instrument.spectrumWave.spectrum[e] && (t = !1,
                        e = p.spectrumControlPoints);
                0 != t && 0 != this.ii.length || (this.ii.splice(0, this.ei),
                this.ei = 0,
                this.ii.unshift(this.instrument.spectrumWave.spectrum.slice()),
                this.ii.length > 32 && this.ii.pop())
            }
            ,
            this.undo = () => {
                if (this.ei < this.ii.length - 1) {
                    this.ei++;
                    const t = this.ii[this.ei].slice();
                    this.setSpectrumWave(t)
                }
            }
            ,
            this.redo = () => {
                if (this.ei > 0) {
                    this.ei--;
                    const t = this.ii[this.ei].slice();
                    this.setSpectrumWave(t)
                }
            }
            ,
            this.K = t => {
                t.preventDefault(),
                this.O = !0;
                const e = this.q.getBoundingClientRect();
                this.N = ((t.clientX || t.pageX) - e.left) * this.u / (e.right - e.left),
                this.Ze = ((t.clientY || t.pageY) - e.top) * this.v / (e.bottom - e.top),
                isNaN(this.N) && (this.N = 0),
                isNaN(this.Ze) && (this.Ze = 0),
                this.Mo = this.Vi(this.N),
                this.So = this.To(this.Ze),
                this.X()
            }
            ,
            this.Y = t => {
                t.preventDefault(),
                this.O = !0;
                const e = this.q.getBoundingClientRect();
                this.N = (t.touches[0].clientX - e.left) * this.u / (e.right - e.left),
                this.Ze = (t.touches[0].clientY - e.top) * this.v / (e.bottom - e.top),
                isNaN(this.N) && (this.N = 0),
                isNaN(this.Ze) && (this.Ze = 0),
                this.Mo = this.Vi(this.N),
                this.So = this.To(this.Ze),
                this.X()
            }
            ,
            this.Z = t => {
                if (null == this.container.offsetParent)
                    return;
                const e = this.q.getBoundingClientRect();
                this.N = ((t.clientX || t.pageX) - e.left) * this.u / (e.right - e.left),
                this.Ze = ((t.clientY || t.pageY) - e.top) * this.v / (e.bottom - e.top),
                isNaN(this.N) && (this.N = 0),
                isNaN(this.Ze) && (this.Ze = 0),
                this.X()
            }
            ,
            this.tt = t => {
                if (null == this.container.offsetParent)
                    return;
                if (!this.O)
                    return;
                t.preventDefault();
                const e = this.q.getBoundingClientRect();
                this.N = (t.touches[0].clientX - e.left) * this.u / (e.right - e.left),
                this.Ze = (t.touches[0].clientY - e.top) * this.v / (e.bottom - e.top),
                isNaN(this.N) && (this.N = 0),
                isNaN(this.Ze) && (this.Ze = 0),
                this.X(),
                this.render()
            }
            ,
            this.et = t => {
                this.O && (this.yo || this.m.record(this.Fo),
                this.storeChange(),
                this.Fo = null),
                this.O = !1
            }
            ,
            this.Eo.spectrum = null == this.gc ? this.instrument.spectrumWave.spectrum.slice() : this.instrument.drumsetSpectrumWaves[this.gc].spectrum.slice();
            for (let t = 0; t < p.spectrumControlPoints; t += p.spectrumControlPointsPerOctave)
                this.bo.appendChild(Y.rect({
                    fill: nt.tonic,
                    x: (t + 1) * this.u / (p.spectrumControlPoints + 2) - 1,
                    y: 0,
                    width: 2,
                    height: this.v
                }));
            for (let t = 4; t <= p.spectrumControlPoints; t += p.spectrumControlPointsPerOctave)
                this.wo.appendChild(Y.rect({
                    fill: nt.fifthNote,
                    x: (t + 1) * this.u / (p.spectrumControlPoints + 2) - 1,
                    y: 0,
                    width: 2,
                    height: this.v
                }));
            this.storeChange(),
            this.container.addEventListener("mousedown", this.K),
            document.addEventListener("mousemove", this.Z),
            document.addEventListener("mouseup", this.et),
            this.container.addEventListener("touchstart", this.Y),
            this.container.addEventListener("touchmove", this.tt),
            this.container.addEventListener("touchend", this.et),
            this.container.addEventListener("touchcancel", this.et)
        }
        Vi(t) {
            return (p.spectrumControlPoints + 2) * t / this.u - 1
        }
        To(t) {
            return p.spectrumMax * (1 - (t - 1) / (this.v - 2))
        }
        X() {
            if (this.O) {
                const t = this.Vi(this.N)
                  , e = this.To(this.Ze)
                  , i = this.m.song.channels[this.m.channel].instruments[this.m.getCurrentInstrument()]
                  , n = null == this.gc ? i.spectrumWave : i.drumsetSpectrumWaves[this.gc];
                if (t != this.Mo) {
                    const i = (e - this.So) / (t - this.Mo)
                      , s = this.So - this.Mo * i
                      , o = Math.ceil(Math.min(this.Mo, t))
                      , a = Math.floor(Math.max(this.Mo, t));
                    for (let t = o; t <= a; t++)
                        t < 0 || t >= p.spectrumControlPoints || (n.spectrum[t] = Math.max(0, Math.min(p.spectrumMax, Math.round(t * i + s))))
                }
                n.spectrum[Math.max(0, Math.min(p.spectrumControlPoints - 1, Math.round(t)))] = Math.max(0, Math.min(p.spectrumMax, Math.round(e))),
                this.Mo = t,
                this.So = e,
                this.Fo = new Je(this.m,i,n),
                this.m.setProspectiveChange(this.Fo)
            }
        }
        getSpectrumWave() {
            const t = this.m.song.channels[this.m.channel].instruments[this.m.getCurrentInstrument()];
            return null == this.gc ? t.spectrumWave : t.drumsetSpectrumWaves[this.gc]
        }
        setSpectrumWave(t, e=!1) {
            const i = this.m.song.channels[this.m.channel].instruments[this.m.getCurrentInstrument()];
            if (null == this.gc) {
                for (let e = 0; e < p.spectrumControlPoints; e++)
                    i.spectrumWave.spectrum[e] = t[e];
                const n = new Je(this.m,i,i.spectrumWave);
                e && this.m.record(n)
            } else {
                for (let e = 0; e < p.spectrumControlPoints; e++)
                    i.drumsetSpectrumWaves[this.gc].spectrum[e] = t[e];
                const n = new Je(this.m,i,i.drumsetSpectrumWaves[this.gc]);
                e && this.m.record(n)
            }
            this.render()
        }
        saveSettings() {
            const t = this.m.song.channels[this.m.channel].instruments[this.m.getCurrentInstrument()];
            return null == this.gc || null == this.gc ? new Je(this.m,t,t.spectrumWave) : new Je(this.m,t,t.drumsetSpectrumWaves[this.gc])
        }
        resetToInitial() {
            this.ii = [],
            this.ei = 0
        }
        render() {
            const t = this.m.song.channels[this.m.channel].instruments[this.m.getCurrentInstrument()]
              , e = null == this.gc ? t.spectrumWave : t.drumsetSpectrumWaves[this.gc]
              , i = t => (1 - t / p.spectrumMax) * (this.v - 1) + 1;
            let n = 0
              , s = "M 0 " + q(this.v) + " ";
            for (let t = 0; t < p.spectrumControlPoints; t++) {
                let o = e.spectrum[t];
                s += 0 != n || 0 != o ? "L " : "M ",
                s += q((t + 1) * this.u / (p.spectrumControlPoints + 2)) + " " + q(i(o)) + " ",
                n = o
            }
            const o = i(n);
            n > 0 && (s += "L " + (this.u - 1) + " " + q(o) + " "),
            this.Co != s && (this.Co = s,
            this.vo.setAttribute("d", s),
            this.ni.setAttribute("d", s + "L " + this.u + " " + q(o) + " L " + this.u + " " + q(this.v) + " L 0 " + q(this.v) + " z "),
            this.wc.setAttribute("d", "M " + this.u + " " + q(o) + " L " + (this.u - 4) + " " + q(o - 4) + " L " + (this.u - 4) + " " + q(o + 4) + " z"),
            this.wc.style.display = n > 0 ? "" : "none"),
            this.Ao != this.m.prefs.showFifth && (this.Ao = this.m.prefs.showFifth,
            this.wo.style.display = this.m.prefs.showFifth ? "" : "none")
        }
    }
    class Qa {
        constructor(t, e, i) {
            if (this.m = t,
            this.hi = e,
            this.vc = i,
            this.spectrumEditor = new Ya(this.m,null,!0),
            this.spectrumEditors = [],
            this.xc = 0,
            this.ci = J.button({
                style: "width: 55%;",
                type: "button"
            }),
            this.kc = [],
            this.Mc = J.div({
                class: "instrument-bar",
                style: "justify-content: center;"
            }),
            this.Oe = J.button({
                class: "cancelButton"
            }),
            this.Re = J.button({
                class: "okayButton",
                style: "width:45%;"
            }, "Okay"),
            this.copyButton = J.button({
                style: "width:86px; margin-right: 5px;",
                class: "copyButton"
            }, ["Copy", Y.svg({
                style: "flex-shrink: 0; position: absolute; left: 0; top: 50%; margin-top: -1em; pointer-events: none;",
                width: "2em",
                height: "2em",
                viewBox: "-5 -21 26 26"
            }, [Y.path({
                d: "M 0 -15 L 1 -15 L 1 0 L 13 0 L 13 1 L 0 1 L 0 -15 z M 2 -1 L 2 -17 L 10 -17 L 14 -13 L 14 -1 z M 3 -2 L 13 -2 L 13 -12 L 9 -12 L 9 -16 L 3 -16 z",
                fill: "currentColor"
            })])]),
            this.pasteButton = J.button({
                style: "width:86px;",
                class: "pasteButton"
            }, ["Paste", Y.svg({
                style: "flex-shrink: 0; position: absolute; left: 0; top: 50%; margin-top: -1em; pointer-events: none;",
                width: "2em",
                height: "2em",
                viewBox: "0 0 26 26"
            }, [Y.path({
                d: "M 8 18 L 6 18 L 6 5 L 17 5 L 17 7 M 9 8 L 16 8 L 20 12 L 20 22 L 9 22 z",
                stroke: "currentColor",
                fill: "none"
            }), Y.path({
                d: "M 9 3 L 14 3 L 14 6 L 9 6 L 9 3 z M 16 8 L 20 12 L 16 12 L 16 8 z",
                fill: "currentColor"
            })])]),
            this.copyPasteContainer = J.div({
                style: "width: 185px;"
            }, this.copyButton, this.pasteButton),
            this.container = J.div({
                class: "prompt noSelection",
                style: "width: 500px;"
            }, J.h2("Edit Spectrum Instrument"), J.div({
                style: "display: flex; width: 55%; align-self: center; flex-direction: row; align-items: center; justify-content: center;"
            }, this.ci), this.Mc, J.div({
                style: "display: flex; flex-direction: row; align-items: center; justify-content: center; height: 80%"
            }, this.spectrumEditor.container), J.div({
                style: "display: flex; flex-direction: row-reverse; justify-content: space-between;"
            }, this.Re, this.copyPasteContainer), this.Oe),
            this.Sc = t => {
                this.kc[this.xc].classList.remove("selected-instrument"),
                this.spectrumEditors[this.xc].setSpectrumWave(this.spectrumEditor.getSpectrumWave().spectrum),
                this.xc = t,
                this.kc[t].classList.add("selected-instrument"),
                this.spectrumEditor.setSpectrumWave(this.spectrumEditors[this.xc].getSpectrumWave().spectrum),
                this.spectrumEditor.render()
            }
            ,
            this.di = () => {
                this.hi.togglePlay(),
                this.updatePlayButton()
            }
            ,
            this.$e = () => {
                this.m.prompt = null,
                this.m.undo()
            }
            ,
            this.cleanUp = () => {
                this.Re.removeEventListener("click", this.He),
                this.Oe.removeEventListener("click", this.$e),
                this.container.removeEventListener("keydown", this.whenKeyPressed),
                this.spectrumEditor.container.removeEventListener("mousemove", ( () => this.spectrumEditor.render())),
                this.ci.removeEventListener("click", this.di)
            }
            ,
            this.pi = () => {
                const t = this.spectrumEditor.getSpectrumWave();
                window.localStorage.setItem("spectrumCopy", JSON.stringify(t.spectrum))
            }
            ,
            this.mi = () => {
                const t = JSON.parse(String(window.localStorage.getItem("spectrumCopy")));
                this.spectrumEditor.setSpectrumWave(t)
            }
            ,
            this.whenKeyPressed = t => {
                "BUTTON" != t.target.tagName && 13 == t.keyCode ? this.He() : 32 == t.keyCode ? (this.di(),
                t.preventDefault()) : 90 == t.keyCode ? (this.spectrumEditor.undo(),
                t.stopPropagation()) : 89 == t.keyCode ? (this.spectrumEditor.redo(),
                t.stopPropagation()) : 219 == t.keyCode ? this.m.synth.goToPrevBar() : 221 == t.keyCode ? this.m.synth.goToNextBar() : t.keyCode >= 49 && t.keyCode <= 57 ? t.shiftKey && this.vc && this.Sc(t.keyCode - 49) : 48 == t.keyCode ? t.shiftKey && this.vc && this.Sc(9) : 189 == t.keyCode || 173 == t.keyCode ? t.shiftKey && this.vc && this.Sc(10) : 187 != t.keyCode && 61 != t.keyCode && 171 != t.keyCode || t.shiftKey && this.vc && this.Sc(11)
            }
            ,
            this.He = () => {
                const t = new Zt;
                for (let e = 0; e < this.spectrumEditors.length; e++)
                    t.append(this.spectrumEditors[e].saveSettings());
                this.m.record(t, !0),
                this.m.prompt = null
            }
            ,
            this.Re.addEventListener("click", this.He),
            this.Oe.addEventListener("click", this.$e),
            this.container.addEventListener("keydown", this.whenKeyPressed),
            this.copyButton.addEventListener("click", this.pi),
            this.pasteButton.addEventListener("click", this.mi),
            this.ci.addEventListener("click", this.di),
            this.container.addEventListener("mousemove", ( () => {
                this.spectrumEditor.render(),
                this.spectrumEditors[this.xc].setSpectrumWave(this.spectrumEditor.getSpectrumWave().spectrum)
            }
            )),
            this.container.addEventListener("mousedown", this.spectrumEditor.render),
            this.spectrumEditor.container.addEventListener("mousemove", ( () => {
                this.spectrumEditor.render(),
                this.spectrumEditors[this.xc].setSpectrumWave(this.spectrumEditor.getSpectrumWave().spectrum)
            }
            )),
            this.spectrumEditor.container.addEventListener("mousedown", this.spectrumEditor.render),
            this.updatePlayButton(),
            this.vc) {
                for (let t = p.drumCount - 1; t >= 0; t--)
                    this.spectrumEditors[t] = new Ya(this.m,p.drumCount - 1 - t,!0),
                    this.spectrumEditors[t].setSpectrumWave(this.hi.Fc[p.drumCount - 1 - t].getSpectrumWave().spectrum);
                let t = nt.getChannelColor(this.m.song, this.m.channel);
                for (let t = 0; t < p.drumCount; t++) {
                    let e = J.button({
                        class: "no-underline",
                        style: "max-width: 2em;"
                    }, "" + (t + 1));
                    this.kc.push(e),
                    this.Mc.appendChild(e),
                    e.addEventListener("click", ( () => {
                        this.Sc(t)
                    }
                    ))
                }
                this.kc[p.drumCount - 1].classList.add("last-button"),
                this.kc[0].classList.add("selected-instrument"),
                this.Mc.style.setProperty("--text-color-lit", t.primaryNote),
                this.Mc.style.setProperty("--text-color-dim", t.secondaryNote),
                this.Mc.style.setProperty("--background-color-lit", t.primaryChannel),
                this.Mc.style.setProperty("--background-color-dim", t.secondaryChannel),
                this.Mc.style.display = "",
                this.spectrumEditor.container.style.display = "",
                this.spectrumEditor.setSpectrumWave(this.spectrumEditors[this.xc].getSpectrumWave().spectrum)
            } else
                this.Mc.style.display = "none",
                this.spectrumEditors[0] = this.spectrumEditor;
            setTimeout(( () => this.ci.focus())),
            this.spectrumEditor.render()
        }
        updatePlayButton() {
            this.m.synth.playing ? (this.ci.classList.remove("playButton"),
            this.ci.classList.add("pauseButton"),
            this.ci.title = "Pause (Space)",
            this.ci.innerText = "Pause") : (this.ci.classList.remove("pauseButton"),
            this.ci.classList.add("playButton"),
            this.ci.title = "Play (Space)",
            this.ci.innerText = "Play")
        }
    }
    const {button: Za, div: Xa, h2: tr, input: er, p: ir, a: nr} = J;
    let sr = !1;
    class or {
        constructor(t, e, i, n) {
            this.m = t,
            this.Le = e,
            this.Cc = i,
            this.Ac = n,
            this.bn = er({
                type: "file",
                accept: "image/*",
                text: "choose editor background image"
            }),
            this.Ec = er({
                type: "file",
                accept: "image/*",
                text: "choose website background image"
            }),
            this.Tc = er({
                type: "text",
                value: localStorage.getItem("customColors") || ":root {\n\t--page-margin: black;\n\t--editor-background: black;\n\t--hover-preview: white;\n\t--playhead: white;\n\t--primary-text: white;\n\t--secondary-text: #999;\n\t--inverted-text: black;\n\t--text-selection: rgba(119,68,255,0.99);\n\t--box-selection-fill: rgba(255,255,255,0.2);\n\t--loop-accent: #74f;\n\t--link-accent: #98f;\n\t--ui-widget-background: #444;\n\t--ui-widget-focus: #777;\n\t--pitch-background: #444;\n\t--tonic: #864;\n\t--fifth-note: #468;\n\t--white-piano-key: #bbb;\n\t--black-piano-key: #444;\n\t--white-piano-key-text: #131200;\n\t--black-piano-key-text: #fff;\n\t--use-color-formula: false;\n\t--track-editor-bg-pitch: #444;\n\t--track-editor-bg-pitch-dim: #333;\n\t--track-editor-bg-noise: #444;\n\t--track-editor-bg-noise-dim: #333;\n\t--track-editor-bg-mod: #234;\n\t--track-editor-bg-mod-dim: #123;\n\t--multiplicative-mod-slider: #456;\n\t--overwriting-mod-slider: #654;\n\t--indicator-primary: #74f;\n\t--indicator-secondary: #444;\n\t--select2-opt-group: #585858;\n\t--input-box-outline: #333;\n\t--mute-button-normal: #ffa033;\n\t--mute-button-mod: #9a6bff;\n\t--pitch1-secondary-channel: #0099A1;\n\t--pitch1-primary-channel:   #25F3FF;\n\t--pitch1-secondary-note:    #00BDC7;\n\t--pitch1-primary-note:      #92F9FF;\n\t--pitch2-secondary-channel: #A1A100;\n\t--pitch2-primary-channel:   #FFFF25;\n\t--pitch2-secondary-note:    #C7C700;\n\t--pitch2-primary-note:      #FFFF92;\n\t--pitch3-secondary-channel: #C75000;\n\t--pitch3-primary-channel:   #FF9752;\n\t--pitch3-secondary-note:    #FF771C;\n\t--pitch3-primary-note:      #FFCDAB;\n\t--pitch4-secondary-channel: #00A100;\n\t--pitch4-primary-channel:   #50FF50;\n\t--pitch4-secondary-note:    #00C700;\n\t--pitch4-primary-note:      #A0FFA0;\n\t--pitch5-secondary-channel: #D020D0;\n\t--pitch5-primary-channel:   #FF90FF;\n\t--pitch5-secondary-note:    #E040E0;\n\t--pitch5-primary-note:      #FFC0FF;\n\t--pitch6-secondary-channel: #7777B0;\n\t--pitch6-primary-channel:   #A0A0FF;\n\t--pitch6-secondary-note:    #8888D0;\n\t--pitch6-primary-note:      #D0D0FF;\n\t--pitch7-secondary-channel: #8AA100;\n\t--pitch7-primary-channel:   #DEFF25;\n\t--pitch7-secondary-note:    #AAC700;\n\t--pitch7-primary-note:      #E6FF92;\n\t--pitch8-secondary-channel: #DF0019;\n\t--pitch8-primary-channel:   #FF98A4;\n\t--pitch8-secondary-note:    #FF4E63;\n\t--pitch8-primary-note:      #FFB2BB;\n\t--pitch9-secondary-channel: #00A170;\n\t--pitch9-primary-channel:   #50FFC9;\n\t--pitch9-secondary-note:    #00C78A;\n\t--pitch9-primary-note:      #83FFD9;\n\t--pitch10-secondary-channel:#A11FFF;\n\t--pitch10-primary-channel:  #CE8BFF;\n\t--pitch10-secondary-note:   #B757FF;\n\t--pitch10-primary-note:     #DFACFF;\n\t--noise1-secondary-channel: #6F6F6F;\n\t--noise1-primary-channel:   #AAAAAA;\n\t--noise1-secondary-note:    #A7A7A7;\n\t--noise1-primary-note:      #E0E0E0;\n\t--noise2-secondary-channel: #996633;\n\t--noise2-primary-channel:   #DDAA77;\n\t--noise2-secondary-note:    #CC9966;\n\t--noise2-primary-note:      #F0D0BB;\n\t--noise3-secondary-channel: #4A6D8F;\n\t--noise3-primary-channel:   #77AADD;\n\t--noise3-secondary-note:    #6F9FCF;\n\t--noise3-primary-note:      #BBD7FF;\n\t--noise4-secondary-channel: #7A4F9A;\n\t--noise4-primary-channel:   #AF82D2;\n\t--noise4-secondary-note:    #9E71C1;\n\t--noise4-primary-note:      #D4C1EA;\n\t--noise5-secondary-channel: #607837;\n\t--noise5-primary-channel:   #A2BB77;\n\t--noise5-secondary-note:    #91AA66;\n\t--noise5-primary-note:      #C5E2B2;\n\t--mod1-secondary-channel:   #339955;\n\t--mod1-primary-channel:     #77fc55;\n\t--mod1-secondary-note:      #77ff8a;\n\t--mod1-primary-note:        #cdffee;\n\t--mod2-secondary-channel:   #993355;\n\t--mod2-primary-channel:     #f04960;\n\t--mod2-secondary-note:      #f057a0;\n\t--mod2-primary-note:        #ffb8de;\n\t--mod3-secondary-channel:   #553399;\n\t--mod3-primary-channel:     #8855fc;\n\t--mod3-secondary-note:      #aa64ff;\n\t--mod3-primary-note:\t    #f8ddff;\n\t--mod4-secondary-channel:   #a86436;\n\t--mod4-primary-channel:     #c8a825;\n\t--mod4-secondary-note:      #e8ba46;\n\t--mod4-primary-note:        #fff6d3;\n\t--mod-label-primary:        #999;\n\t--mod-label-secondary-text: #333;\n\t--mod-label-primary-text:   black;\n\t--disabled-note-primary:    #999;\n\t--disabled-note-secondary:  #666; }"
            }),
            this.Oe = Za({
                class: "cancelButton"
            }),
            this.Re = Za({
                class: "okayButton",
                style: "width:45%;"
            }, "Okay"),
            this.Ra = Za({
                style: "height: auto; min-height: var(--button-size);"
            }, "Reset to defaults"),
            this.container = Xa({
                class: "prompt noSelection",
                style: "width: 300px;"
            }, tr("Import"), ir({
                style: "text-align: left; margin: 0.5em 0;"
            }, "You can upload images to create a custom theme. The first image will become the editor background, and the second image will be tiled across the webpage."), Xa({
                style: "text-align: left; margin-top: 0.5em; margin-bottom: 0.5em;"
            }, "You can find a list of custom themes made by other users on the ", nr({
                target: "_blank",
                href: "https://docs.google.com/spreadsheets/d/1dGjEcLgJrPwzBExPmwA9pbE_KVQ3jNrnTBrd46d2IKo/edit"
            }, "custom theme sheet.")), Xa(), ir({
                style: "text-align: left; margin: 0;"
            }, "Editor Background Image:", this.bn), ir({
                style: "text-align: left; margin: 0.5em 0;"
            }, "Website Background Image:", this.Ec), Xa(), ir({
                style: "text-align: left; margin: 0;"
            }, "Replace the text below with your custom theme data to load it:"), this.Tc, Xa({
                style: "display: flex; flex-direction: row-reverse; justify-content: space-between;"
            }, this.Ra), Xa({
                style: "display: flex; flex-direction: row-reverse; justify-content: space-between;"
            }, this.Re), this.Oe),
            this.$e = () => {
                this.m.prompt = null,
                this.m.undo(),
                sr && setTimeout(( () => {
                    window.location.reload()
                }
                ), 50)
            }
            ,
            this.cleanUp = () => {
                this.Re.removeEventListener("click", this.$e),
                this.Oe.removeEventListener("click", this.$e),
                this.Ra.removeEventListener("click", this.Pc)
            }
            ,
            this.Pc = () => {
                window.localStorage.removeItem("colorTheme"),
                window.localStorage.removeItem("customTheme"),
                window.localStorage.removeItem("customTheme2"),
                window.localStorage.removeItem("customColors"),
                this.Le.q.style.backgroundImage = "",
                document.body.style.backgroundImage = "",
                this.Cc.style.backgroundImage = "",
                this.Ac.style.backgroundImage = "";
                const t = document.getElementById("secondImage");
                null != t && (t.style.backgroundImage = ""),
                sr = !0,
                this.$e()
            }
            ,
            this.Bc = () => {
                localStorage.setItem("customColors", this.Tc.value),
                window.localStorage.setItem("colorTheme", "custom"),
                this.m.colorTheme = "custom",
                sr = !0
            }
            ,
            this.wn = () => {
                const t = this.bn.files[0];
                if (!t)
                    return;
                const e = new FileReader;
                e.addEventListener("load", (t => {
                    let i = e.result;
                    window.localStorage.setItem("customTheme", i);
                    const n = `url("${window.localStorage.getItem("customTheme")}")`;
                    console.log("setting", n),
                    this.Le.q.style.backgroundImage = n,
                    console.log("done")
                }
                )),
                e.readAsDataURL(t)
            }
            ,
            this.Ic = () => {
                const t = this.Ec.files[0];
                if (!t)
                    return;
                const e = new FileReader;
                e.addEventListener("load", (t => {
                    let i = e.result;
                    window.localStorage.setItem("customTheme2", i);
                    const n = `url("${window.localStorage.getItem("customTheme2")}")`;
                    document.body.style.backgroundImage = `url(${i})`,
                    this.Cc.style.backgroundImage = n,
                    this.Ac.style.backgroundImage = n;
                    const s = document.getElementById("secondImage");
                    null != s && (s.style.backgroundImage = `url(${i})`)
                }
                )),
                e.readAsDataURL(t)
            }
            ,
            this.bn.addEventListener("change", this.wn),
            this.Ec.addEventListener("change", this.Ic),
            this.Tc.addEventListener("change", this.Bc),
            this.Re.addEventListener("click", this.$e),
            this.Oe.addEventListener("click", this.$e),
            this.Ra.addEventListener("click", this.Pc)
        }
    }
    const {button: ar, div: rr, h2: hr, select: lr, option: cr, optgroup: dr} = J;
    class pr {
        constructor(t) {
            this.m = t,
            this.Lc = lr({
                style: "width: 100%;"
            }, dr({
                label: "Default Themes"
            }, cr({
                value: "ultrabox dark"
            }, "UltraBox"), cr({
                value: "forest"
            }, "Forest"), cr({
                value: "canyon"
            }, "Canyon"), cr({
                value: "midnight"
            }, "Midnight"), cr({
                value: "beachcombing"
            }, "Beachcombing"), cr({
                value: "violet verdant"
            }, "Violet Verdant"), cr({
                value: "sunset"
            }, "Sunset"), cr({
                value: "autumn"
            }, "Autumn"), cr({
                value: "fruit"
            }, "Shadowfruit"), cr({
                value: "toxic"
            }, "Toxic"), cr({
                value: "roe"
            }, "Roe"), cr({
                value: "moonlight"
            }, "Moonlight"), cr({
                value: "portal"
            }, "Portal"), cr({
                value: "fusion"
            }, "Fusion"), cr({
                value: "inverse"
            }, "Inverse"), cr({
                value: "nebula"
            }, "Nebula"), cr({
                value: "roe light"
            }, "Roe Light"), cr({
                value: "amoled dark"
            }, "High Contrast Dark"), cr({
                value: "energized"
            }, "Energized"), cr({
                value: "neapolitan"
            }, "Neapolitan"), cr({
                value: "poly"
            }, "Poly"), cr({
                value: "blutonium"
            }, "Blutonium"), cr({
                value: "slushie"
            }, "Slushie")), dr({
                label: "Mod Themes"
            }, cr({
                value: "dark classic"
            }, "BeepBox Dark"), cr({
                value: "light classic"
            }, "BeepBox Light"), cr({
                value: "dark competition"
            }, "BeepBox Competition Dark"), cr({
                value: "jummbox classic"
            }, "JummBox Dark"), cr({
                value: "modbox classic"
            }, "Modbox"), cr({
                value: "sandbox classic"
            }, "Sandbox"), cr({
                value: "harrybox"
            }, "Haileybox"), cr({
                value: "brucebox"
            }, "Brucebox"), cr({
                value: "shitbox 3.0"
            }, "Shitbox 1.0/3.0"), cr({
                value: "shitbox 2.0"
            }, "Shitbox 2.0"), cr({
                value: "nerdbox"
            }, "NerdBox"), cr({
                value: "zefbox"
            }, "Zefbox"), cr({
                value: "cardboardbox classic"
            }, "Cardboardbox"), cr({
                value: "blubox classic"
            }, "Blubox"), cr({
                value: "dogebox classic"
            }, "Dogebox"), cr({
                value: "wackybox"
            }, "Wackybox"), cr({
                value: "todbox dark mode"
            }, "Todbox Dark Mode"), cr({
                value: "mainbox 1.0"
            }, "Mainbox"), cr({
                value: "microbox"
            }, "MicroBox"), cr({
                value: "paandorasbox"
            }, "PaandorasBox"), cr({
                value: "foxbox"
            }, "FoxBox"), cr({
                value: "midbox"
            }, "Midbox"), cr({
                value: "dogebox2"
            }, "Dogebox2"), cr({
                value: "abyssbox classic"
            }, "AbyssBox Classic"), cr({
                value: "abyssbox light"
            }, "AbyssBox Light"), cr({
                value: "nepbox"
            }, "Nepbox"), cr({
                value: "slarmoosbox"
            }, "Slarmoo's Box")), dr({
                label: "Misc"
            }, cr({
                value: "azur lane"
            }, "Azur Lane"), cr({
                value: "custom"
            }, "Custom"))),
            this.Oe = ar({
                class: "cancelButton"
            }),
            this.Re = ar({
                class: "okayButton",
                style: "width:45%;"
            }, "Okay"),
            this.container = rr({
                class: "prompt noSelection",
                style: "width: 220px;"
            }, hr("Set Theme"), rr({
                style: "display: flex; flex-direction: row; align-items: center; height: 2em; justify-content: flex-end;"
            }, rr({
                class: "selectContainer",
                style: "width: 100%;"
            }, this.Lc)), rr({
                style: "display: flex; flex-direction: row-reverse; justify-content: space-between;"
            }, this.Re), this.Oe),
            this.lastTheme = window.localStorage.getItem("colorTheme"),
            this.$e = () => {
                null != this.lastTheme ? nt.setTheme(this.lastTheme) : nt.setTheme(nt.defaultTheme),
                this.m.undo()
            }
            ,
            this.cleanUp = () => {
                this.Re.removeEventListener("click", this.He),
                this.Oe.removeEventListener("click", this.$e),
                this.container.removeEventListener("keydown", this.Ge)
            }
            ,
            this.Ge = t => {
                "BUTTON" != t.target.tagName && 13 == t.keyCode && this.He()
            }
            ,
            this.He = () => {
                window.localStorage.setItem("colorTheme", this.Lc.value),
                this.m.prompt = null,
                this.m.prefs.colorTheme = this.Lc.value,
                this.m.undo()
            }
            ,
            this.Dc = () => {
                nt.setTheme(this.Lc.value),
                this.m.notifier.changed()
            }
            ,
            null != this.lastTheme && (this.Lc.value = this.lastTheme),
            this.Re.addEventListener("click", this.He),
            this.Oe.addEventListener("click", this.$e),
            this.container.addEventListener("keydown", this.Ge),
            this.Lc.addEventListener("change", this.Dc)
        }
    }
    const {button: mr, div: ur, p: fr, h2: yr, h3: br} = J;
    class gr {
        constructor(t, e) {
            let i;
            switch (this.m = t,
            this.zc = mr({
                class: "cancelButton"
            }),
            this.$e = () => {
                this.m.undo()
            }
            ,
            this.cleanUp = () => {
                this.zc.removeEventListener("click", this.$e)
            }
            ,
            e) {
            case "scale":
                i = ur(yr("Scale"), fr("This setting limits the available pitches for adding notes. You may think that there's no point in limiting your choices, but the set of pitches you use has a strong influence on the mood and feel of your song, and these scales serve as guides to help you choose appropriate pitches. Don't worry, you can change the scale at any time, so you're not locked into it. Try making little melodies using all the available pitches of a scale to get a sense for how it sounds."), fr('The most common scales are major and minor. Assuming your song uses all pitches in the scale and especially "tonic" pitches (the purple rows in the pattern editor) then major scales tend to sound more playful or optimistic, whereas minor scales sound more serious or sad.'));
                break;
            case "key":
                i = ur(yr("Song Key"), fr('This setting can shift the frequency of every note in your entire song up or down, keeping the "tonic" pitches (the brown rows in the pattern editor) aligned with the selected "key" pitch.'), fr('If you\'ve already placed some notes but they don\'t emphasize "tonic" pitches then the selected key isn\'t very meaningful. You can select the "Detect Key" option in the key menu to automatically align the most emphasized notes with "tonic" pitches.'));
                break;
            case "key_octave":
                i = ur(yr("Octave"), fr('This setting can shift the "key" by an octave, allowing you to use a B- or C+ key.'), fr(`This goes from ${p.octaveMin} to ${p.octaveMax}.`));
                break;
            case "tempo":
                i = ur(yr("Song Tempo"), fr('This setting controls the speed of your song, measured in beats-per-minute. A "beat" is the duration of the little gray rectangles in the pattern editor. (In conventional music notation, a "quarter note" is usually equivalent to "beat".)'));
                break;
            case "reverb":
                i = ur(yr("Reverb"), fr('Reverb is like a continuous echo effect. A little bit helps instruments sound more natural. Adding a lot of reverb can add sense of depth or mystery, but too much reverb can kinda "smear" sounds so that it\'s harder to distinguish notes or instruments, especially for lower "bass" notes.'));
                break;
            case "rhythm":
                i = ur(yr("Rhythm"), fr("This setting determines how beats are divided. The pattern editor helps you align notes to fractions of a beat based on this setting."), fr("If you've already placed some notes but they don't align with the selected rhythm, you can select the \"Snap Notes To Rhythm\" option in the rhythm menu to force the notes in the currently selected pattern(s) to align with the selected rhythm."));
                break;
            case "instrumentIndex":
                i = ur(yr("Instrument Number"), fr('In the "Channel Settings" option from UltraBox\'s "Edit" menu, there are a few ways to enable multiple instruments per channel.'), fr("First, you could enable multiple simultaneous instruments per channel. All of the channel's instruments will play all of the notes in the channel at the same time, and you can click an instrument number to view and edit its settings."), fr("Second, you could enable different instruments per pattern. Only one of the instruments will play at any given time, but you can click the instrument number to change which instrument is used for the currently selected pattern(s)."), fr("Finally, you can enable them both, in which case you can click an instrument number once to view it, and again to toggle whether the instrument is used for the currently selected pattern(s)."), fr("Either way, you can click the + button to add more instruments to a channel, and you can press shift and a number key on your keyboard to select an instrument as if you had clicked the corresponding button here."));
                break;
            case "instrumentVolume":
                i = ur(yr("Instrument Volume"), fr("This setting controls the volume of the selected instrument without affecting the volume of the other instruments. This allows you to balance the loudness of each instrument relative to each other."), fr("Please be careful when using volume settings above 0. This indicates amplification and too much of that can trip the audio limiter built into this tool. This can lead to your song sounding muffled if overused. But when used carefully, amplification can be a powerful tool!"));
                break;
            case "pan":
                i = ur(yr("Instrument Panning"), fr("If you're listening through headphones or some other stereo sound system, this controls the position of the instrument and where the sound is coming from, ranging from left to right."), fr("As a suggestion, composers often put lead melodies, drums, and basses in the center, and spread other instruments toward either side. If too many instruments seem like they're coming from the same place, it can feel crowded and harder to distinguish individual sounds, especially if they cover a similar pitch range."));
                break;
            case "panDelay":
                i = ur(yr("Stereo Delay"), fr("When panning, a slight delay is often added between the left and right ear to help make a sound feel more 'directional'. For example, in the real world your left ear will hear a sound coming from the left just slightly before the right ear."), fr("This setting controls how much delay is added. When this is set to minimum, panning only affects the volume of the left/right ear without changing the delay. This can help to get a more 'uniform' feeling sound, which can be desirable for making 8-bit music."));
                break;
            case "arpeggioSpeed":
                i = ur(yr("Arpeggio Speed"), fr("This setting affects how fast your chord will 'arpeggiate', or cycle between notes. With a fast arpeggio speed it will sound rapid-fire, with a slow speed you can hear each note one after another."));
                break;
            case "twoNoteArpeggio":
                i = ur(yr("Faster Two-Note Arpeggio"), fr("This setting makes arpeggios with only two notes in them happen twice as fast. Arpeggios with more notes in them are unaffected."));
                break;
            case "detune":
                i = ur(yr("Detune"), fr("This setting can be used to finely control the pitch of your instrument. It is in units of 'cents', 100 of which equal a pitch shift of one semitone."), fr("Careful - you can quickly get very dissonant sounding songs by using this setting."));
                break;
            case "instrumentType":
                i = ur(yr("Instrument Type"), fr("UltraBox comes with many instrument presets, try them out! You can also create your own custom instruments!"), fr('There are also buttons for copying and pasting instruments at the bottom of the instrument settings tab, and for generating random instruments in the "Randomize" category in the instrument type menu.'));
                break;
            case "eqFilter":
                i = ur(yr("EQ Filter"), fr("Filters are a way of emphasizing or diminishing different parts of a sound. Musical notes have a fundamental (base) frequency, but the sound of a musical note also has parts at higher frequencies and filters can adjust the volume of each of these parts based on their frequency."), fr("Click in the filter editor to insert, delete, or drag a filter control point. The horizontal position of the point determines which frequencies it affects, and the vertical position determines how the volume is affected at that frequency."), fr('Insert a new point on the left side of the filter editor to add a "high-pass" filter point, which additionally reduces the volume of lower frequencies, or insert a new point on the right side to add a "low-pass" filter point which reduces the volume of higher frequencies.'), fr('You can also enable a "Note Filter" as an effect. EQ and note filters are mostly the same, but have different purposes. EQ filters are for overall adjustments, whereas note filters are for dynamic control and can be moved with envelopes. Note filters also change how the distortion effect sounds.'));
                break;
            case "noteFilter":
                i = ur(yr("Note Filter"), fr("Note filters are mostly the same as EQ filters, but have a different purpose. EQ filters are for overall adjustments, whereas note filters are for dynamic control and can be moved with envelopes. Note filters also change how the distortion effect sounds."), fr("Filters are a way of emphasizing or diminishing different parts of a sound. Musical notes have a fundamental (base) frequency, but the sound of a musical note also has parts at higher frequencies and filters can adjust the volume of each of these parts based on their frequency."), fr("Click in the filter editor to insert, delete, or drag a filter control point. The horizontal position of the point determines which frequencies it affects, and the vertical position determines how the volume is affected at that frequency."), fr('Insert a new point on the left side of the filter editor to add a "high-pass" filter point, which additionally reduces the volume of lower frequencies, or insert a new point on the right side to add a "low-pass" filter point which reduces the volume of higher frequencies.'));
                break;
            case "fadeInOut":
                i = ur(yr("Fade In/Out"), fr("This setting controls how long it takes for notes to reach full volume at the beginning or decay to silence at the end."), fr("An instant fade-in sounds like instruments that are played by hitting or plucking, whereas slower fade-ins sound like instruments that are played by blowing air."), fr("You can also make the fade-out start before the note ends to leave a gap before the next note starts, or after the note ends to allow the sound of the end of the note to overlap with the start of the next note."));
                break;
            case "transition":
                i = ur(yr("Transition"), fr("Usually, when one note ends at the same time another begins, the old note will fade out and the new note will fade in based on the fade in/out settings, but this setting can override that, connecting the end of one note to the beginning of the next."), fr('The "interrupt" transition makes the wave suddenly change from the old note\'s frequency to the new note\'s frequency without any fading, but still restarts envelopes at the beginning of the new note. The "continue" transition is similar but it doesn\'t even restart envelopes, and can be used to make each of the notes in a chord start or stop at different times!'), fr('The "slide" transition makes the pitch shift quickly but not instantaneously from the old note\'s frequency to the new note\'s frequency, and softly restarts envelopes. The "slide in pattern" transition is the same except it doesn\'t connect the last note in a pattern to the first note in the next pattern.'));
                break;
            case "chipWave":
                i = ur(yr("Chip Wave"), fr("UltraBox comes with some sound waves based on classic electronic sound chips, as well as several unique waves. This is the basic source of the sound of the instrument, which is modified by the other instrument settings."));
                break;
            case "chipNoise":
                i = ur(yr("Noise"), fr("UltraBox comes with several basic noise sounds. These do not have any distinct musical pitch, and can be used like drums to create beats and emphasize your song's rhythm."));
                break;
            case "supersawDynamism":
                i = ur(yr("Supersaw Dynamism"), fr("A supersaw is a combination of many sawtooth waves, and this setting controls the contribution of extra sawtooth waves."), fr('At the low end of the slider, only the first wave is contributing to the sound, which sounds like an ordinary static sawtooth wave. At the maximum setting, all of the waves are contributing equally and the resulting tone can randomly shift depending on how the waves line up with each other, similar to the "unison" and "chorus" settings.'));
                break;
            case "supersawSpread":
                i = ur(yr("Supersaw Spread"), fr("A supersaw is a combination of many sawtooth waves, and this setting controls the distance between their frequencies. The dynamism setting must be used for the extra waves to have any effect."), fr('At the low end of the spread slider, all of the voices have the same frequency but random phase, resulting in a different sound every time a note starts. In the middle, the waves all have slightly different frequencies that shift in and out of phase over time similar to the "unison" and "chorus" settings, creating a classic supersaw sound. At the extreme end, the frequencies are so far apart they sound dissonant.'));
                break;
            case "supersawShape":
                i = ur(yr("Supersaw Shape"), fr("This supersaw instrument includes an option to change the shape of the waves from sawtooth waves to pulse waves. Use this setting to morph between the two shapes."), fr("When a pulse wave shape is used, you can also control the pulse width with a separate setting."));
                break;
            case "pulseWidth":
                i = ur(yr("Pulse Wave Width"), fr("This setting controls the shape and sound of a pulse wave. At the minimum width, it sounds light and buzzy. At the maximum width, it is shaped like a classic square wave."));
                break;
            case "unison":
                i = ur(yr("Unison"), fr("This instrument can play two identical waves at different frequencies. When two waves play at slightly different frequencies, they move in and out of phase with each other over time as different parts of the waves line up. This creates a dynamic, shifting sound. Pianos are a common example of this kind of sound, because each piano key strikes multiple strings that are tuned to slightly different frequencies."), fr('The distance between two frequencies is called an "interval", and this setting controls how large it is. If the interval is too wide, then the waves may sound out-of-tune and "dissonant". However, if the interval is even larger, then the two frequencies can even be distinct pitches.'));
                break;
            case "chords":
                i = ur(yr("Chords"), fr("When multiple different notes occur at the same time, this is called a chord. Chords can be created in UltraBox's pattern editor by adding notes above or below another note."), fr('This setting determines how chords are played. The standard option is "simultaneous" which starts playing all of the pitches in a chord at the same instant. The "strum" option is similar, but plays the notes starting at slightly different times. The "arpeggio" option is used in "chiptune" style music and plays a single tone that rapidly alternates between all of the pitches in the chord.'), fr('Some UltraBox instruments have an option called "custom interval" which uses the chord notes to control the interval between the waves of a single tone. This can create strange sound effects when combined with FM modulators.'));
                break;
            case "vibrato":
                i = ur(yr("Vibrato"), fr("This setting causes the frequency of a note to wobble slightly. Singers and violinists often use vibrato."));
                break;
            case "vibratoDepth":
                i = ur(yr("Vibrato Depth"), fr("This setting affects the depth of your instrument's vibrato, making the wobbling effect sound stronger or weaker."));
                break;
            case "vibratoDelay":
                i = ur(yr("Vibrato Delay"), fr("This setting changes when vibrato starts to kick in after a note is played. Vibrato is most common for long held notes and less common in short notes, so this can help you achieve that effect."));
                break;
            case "vibratoSpeed":
                i = ur(yr("Vibrato Speed"), fr("This setting determines how fast the vibrato's up-and-down wobble effect will happen for your instrument."));
                break;
            case "vibratoType":
                i = ur(yr("Vibrato Type"), fr("This determines the way vibrato causes your instrument's pitch to wobble. The normal type is smooth up and down, the shaky type is chaotic."));
                break;
            case "algorithm":
                i = ur(yr("FM Algorithm"), fr("FM Synthesis is a mysterious but powerful technique for crafting sounds, popularized by Yamaha keyboards and the Sega Genesis/Mega Drive. It may seem confusing, but try playing around with the options until you get a feel for it, or check out some of the preset examples!"), fr("This FM synthesizer uses up to four waves, numbered 1, 2, 3, and 4. Each wave may have its own frequency and volume."), fr('There are two kinds of waves: "carrier" waves play a tone out loud, but "modulator" waves distort other waves instead. Wave 1 is always a carrier and plays a tone, but other waves may distort it. The "Algorithm" setting determines which waves are modulators, and which other waves those modulators distort. For example, "1←2" means that wave 2 modulates wave 1, and wave 1 plays out loud.'));
                break;
            case "feedbackType":
                i = ur(yr("Feedback Type"), fr("Modulators distort in one direction (like 1←2), but you can also use the feedback setting to make any wave distort in the opposite direction (1→2), or even itself (1⟲)."));
                break;
            case "feedbackVolume":
                i = ur(yr("Feedback Distortion"), fr("This setting controls the amount of feedback distortion based on the feedback type setting."));
                break;
            case "operatorFrequency":
                i = ur(yr("Operator Frequency"), fr('This setting controls the frequency of an individual FM wave, relative to the fundamental frequency of the note. The multiplier 1× is the same as the fundamental frequency, whereas 2x would be an octave (12 semitones) above it. The frequencies with a "~" are slightly detuned and shift in and out of phase over time compared to the other frequencies.'), fr('Try different combinations of a "carrier" wave and a "modulator" wave with different frequencies to get a feel for how they sound together.'));
                break;
            case "operatorVolume":
                i = ur(yr("Operator Volume"), fr('This setting controls the volume of "carrier" waves, or the amount of distortion that "modulator" waves apply to other waves.'));
                break;
            case "spectrum":
                i = ur(yr("Spectrum"), fr("This setting allows you to draw your own noise spectrum! This is good for making drum sounds."), fr("If you only use certain frequencies and a soft fade in/out, it's also possible to make howling wind sounds or even musical wind instruments."), fr("The left side of the spectrum editor controls the noise energy at lower frequencies, and the right side controls higher frequencies."));
                break;
            case "harmonics":
                i = ur(yr("Harmonics"), fr("This setting allows you to design your own sound wave! Most musical waves are actually a combination of sine waves at certain frequencies, and this lets you control the volume of each sine wave individually."), fr("The left side of the harmonics editor controls the sine wave volumes at lower frequencies, and the right side controls higher frequencies."));
                break;
            case "effects":
                i = ur(yr("Effects"), fr("UltraBox has many different kinds of special effects you can add to instruments. You can turn on multiple effects at once, and they can be configured individually. Try them all out!"));
                break;
            case "drumsetEnvelope":
                i = ur(yr("Drumset Envelope"), fr("This drumset comes with a low-pass filter, and this setting can dynamically change the low-pass filter frequency over time. Each row in the pattern editor can have a different envelope shape."));
                break;
            case "drumsetSpectrum":
                i = ur(yr("Drumset Spectrum"), fr("This setting allows you to draw your own noise spectrum! This is good for making drumsets. Each row in the pattern editor gets its own spectrum."), fr("The left side of the spectrum editor controls the noise energy at lower frequencies, and the right side controls higher frequencies."));
                break;
            case "chorus":
                i = ur(yr("Chorus"), fr("The chorus effect combines multiple copies of the instrument's sound and adds a bit of vibrato to simulate an ensemble of instruments or voices. Drag the slider to control how much chorus is added."));
                break;
            case "echoSustain":
                i = ur(yr("Echo Volume"), fr("The echo effect repeats the instrument's sound after a delay. Each echo is a little bit quieter than the last, and this setting controls how much quieter."));
                break;
            case "echoDelay":
                i = ur(yr("Echo Delay"), fr("The echo effect repeats the instrument's sound after a delay, and this setting controls how long the delay is."));
                break;
            case "pitchShift":
                i = ur(yr("Pitch Shift"), fr("This setting makes instruments play higher or lower pitches than the ones displayed in the pattern editor. Be careful that you don't confuse yourself!"), fr("You can combine this with envelopes to bend pitch over time, or play multiple simultaneous instruments with different pitch shifts for interesting layered sounds."), fr('The intervals created by this setting are in "just intonation" which means they stay in phase with the original pitch instead of shifting in and out of phase over time. If you want the shifting, add the detune effect!'));
                break;
            case "detune":
                i = ur(yr("Detune"), fr('This setting slightly adjusts the frequency of notes played by the instrument. You can use a little bit to add a pleasing shifting sound similar to the "unison" feature when combined with other instruments. If you use too much, then the instrument may sound unpleasantly out-of-tune.'));
                break;
            case "distortion":
                i = ur(yr("Distortion"), fr("This is the famous electric guitar effect! However, there are some things to be aware of."), fr('First, most chords don\'t sound right when combined with heavy distortion. The only chords commonly used with distorted electric guitars are "power chords" which consist of a root note, a "fifth" note above that, and/or any octaves of those two notes.'), fr("Second, the distortion sound depends a lot on filtering. In particular, I recommend enabling the note filter effect, and adding both high-pass and low-pass points to the note filter. (Note filters are applied first, then distortion which transforms the sound based on that filtering, then the EQ filter is applied last.)"), fr("Finally, I recommend adjusting the fade-out setting to allow the end of each note to overlap a little bit with the beginning of the next, but not too much!"));
                break;
            case "bitcrusherQuantization":
                i = ur(yr("Bitcrusher Quantization"), fr("This effect makes stuff sounds harsher, artificial, and \"low quality\", which is great if that's what you're going for!"));
                break;
            case "bitcrusherFreq":
                i = ur(yr("Frequency Quantization"), fr("The bitcrusher effect comes with an additional frequency quantization effect! This is a fun one to play with, especially when combined with the note filter effect."), fr("Every other notch on this slider is aligned with the currently selected key of the song, and the in-between notches are aligned with the tritones of the key."));
                break;
            case "envelopes":
                i = ur(yr("Envelopes"), fr("Envelopes are a way to dynamically adjust various other settings over time, usually based on how long the note lasts. Press the + button to add an envelope, then use the menus below to select which setting to control and the curve of the envelope. Try different combinations to see how they sound!"), fr('Most envelope curves restart from the beginning every time a new note plays. The "note size" option is based on the note width as drawn in the pattern editor.'), fr("Envelope curves move in the range from 0 to 1 (or vice versa), where 0 means as quiet as possible and 1 is the same as the corresponding position selected in the instrument settings above. If multiple envelopes are targetting the same setting, they are multiplied before applying to the setting."));
                break;
            case "discreteEnvelope":
                i = ur(yr("Use Discrete Envelopes?"), fr("Envelopes are usually interpolated, meaning they change continuously and smoothly. This setting, when ticked, makes envelopes not interpolate. It's a small difference, but can be helpful for some chip noises, and it's most noticeable with the 'blip' transitions."));
                break;
            case "envelopeSpeed":
                i = ur(yr("Envelope Speed"), fr("This setting controls the speed of ALL envelopes for the instrument. Each envelope 'plays' at a certain speed, and this slider can scale it to play faster or slower. Use this to fine-tune your tremolo or how fast something decays to get just the right effect."), fr("Note that, while this setting is limited in the sense that it controls all envelopes at once, you can still achieve a variety of outcomes by trying combinations of modes of each envelope type, which typically differ only in speed."));
                break;
            case "usedInstrument":
                i = ur(br("'Is this instrument used somewhere else?'"), fr("This indicator will light up when the instrument you're currently looking at is used in another place in your song (outside the selection)."), fr("This can be useful when you're not sure if you've used the instrument before and making edits carelessly could change other parts of the song."));
                break;
            case "usedPattern":
                i = ur(br("'Is this pattern used somewhere else?'"), fr("This indicator will light up when the pattern you're currently looking at is used in another place in your song (outside the selection)."), fr("This can be useful when you're not sure if you've used the pattern before and making edits carelessly could change other parts of the song."));
                break;
            case "modChannel":
                i = ur(yr("Modulator Channel"), fr("Modulators can be used to change settings in your song automatically over time. This technique is also known as automation."), fr("This setting controls which channel the modulators will take effect for. If you choose 'Song', you can change song-wide settings too!"));
                break;
            case "modInstrument":
                i = ur(yr("Modulator Instrument"), fr("Modulators can be used to change settings in your song automatically over time. This technique is also known as automation."), fr("This setting controls which instrument your modulator will apply to within the given channel you've chosen."), fr("If you choose 'all', every instrument in the channel will be affected. If you choose 'active', just the current ones used in this pattern will be instead."), fr("Note that with 'all' or 'active', effects will only be applied to instruments that the effect is applicable on. For example if an instrument does not have panning effects, modulating panning will not affect it."));
                break;
            case "modSet":
                i = ur(yr("Modulator Setting"), fr("This is the parameter that you want to change with this modulator. For example, if you set this to 'Tempo', you can speed up or slow down your song by laying notes in the pattern editor."), fr("Note that you'll see different options if your channel is set to 'Song' versus a channel number. With 'Song', you'll see song-wide settings such as tempo. With a channel, you'll see specific instrument settings. Adding more effects to the instrument causes modulators for them to be available, so be sure to experiment!"), fr("Most modulators behave as you'd expect and work just as if you were moving their associated slider. Click the '?' when you have a setting selected to get more info about it!"));
                break;
            case "modFilter":
                i = ur(yr("Filter Target"), fr("This setting specifies which parameter of your targeted filter you would like to change."), fr("With the 'morph' setting, the note value for your modulator represents the number of a subfilter to 'morph' into over time. For example, dragging a note from 0 to 7 will morph from your main filter to the 7th subfilter. To change how your subfilters are set up, click the '+' button on the target filter."), fr("With a Dot setting, you can fine-tune the exact location of every dot on your filter graph. Note that this is extremely intensive if you want to modulate all dots - a morph is better in that case - but this can come in handy for small adjustments."));
                break;
            case "transitionBar":
                i = ur(yr("Tie Notes Over Bars"), fr("With this option ticked, notes won't transition across bars if you put notes with the same pitches at the start of the next bar. Instead they will 'tie over' and sound like one long note."));
                break;
            case "clicklessTransition":
                i = ur(yr("Clickless Transition"), fr("Sometimes, seamless and other transition types can make audible 'clicks' when changing between notes. Ticking this option will cause those clicks to be silenced as much as possible."));
                break;
            case "aliases":
                i = ur(yr("Aliasing"), fr("UltraBox applies a technique called 'anti-aliasing' to instruments normally to help them sound cleaner even at high frequencies and low sample rates."), fr("When this setting is ticked that technique is disabled, so you may hear strange audio artifacts especially at high pitches and when bending notes. However, this can lend a grungy sound to an instrument that could be desirable."));
                break;
            case "operatorWaveform":
                i = ur(yr("Operator Waveform"), fr("This setting controls the what kind of sound wave an individual FM wave uses."), fr("By defualt the FM synth uses sinewaves."));
                break;
            case "filterType":
                i = ur(yr("Filter Type"), fr("Toggling these buttons lets you choose between a simple filter interface with two sliders, or the more advanced filter graph."), fr("The two-slider version controls a single low-pass filter and was used in legacy versions. It is not as powerful, but if you feel overwhelmed you can start with this."), fr("Note that switching from the simple interface to the advanced interface will convert your current settings, so you can also use it as a basis for later tweaking."));
                break;
            case "filterCutoff":
                i = ur(yr("Low-Pass Filter Cutoff Frequency"), fr('The lowest setting feels "muffled" or "dark", and the highest setting feels "harsh" or "bright".'), fr("Most sounds include a range of frequencies from low to high. UltraBox instruments have a filter that allows the lowest frequencies to pass through at full volume, but can reduce the volume of the higher frequencies that are above a cutoff frequency. This setting controls the cutoff frequency and thus the range of higher frequencies that are reduced."), fr("This cutoff setting also determines which frequency resonates when the resonance peak setting is used."));
                break;
            case "filterResonance":
                i = ur(yr("Low-Pass Filter Resonance Peak"), fr("Increasing this setting emphasizes a narrow range of frequencies, based on the position of the filter cutoff setting. This can be used to imitate the resonant bodies of acoustic instruments and other interesting effects."), fr("The filter preserves the volume of frequencies that are below the cutoff frequency, and reduces the volume of frequencies that are above the cutoff. If this setting is used, the filter also increases the volume of frequencies that are near the cutoff."));
                break;
            case "loopControls":
                i = ur(yr("Loop Controls"), fr("This enables the use of parameters that control how a chip wave should repeat."));
                break;
            case "loopMode":
                i = ur(yr("Loop Mode"), fr("This sets the way the chip wave loops when its ends are reached."), fr('The "Loop" mode is the default: when the end of the loop is reached, it will jump back to the starting point of the loop.'), fr('The "Ping-Pong" mode starts playing the chip wave backwards when the end of the loop is reached. Once it reaches the start of the loop, it will start playing forwards again, endlessly going back and forth.'), fr('The "Play Once" mode stops the chip wave once the end is reached (or the start of the loop, if it\'s playing backwards).'), fr('The "Play Loop Once" mode stops the chip wave once the end of the loop is reached (or the start of the loop, if it\'s playing backwards).'));
                break;
            case "loopStart":
                i = ur(yr("Loop Start Point"), fr('This specifies where the loop region of the chip wave starts. It\'s measured in "samples", or rather, it refers to a point on a waveform.'), fr('Be careful with tiny loop sizes (especially combined with high pitches), they may re-introduce aliasing even if the "Aliasing" checkbox is unchecked.'));
                break;
            case "loopEnd":
                i = ur(yr("Loop End Point"), fr('This specifies where the loop region of the chip wave ends. It\'s measured in "samples", or rather, it refers to a point on a waveform.'), fr("The button next to the input box sets this to end of the chip wave."), fr('Be careful with tiny loop sizes (especially combined with high pitches), they may re-introduce aliasing even if the "Aliasing" checkbox is unchecked.'));
                break;
            case "offset":
                i = ur(yr("Offset"), fr('This specifies where the chip wave should start playing from. You can use this to chop up a large sample, to say, turn a drum loop into a drum kit! It\'s measured in "samples", or rather, it refers to a point on a waveform.'));
                break;
            case "backwards":
                i = ur(yr("Backwards"), fr("When set, the chip wave will start playing backwards. After checking this, you may want to adjust the offset to start from a different point that makes sense for this mode."));
                break;
            case "decimalOffset":
                i = ur(yr("Decimal Offset"), fr("The decimal offset is subtracted from the pulse width value, enabling the use of numbers such as 12.5 or 6.25. This could be useful if you're trying to recreate the sound of old soundchips."));
                break;
            case "unisonVoices":
                i = ur(yr("Unison Voices"), fr('This setting controls how many voices there are in a unison. Unisons such as "none" or "detune" use 1 voice, while most other unisons use 2 voices.'));
                break;
            case "unisonSpread":
                i = ur(yr("Unison Spread"), fr("This setting controls the distance between the two voices, in semitones. A small amount of spread causes the voice's waves to shift in and out from each other, causing a shimmering effect. Larger spread will cause the voices to act like separate notes."));
                break;
            case "unisonOffset":
                i = ur(yr("Unison Offset"), fr("This setting controls the detune applied to BOTH voices, in semitones."));
                break;
            case "unisonExpression":
                i = ur(yr("Unison Volume"), fr("This setting controls the unison volume. Use this if the unison makes your instrument too loud in comparison to other instruments."));
                break;
            case "unisonSign":
                i = ur(yr("Unison Sign"), fr("This setting is a volume multiplier applied to the second voice. This setting will only work correctly with two voices."));
                break;
            default:
                if (e.indexOf("modSetInfo") >= 0) {
                    let n = +e[e.length - 1]
                      , s = t.song.channels[t.channel].instruments[t.getCurrentInstrument()].modulators[n]
                      , o = [];
                    for (let t = 0; t < p.modulators[s].promptDesc.length; t++)
                        o.push(fr(p.modulators[s].promptDesc[t].replace("$LO", "" + p.modulators[s].convertRealFactor).replace("$MID", "" + (p.modulators[s].convertRealFactor + p.modulators[s].maxRawVol / 2)).replace("$HI", "" + (p.modulators[s].convertRealFactor + p.modulators[s].maxRawVol))));
                    o[o.length - 1].style.setProperty("color", "var(--secondary-text)"),
                    i = ur(yr(p.modulators[s].promptName), o);
                    break
                }
                throw new Error("Unhandled TipPrompt type: " + e)
            }
            this.container = ur({
                class: "prompt",
                style: "width: 300px;"
            }, i, this.zc),
            setTimeout(( () => this.zc.focus())),
            this.zc.addEventListener("click", this.$e)
        }
    }
    class wr {
        constructor(t, e) {
            this.m = t,
            this.hi = e,
            this.qc = J.select({
                style: "width: 32px; height: " + p.barEditorHeight + "px; top: 0px; position: absolute; opacity: 0"
            }, J.option({
                value: "barBefore"
            }, "Insert Bar Before"), J.option({
                value: "barAfter"
            }, "Insert Bar After"), J.option({
                value: "deleteBar"
            }, "Delete This Bar")),
            this.Nc = J.div({
                style: `display: flex; flex-direction: column; padding-top: ${p.barEditorHeight}px`
            }),
            this.Oc = Y.g(),
            this.k = Y.rect({
                fill: nt.playhead,
                x: 0,
                y: 0,
                width: 4,
                height: 128
            }),
            this.Rc = Y.rect({
                fill: "none",
                stroke: nt.hoverPreview,
                "stroke-width": 2,
                "pointer-events": "none",
                x: 1,
                y: 1,
                width: 30,
                height: 30
            }),
            this.Kr = Y.path({
                fill: nt.invertedText,
                stroke: nt.invertedText,
                "stroke-width": 1,
                "pointer-events": "none"
            }),
            this.Jr = Y.path({
                fill: nt.invertedText,
                stroke: nt.invertedText,
                "stroke-width": 1,
                "pointer-events": "none"
            }),
            this.$c = Y.path({
                fill: nt.uiWidgetBackground,
                stroke: nt.uiWidgetBackground,
                "stroke-width": 1,
                "pointer-events": "none"
            }),
            this.gh = Y.rect({
                class: "dashed-line dash-move",
                fill: nt.boxSelectionFill,
                stroke: nt.hoverPreview,
                "stroke-width": 2,
                "stroke-dasharray": "5, 3",
                "fill-opacity": "0.4",
                "pointer-events": "none",
                visibility: "hidden",
                x: 1,
                y: 1,
                width: 62,
                height: 62
            }),
            this.q = Y.svg({
                style: "position: absolute; top: 0;"
            }, this.$c, this.gh, this.Oc, this.Rc, this.Kr, this.Jr, this.k),
            this.Hc = J.select({
                class: "trackSelectBox",
                style: "background: none; border: none; appearance: none; border-radius: initial; box-shadow: none; color: transparent; position: absolute; touch-action: none;"
            }),
            this.container = J.div({
                class: "noSelection",
                style: `background-color: ${nt.editorBackground}; position: relative; overflow: hidden;`
            }, this.Nc, this.q, this.Hc, this.qc),
            this._c = [],
            this.Vc = [],
            this.N = 0,
            this.Ze = 0,
            this.Gc = 0,
            this.Wc = 0,
            this.jc = 0,
            this.Uc = 0,
            this.R = !1,
            this.Kc = !1,
            this.Si = !1,
            this.ir = 32,
            this.dr = -1,
            this.Jc = -1,
            this.Yc = -1,
            this.Qc = 0,
            this.L = -1,
            this.Mi = z,
            this.Zc = 0,
            this.Xc = 0,
            this.td = t => {
                this.Zc = Math.floor(Math.min(this.m.song.barCount - 1, Math.max(0, this.N / this.ir)))
            }
            ,
            this.ed = t => {
                var e = "barBefore" == this.qc.value ? 0 : 1;
                "barBefore" == this.qc.value || "barAfter" == this.qc.value ? (this.m.bar = this.Zc - 1 + e,
                this.m.selection.resetBoxSelection(),
                this.m.selection.insertBars(),
                this.m.synth.playhead >= this.Zc + e && (this.m.synth.playhead++,
                this.hi.nd.animatePlayhead())) : "deleteBar" == this.qc.value && (this.m.bar = this.Zc,
                this.m.selection.resetBoxSelection(),
                this.m.selection.deleteBars(),
                this.m.synth.playhead > this.Zc && (this.m.synth.playhead--,
                this.hi.nd.animatePlayhead())),
                this.qc.selectedIndex = -1
            }
            ,
            this.sd = () => {
                this.m.selection.setPattern(this.Hc.selectedIndex)
            }
            ,
            this.fl = t => {
                const e = this.ir * this.m.synth.playhead - 2;
                this.L != e && (this.L = e,
                this.k.setAttribute("x", "" + e)),
                window.requestAnimationFrame(this.fl)
            }
            ,
            this.od = t => {
                this.Kc = !0,
                this.Si = !0,
                this.ad(t),
                this.Gc = this.jc,
                this.Wc = this.Uc
            }
            ,
            this.rd = t => {
                this.ad(t),
                this.Gc == this.jc && this.Wc == this.Uc || t.preventDefault(),
                this.Kc && this.hd(),
                this.j()
            }
            ,
            this.ld = t => {
                this.Kc = !1,
                this.Si = !1,
                this.j()
            }
            ,
            this.W = t => {
                this.R || (this.R = !0)
            }
            ,
            this.U = t => {
                this.R && (this.R = !1)
            }
            ,
            this.K = t => {
                t.preventDefault(),
                this.Kc = !0,
                this.dd(t),
                this.Gc = this.jc,
                this.Wc = this.Uc,
                this.Ze >= p.barEditorHeight && (t.shiftKey ? (this.Si = !0,
                this.m.selection.setTrackSelection(this.m.selection.boxSelectionX0, this.jc, this.m.selection.boxSelectionY0, this.Uc),
                this.m.selection.selectionUpdated()) : (this.Si = !1,
                this.m.channel == this.Uc && this.m.bar == this.jc || (this.m.selection.setChannelBar(this.Uc, this.jc),
                this.Si = !0),
                this.m.selection.resetBoxSelection()))
            }
            ,
            this.Z = t => {
                this.dd(t),
                this.Kc && (this.Gc == this.jc && this.Wc == this.Uc || (this.Si = !0),
                this.hd()),
                this.j()
            }
            ,
            this.Yl = t => {
                if (this.Kc && !this.Si && this.m.channel == this.Uc && this.m.bar == this.jc) {
                    const t = (this.Ze - p.barEditorHeight) % xo.patternHeight < xo.patternHeight / 2
                      , e = this.m.song.patternsPerChannel;
                    this.m.selection.setPattern((this.m.song.channels[this.Uc].bars[this.jc] + (t ? 1 : e)) % (e + 1))
                }
                this.Kc = !1,
                this.Si = !1,
                this.j()
            }
            ,
            window.requestAnimationFrame(this.fl),
            this.q.addEventListener("mousedown", this.K),
            document.addEventListener("mousemove", this.Z),
            document.addEventListener("mouseup", this.Yl),
            this.q.addEventListener("mouseover", this.W),
            this.q.addEventListener("mouseout", this.U),
            this.Hc.addEventListener("change", this.sd),
            this.Hc.addEventListener("touchstart", this.od),
            this.Hc.addEventListener("touchmove", this.rd),
            this.Hc.addEventListener("touchend", this.ld),
            this.Hc.addEventListener("touchcancel", this.ld);
            let i = !1;
            document.addEventListener("mousedown", ( () => {
                i || (this.Mi = !1,
                this.j()),
                i = !0
            }
            ), !0),
            document.addEventListener("touchstart", ( () => {
                i || (this.Mi = !0,
                this.j()),
                i = !0
            }
            ), !0),
            this.qc.selectedIndex = -1,
            this.qc.addEventListener("change", this.ed),
            this.qc.addEventListener("mousedown", this.td)
        }
        movePlayheadToMouse() {
            return !!this.R && (this.m.synth.playhead = this.jc + this.N % this.ir / this.ir,
            !0)
        }
        hd() {
            this.m.selection.setTrackSelection(this.m.selection.boxSelectionX0, this.jc, this.m.selection.boxSelectionY0, this.Uc),
            this.m.selection.selectionUpdated()
        }
        ad(t) {
            const e = this.q.getBoundingClientRect();
            this.N = t.touches[0].clientX - e.left,
            this.Ze = t.touches[0].clientY - e.top,
            isNaN(this.N) && (this.N = 0),
            isNaN(this.Ze) && (this.Ze = 0),
            this.jc = Math.floor(Math.min(this.m.song.barCount - 1, Math.max(0, this.N / this.ir))),
            this.Uc = Math.floor(Math.min(this.m.song.getChannelCount() - 1, Math.max(0, (this.Ze - p.barEditorHeight) / xo.patternHeight)))
        }
        dd(t) {
            const e = this.q.getBoundingClientRect();
            this.N = (t.clientX || t.pageX) - e.left,
            this.Ze = (t.clientY || t.pageY) - e.top,
            this.jc = Math.floor(Math.min(this.m.song.barCount - 1, Math.max(0, this.N / this.ir))),
            this.Uc = Math.floor(Math.min(this.m.song.getChannelCount() - 1, Math.max(0, (this.Ze - p.barEditorHeight) / xo.patternHeight)))
        }
        j() {
            let t = this.Uc
              , e = this.jc;
            this.Mi && (e = this.m.bar,
            t = this.m.channel);
            const i = e == this.m.bar && t == this.m.channel
              , n = this.Ze >= p.barEditorHeight;
            if (this.Si && this.Gc != this.jc) {
                var s = Date.now();
                s - this.Xc >= 50 && (e > this.m.barScrollPos + this.m.trackVisibleBars - 1 && this.m.barScrollPos < this.m.song.barCount - this.m.trackVisibleBars && this.hi.changeBarScrollPos(1),
                e < this.m.barScrollPos && this.m.barScrollPos > 0 && this.hi.changeBarScrollPos(-1),
                this.Xc = s)
            }
            if (this.R && !this.Kc && !i && n ? (this.Rc.setAttribute("x", "" + (1 + this.ir * e)),
            this.Rc.setAttribute("y", "" + (1 + p.barEditorHeight + xo.patternHeight * t)),
            this.Rc.setAttribute("height", "" + (xo.patternHeight - 2)),
            this.Rc.setAttribute("width", "" + (this.ir - 2)),
            this.Rc.style.visibility = "visible") : (this.R || this.N >= e * this.ir && this.N < e * this.ir + this.ir && this.Ze > 0) && !n ? (this.Rc.setAttribute("x", "" + (1 + this.ir * e)),
            this.Rc.setAttribute("y", "1"),
            this.Rc.setAttribute("height", "" + (p.barEditorHeight - 3)),
            this.Rc.style.visibility = "visible") : this.Rc.style.visibility = "hidden",
            (this.R || this.Mi) && i && n) {
                const i = (this.Ze - p.barEditorHeight) % xo.patternHeight < xo.patternHeight / 2
                  , n = this.ir * (e + .8)
                  , s = p.barEditorHeight + xo.patternHeight * (t + .5)
                  , o = .1 * xo.patternHeight
                  , a = .4 * xo.patternHeight
                  , r = .175 * xo.patternHeight;
                this.Kr.setAttribute("fill", i && !this.Mi ? nt.hoverPreview : nt.invertedText),
                this.Jr.setAttribute("fill", i || this.Mi ? nt.invertedText : nt.hoverPreview),
                this.Kr.setAttribute("d", `M ${n} ${s - a} L ${n + r} ${s - o} L ${n - r} ${s - o} z`),
                this.Jr.setAttribute("d", `M ${n} ${s + a} L ${n + r} ${s + o} L ${n - r} ${s + o} z`),
                this.Kr.style.visibility = "visible",
                this.Jr.style.visibility = "visible"
            } else
                this.Kr.style.visibility = "hidden",
                this.Jr.style.visibility = "hidden";
            this.gh.style.left = this.ir * this.m.bar + "px",
            this.gh.style.top = p.barEditorHeight + xo.patternHeight * this.m.channel + "px",
            this.Hc.style.left = this.ir * this.m.bar + "px",
            this.Hc.style.width = this.ir + "px",
            this.Hc.style.top = p.barEditorHeight + xo.patternHeight * this.m.channel + "px",
            this.Hc.style.height = xo.patternHeight + "px",
            this.qc.style.left = this.ir * e + "px";
            const o = this.m.song.patternsPerChannel + 1;
            for (let t = this.Qc; t < o; t++)
                this.Hc.appendChild(J.option({
                    value: t
                }, t));
            for (let t = o; t < this.Qc; t++)
                this.Hc.removeChild(this.Hc.lastChild);
            this.Qc = o;
            const a = this.m.song.channels[this.m.channel].bars[this.m.bar];
            this.Hc.selectedIndex != a && (this.Hc.selectedIndex = a)
        }
        render() {
            if (this.ir = this.m.getBarWidth(),
            this._c.length != this.m.song.getChannelCount()) {
                for (let t = this._c.length; t < this.m.song.getChannelCount(); t++) {
                    const e = new xo(this.m,t);
                    this._c[t] = e,
                    this.Nc.appendChild(e.container)
                }
                for (let t = this.m.song.getChannelCount(); t < this._c.length; t++)
                    this.Nc.removeChild(this._c[t].container);
                this._c.length = this.m.song.getChannelCount(),
                this.Kc = !1
            }
            for (let t = 0; t < this.m.song.getChannelCount(); t++)
                this._c[t].render();
            const t = this.ir * this.m.song.barCount;
            if (this.Jc != t) {
                this.Jc = t,
                this.Nc.style.width = t + "px",
                this.container.style.width = t + "px",
                this.q.setAttribute("width", t + ""),
                this.Kc = !1;
                var e = "";
                for (let t = 0; t < this.m.song.barCount; t++) {
                    var i = t * this.ir + 2;
                    e += `M ${i} 1 H ${t * this.ir + this.ir - 2} V ${p.barEditorHeight - 3} H ${i} V 1 Z `
                }
                if (this.$c.setAttribute("d", e),
                this.dr < this.m.song.barCount) {
                    this.Vc.length = this.m.song.barCount;
                    for (var n = this.dr; n < this.Vc.length; n++)
                        this.Vc[n] = Y.text({
                            "font-family": "sans-serif",
                            "font-size": "8px",
                            "text-anchor": "middle",
                            "font-weight": "bold",
                            x: n * this.ir + this.ir / 2 + "px",
                            y: "7px",
                            fill: nt.secondaryText
                        }, "" + (n + 1)),
                        n % 4 == 0 && this.Vc[n].setAttribute("fill", nt.primaryText),
                        this.Oc.appendChild(this.Vc[n]);
                    this.dr = this.m.song.barCount
                } else if (this.dr > this.m.song.barCount) {
                    for (n = this.dr - 1; n >= this.m.song.barCount; n--)
                        this.Oc.removeChild(this.Vc[n]);
                    this.Vc.length = this.m.song.barCount,
                    this.dr = this.m.song.barCount
                }
                for (n = 0; n < this.Vc.length; n++)
                    this.Vc[n].setAttribute("x", n * this.ir + this.ir / 2 + "px");
                this.Jc = t,
                this.Nc.style.width = t + "px",
                this.container.style.width = t + "px",
                this.q.setAttribute("width", t + ""),
                this.Kc = !1
            }
            const s = this.m.song.getChannelCount() * xo.patternHeight;
            this.Yc != s && (this.Yc = s,
            this.q.setAttribute("height", "" + (s + p.barEditorHeight)),
            this.k.setAttribute("height", "" + (s + p.barEditorHeight)),
            this.container.style.height = s + p.barEditorHeight + "px"),
            this.Hc.style.display = this.Mi ? "" : "none",
            this.m.selection.boxSelectionActive ? (this.gh.setAttribute("x", String(this.ir * this.m.selection.boxSelectionBar + 1)),
            this.gh.setAttribute("y", String(p.barEditorHeight + xo.patternHeight * this.m.selection.boxSelectionChannel + 1)),
            this.gh.setAttribute("width", String(this.ir * this.m.selection.boxSelectionWidth - 2)),
            this.gh.setAttribute("height", String(xo.patternHeight * this.m.selection.boxSelectionHeight - 2)),
            this.gh.setAttribute("visibility", "visible")) : this.gh.setAttribute("visibility", "hidden"),
            this.j()
        }
    }
    class vr {
        constructor(t, e=1) {
            this.canvas = t,
            this.scale = e,
            this.pd = function(i, n) {
                if (n) {
                    var s = t.getContext("2d");
                    s.fillStyle = nt.getComputed("--editor-background"),
                    s.fillRect(0, 0, t.width, t.height),
                    s.fillStyle = nt.getComputed("--oscilloscope-line-L");
                    for (let n = i.length - 1; n >= i.length - 1 - t.width / e; n--) {
                        let o = n - (i.length - 1) + t.width / e
                          , a = i[n] * (t.height / e / 2) + t.height / e / 2;
                        if (s.fillRect((o - 1) * e, (a - 1) * e, 1 * e, 1.5 * e),
                        0 == o)
                            break
                    }
                    s.fillStyle = nt.getComputed("--oscilloscope-line-R");
                    for (let i = n.length - 1; i >= n.length - 1 - t.width / e; i--) {
                        let o = i - (n.length - 1) + t.width / e
                          , a = n[i] * (t.height / e / 2) + t.height / e / 2;
                        if (s.fillRect((o - 1) * e, (a - 1) * e, 1 * e, 1.5 * e),
                        0 == o)
                            break
                    }
                }
            }
            ,
            ct.listen("oscilloscopeUpdate", this.pd)
        }
    }
    const {div: xr, input: kr, button: Mr, h2: Sr, select: Fr, option: Cr, canvas: Ar} = J
      , Er = (t, e, i, n, s, o) => {
        e.fillRect(i, n, s, o)
    }
    ;
    class Tr {
        constructor(t, e, i, n, s, o, a, r, h) {
            this.md = 40,
            this.O = !1,
            this.ud = null,
            this.canvas = null,
            this.fd = null,
            this.update = t => {
                this.Bo = this.yd(t)
            }
            ,
            this.render = () => {
                const t = this.canvas
                  , e = this.fd
                  , i = t.width
                  , n = t.height
                  , s = this.bd
                  , o = this.gd
                  , a = this.Bo;
                e.clearRect(0, 0, i, n),
                e.fillStyle = nt.getComputed("--loop-accent");
                const r = this.md
                  , h = n
                  , l = Math.floor((a - s) * i / (o - s)) - r / 2;
                this.wd(t, e, l, 0, r, h)
            }
            ,
            this.updateViewport = (t, e) => {
                this.bd = t,
                this.gd = e
            }
            ,
            this.vd = t => {
                if (!this.O)
                    return;
                const e = this.xd
                  , i = this.bd
                  , n = this.gd
                  , s = this.canvas.getBoundingClientRect()
                  , o = e / s.width
                  , a = i + ((t.clientX || t.pageX) - s.left) * o * (n - i) / e;
                this.Bo = this.yd(a - (null != this.ud ? this.ud : 0)),
                this.render(),
                this.kd && this.kd(this.Bo)
            }
            ,
            this.Md = t => {
                this.O = !0;
                const e = this.xd
                  , i = this.bd
                  , n = this.gd
                  , s = this.canvas.getBoundingClientRect()
                  , o = e / s.width
                  , a = ((t.clientX || t.pageX) - s.left) * o
                  , r = this.md
                  , h = (this.Bo - i) * e / (n - i) - r / 2;
                a >= h && a <= h + r && (this.ud = (a - (h + r / 2)) * (n - i) / e);
                const l = i + a * (n - i) / e;
                this.Bo = this.yd(l - (null != this.ud ? this.ud : 0)),
                this.render(),
                this.kd && this.kd(this.Bo)
            }
            ,
            this.Sd = t => {
                this.O && (this.O = !1,
                this.ud = null,
                this.Fd())
            }
            ,
            this.Cd = t => {
                if (!this.O)
                    return;
                t.preventDefault();
                const e = this.xd
                  , i = this.bd
                  , n = this.gd
                  , s = this.canvas.getBoundingClientRect()
                  , o = e / s.width
                  , a = i + (t.touches[0].clientX - s.left) * o * (n - i) / e;
                this.Bo = this.yd(a - (null != this.ud ? this.ud : 0)),
                this.render(),
                this.kd && this.kd(this.Bo)
            }
            ,
            this.Ad = t => {
                t.preventDefault(),
                this.O = !0;
                const e = this.xd
                  , i = this.bd
                  , n = this.gd
                  , s = this.canvas.getBoundingClientRect()
                  , o = e / s.width
                  , a = (t.touches[0].clientX - s.left) * o
                  , r = this.md
                  , h = (this.Bo - i) * e / (n - i) - r / 2;
                a >= h && a <= h + r && (this.ud = (a - (h + r / 2)) * (n - i) / e);
                const l = i + a * (n - i) / e;
                this.Bo = this.yd(l - (null != this.ud ? this.ud : 0)),
                this.render(),
                this.kd && this.kd(this.Bo)
            }
            ,
            this.Ed = t => {
                t.preventDefault(),
                this.O = !1,
                this.ud = null,
                this.Fd()
            }
            ,
            this.cleanUp = () => {
                window.removeEventListener("mousemove", this.vd),
                this.canvas.removeEventListener("mousedown", this.Md),
                window.removeEventListener("mouseup", this.Sd),
                this.canvas.removeEventListener("touchstart", this.Ad),
                this.canvas.removeEventListener("touchmove", this.Cd),
                this.canvas.removeEventListener("touchend", this.Ed),
                this.canvas.removeEventListener("touchcancel", this.Ed)
            }
            ,
            this.Bo = t,
            this.yd = o,
            this.kd = a,
            this.Fd = r,
            this.wd = null == h ? Er : h,
            this.bd = n,
            this.gd = s,
            this.xd = e,
            this.Td = i,
            this.canvas = Ar({
                width: this.xd,
                height: this.Td,
                style: "cursor: default; position: static; margin-bottom: 0.5em; margin-left: auto; margin-right: auto; outline: 1px solid var(--ui-widget-background); box-sizing: border-box; width: 100%;"
            }),
            this.fd = this.canvas.getContext("2d"),
            window.addEventListener("mousemove", this.vd),
            this.canvas.addEventListener("mousedown", this.Md),
            window.addEventListener("mouseup", this.Sd),
            this.canvas.addEventListener("touchstart", this.Ad),
            this.canvas.addEventListener("touchmove", this.Cd),
            this.canvas.addEventListener("touchend", this.Ed),
            this.canvas.addEventListener("touchcancel", this.Ed)
        }
    }
    class Pr {
        constructor(t, e) {
            this.Pd = 500,
            this.Bd = 200,
            this.Id = 20,
            this.ne = null,
            this.Ld = null,
            this.Dd = null,
            this.zd = null,
            this.qd = null,
            this.Nd = null,
            this.Od = null,
            this.Rd = null,
            this.$d = 0,
            this.Hd = 0,
            this._d = 0,
            this.Vd = 0,
            this.Gd = !1,
            this.Wd = 0,
            this.jd = 1,
            this.Ud = -1.01,
            this.Kd = 1.01,
            this.Jd = 1,
            this.Yd = 0,
            this.Qd = 0,
            this.Zd = !1,
            this.Xd = null,
            this.tp = null,
            this.ep = t => Math.max(0, Math.min(this.Dd, Math.floor(t))),
            this.ip = t => Math.max(0, Math.min(this.Dd, Math.min(this.Vd - 2, Math.floor(t)))),
            this.np = t => Math.max(0, Math.min(this.Dd, Math.max(this._d + 2, Math.floor(t)))),
            this.sp = new Tr(this.Hd,this.Pd,this.Id,this.Wd,this.jd,this.ep,(t => {
                this.Hd = t,
                this.ne.chipWaveStartOffset = this.Hd,
                this.op(),
                this.ap()
            }
            ),( () => {
                this.gotMouseUp = !0,
                setTimeout(( () => {
                    this.gotMouseUp = !1
                }
                ), 10)
            }
            ),( (t, e, i, n, s, o) => {
                const a = o / 4;
                e.beginPath(),
                e.moveTo(i, n),
                e.lineTo(i + s, n),
                e.lineTo(i + s, n + o - a),
                e.lineTo(i + s / 2, n + o),
                e.lineTo(i, n + o - a),
                e.fill()
            }
            )),
            this.rp = new Tr(this._d,this.Pd,this.Id,this.Wd,this.jd,this.ip,(t => {
                this._d = t,
                this.ne.chipWaveLoopStart = this._d,
                this.op(),
                this.ap()
            }
            ),( () => {
                this.gotMouseUp = !0,
                setTimeout(( () => {
                    this.gotMouseUp = !1
                }
                ), 10)
            }
            ),( (t, e, i, n, s, o) => {
                const a = s / 4;
                e.beginPath(),
                e.moveTo(i, n),
                e.lineTo(i + s - a, n),
                e.lineTo(i + s, n + o / 2),
                e.lineTo(i + s - a, n + o),
                e.lineTo(i, n + o),
                e.fill()
            }
            )),
            this.hp = new Tr(this.Vd,this.Pd,this.Id,this.Wd,this.jd,this.np,(t => {
                this.Vd = t,
                this.ne.chipWaveLoopEnd = this.Vd,
                this.op(),
                this.ap()
            }
            ),( () => {
                this.gotMouseUp = !0,
                setTimeout(( () => {
                    this.gotMouseUp = !1
                }
                ), 10)
            }
            ),( (t, e, i, n, s, o) => {
                const a = s / 4;
                e.beginPath(),
                e.moveTo(i + s, n),
                e.lineTo(i + s, n + o),
                e.lineTo(i + a, n + o),
                e.lineTo(i, n + o / 2),
                e.lineTo(i + a, n),
                e.fill()
            }
            )),
            this.lp = !0,
            this.cp = Ar({
                width: this.Pd,
                height: this.Bd,
                style: "cursor: default; position: static; width: 100%;"
            }),
            this.dp = null,
            this.pp = Ar({
                width: this.Pd,
                height: this.Bd,
                style: "cursor: default; position: absolute; top: 0; left: 0; width: 100%;"
            }),
            this.mp = null,
            this.up = xr({
                style: `position: relative; margin-bottom: 0.5em; margin-left: auto; margin-right: auto; width: 100%; outline: 1px solid ${nt.uiWidgetBackground};`
            }, this.cp, this.pp),
            this.fp = kr({
                style: "width: 100%; flex-grow: 1; margin: 0;",
                type: "range",
                min: "0",
                max: "1",
                value: "0",
                step: "0.00001"
            }),
            this.yp = Mr({
                type: "button",
                title: "Zoom In",
                style: "height: var(--button-size); margin-left: 0.5em;"
            }, Y.svg({
                width: "20",
                height: "20",
                viewBox: "-10 -10 20 20",
                "pointer-events": "none",
                style: "width: 100%; height: 100%;"
            }, Y.circle({
                cx: -1,
                cy: -1,
                r: 6,
                "stroke-width": 2,
                stroke: nt.primaryText,
                fill: "none"
            }), Y.path({
                stroke: nt.primaryText,
                "stroke-width": 2,
                d: "M 3 3 L 7 7 M -1 -4 L -1 2 M -4 -1 L 2 -1",
                fill: "none"
            }))),
            this.bp = Mr({
                type: "button",
                title: "Zoom Out",
                style: "height: var(--button-size); margin-left: 0.5em;"
            }, Y.svg({
                width: "20",
                height: "20",
                viewBox: "-10 -10 20 20",
                "pointer-events": "none",
                style: "width: 100%; height: 100%;"
            }, Y.circle({
                cx: -1,
                cy: -1,
                r: 6,
                "stroke-width": 2,
                stroke: nt.primaryText,
                fill: "none"
            }), Y.path({
                stroke: nt.primaryText,
                "stroke-width": 2,
                d: "M 3 3 L 7 7 M -4 -1 L 2 -1",
                fill: "none"
            }))),
            this.gp = Mr({
                type: "button",
                title: "Zoom 100%",
                style: "height: var(--button-size); margin-left: 0.5em;"
            }, "100%"),
            this.wp = Fr({
                style: "width: 100%; flex-grow: 1; margin-left: 0.5em;"
            }, Cr({
                value: 0
            }, "Loop"), Cr({
                value: 1
            }, "Ping-Pong"), Cr({
                value: 2
            }, "Play Once"), Cr({
                value: 3
            }, "Play Loop Once")),
            this.vp = kr({
                style: "flex-grow: 1; margin-left: 1em; width: 100%;",
                type: "number",
                value: this.Hd,
                min: "0",
                step: "1"
            }),
            this.xp = kr({
                style: "flex-grow: 1; margin-left: 1em; width: 100%;",
                type: "number",
                value: this._d,
                min: "0",
                step: "1"
            }),
            this.kp = kr({
                style: "flex-grow: 1; margin-left: 1em; width: 100%;",
                type: "number",
                value: this.Vd,
                min: "0",
                step: "1"
            }),
            this.Mp = kr({
                type: "checkbox",
                style: "width: 1em; padding: 0; margin-left: auto; margin-right: auto;"
            }),
            this.Sp = Mr({
                style: "width: 55%;",
                type: "button"
            }),
            this.Oe = Mr({
                class: "cancelButton"
            }),
            this.Re = Mr({
                class: "okayButton",
                style: "width: 25%;"
            }, "Okay"),
            this.Fp = xr({
                style: "margin-bottom: 0.5em; display: none;"
            }, "Sample is loading"),
            this.Cp = xr(xr({
                style: "display: flex; flex-direction: column; align-items: center; justify-content: center; margin-bottom: 0.5em;"
            }, xr({
                style: `width: 100%; margin-bottom: 0.5em; text-align: center; color: ${nt.secondaryText};`
            }, "You can also zoom by dragging horizontally on the waveform.")), this.sp.canvas, this.up, this.rp.canvas, this.hp.canvas, xr({
                style: "display: flex; flex-direction: row; align-items: center; justify-content: center; margin-bottom: 0.5em;"
            }, this.fp, this.yp, this.bp, this.gp), xr({
                style: "display: flex; flex-direction: column; align-items: center; justify-content: center; margin-bottom: 0.5em;"
            }, xr({
                style: "width: 100%; display: flex; flex-direction: row; margin-bottom: 0.5em;"
            }, xr({
                style: `flex-shrink: 0; text-align: right: color: ${nt.primaryText}; align-self: center;`
            }, "Loop Mode"), this.wp), xr({
                style: "width: 100%; display: flex; flex-direction: row; margin-bottom: 0.5em;"
            }, xr({
                style: `flex-shrink: 0; text-align: right; color: ${nt.primaryText}; align-self: center;`
            }, "Offset"), this.vp), xr({
                style: "width: 100%; display: flex; flex-direction: row; margin-bottom: 0.5em;"
            }, xr({
                style: `flex-shrink: 0; text-align: right; color: ${nt.primaryText}; align-self: center;`
            }, "Loop Start"), this.xp), xr({
                style: "width: 100%; display: flex; flex-direction: row; margin-bottom: 0.5em;"
            }, xr({
                style: `flex-shrink: 0; text-align: right; color: ${nt.primaryText}; align-self: center;`
            }, "Loop End"), this.kp), xr({
                style: "width: 100%; display: flex; flex-direction: row; margin-bottom: 0.5em;"
            }, xr({
                style: `flex-shrink: 0; text-align: right; color: ${nt.primaryText}; align-self: center;`
            }, "Backwards"), this.Mp), xr({
                style: "width: 100%; display: flex; flex-direction: row; margin-bottom: 0.5em; justify-content: center;"
            }, this.Sp))),
            this.container = xr({
                class: "prompt noSelection",
                style: "width: 500px;"
            }, xr(Sr({
                style: "margin-bottom: 0.5em;"
            }, "Loop Controls"), this.Fp, this.Cp, xr({
                style: "display: flex; flex-direction: row-reverse; justify-content: space-between;"
            }, this.Re)), this.Oe),
            this.gotMouseUp = !1,
            this.Ap = t => {
                const e = this.Dd;
                return t >= 0 && t < e ? this.Ld[Math.floor(t)] : 0
            }
            ,
            this.Ep = (t, e) => {
                const i = this.Dd
                  , n = Math.max(0, Math.min(i, Math.ceil(t)))
                  , s = Math.max(0, Math.min(i, Math.ceil(e)));
                if (n >= s)
                    return [0, 0];
                let o = this.Ld[n]
                  , a = o;
                for (let t = n + 1; t < s; t++) {
                    const e = this.Ld[t];
                    o = Math.min(o, e),
                    a = Math.max(a, e)
                }
                return [o, a]
            }
            ,
            this.cleanUp = () => {
                this.sp.cleanUp(),
                this.rp.cleanUp(),
                this.hp.cleanUp(),
                this.container.removeEventListener("keydown", this.Ge),
                this.Re.removeEventListener("click", this.He),
                this.Oe.removeEventListener("click", this.$e),
                this.fp.removeEventListener("input", this.Tp),
                this.yp.removeEventListener("click", this.Pp),
                this.bp.removeEventListener("click", this.Bp),
                this.gp.removeEventListener("click", this.Ip),
                this.wp.removeEventListener("change", this.Lp),
                this.vp.removeEventListener("change", this.Dp),
                this.xp.removeEventListener("change", this.zp),
                this.kp.removeEventListener("change", this.qp),
                this.Mp.removeEventListener("input", this.Np),
                this.Sp.removeEventListener("click", this.Op),
                this.pp.removeEventListener("mousemove", this.Rp),
                this.pp.removeEventListener("mousedown", this.$p),
                this.pp.removeEventListener("mouseup", this.Hp),
                this.pp.removeEventListener("touchstart", this._p),
                this.pp.removeEventListener("touchmove", this.Vp),
                this.pp.removeEventListener("touchend", this.Gp),
                this.pp.removeEventListener("touchcancel", this.Gp)
            }
            ,
            this.$e = () => {
                this.m.prompt = null,
                this.m.undo()
            }
            ,
            this.He = () => {
                if (this.lp)
                    this.m.prompt = null,
                    this.m.undo();
                else {
                    this.m.prompt = null,
                    this.ne.chipWaveLoopMode = this.zd,
                    this.ne.chipWaveStartOffset = this.qd,
                    this.ne.chipWaveLoopStart = this.Nd,
                    this.ne.chipWaveLoopEnd = this.Od,
                    this.ne.chipWavePlayBackwards = this.Rd;
                    const t = new Zt;
                    t.append(new On(this.m,this.$d)),
                    t.append(new Hn(this.m,this.Hd)),
                    t.append(new Rn(this.m,this._d)),
                    t.append(new $n(this.m,this.Vd)),
                    t.append(new _n(this.m,this.Gd)),
                    this.m.record(t, !0)
                }
            }
            ,
            this.Op = () => {
                this.hi.togglePlay(),
                this.Wp()
            }
            ,
            this.jp = () => {
                if (this.lp)
                    return;
                const t = this.cp
                  , e = this.dp
                  , i = t.width
                  , n = t.height
                  , s = this.Wd
                  , o = this.jd
                  , a = this.Ud
                  , r = this.Kd
                  , h = (o - s) / i;
                e.clearRect(0, 0, i, n),
                e.fillStyle = nt.getComputed("--ui-widget-background"),
                e.fillRect(0, n / 2, i, 1);
                const l = nt.getComputed("--primary-text");
                if (h < 1) {
                    e.strokeStyle = l,
                    e.lineWidth = 1;
                    let t = !0;
                    e.beginPath();
                    for (let o = 0; o < i; o++) {
                        const i = s + o * h
                          , l = n - (this.Ap(i) - a) * n / (r - a);
                        t ? (e.moveTo(o, l),
                        t = !1) : e.lineTo(o, l)
                    }
                    e.stroke()
                } else {
                    e.fillStyle = l;
                    let t = null
                      , o = null;
                    for (let l = 0; l < i; l++) {
                        const i = s + l * h
                          , [c,d] = this.Ep(i - h / 2, i + h / 2)
                          , p = Math.max(-1, Math.min(n, n - (d - a) * n / (r - a)))
                          , m = Math.max(-1, Math.min(n, n - (c - a) * n / (r - a)))
                          , u = Math.floor(p)
                          , f = Math.max(Math.ceil(m), u + 1)
                          , y = null == o ? u : Math.min(u, o)
                          , b = null == t ? f : Math.max(f, t)
                          , g = Math.max(1, b - y);
                        e.fillRect(l, y, 1, g),
                        t = y,
                        o = b
                    }
                }
            }
            ,
            this.op = () => {
                const t = this.pp
                  , e = this.mp
                  , i = t.width
                  , n = t.height
                  , s = this.Wd
                  , o = this.jd
                  , a = this.Hd
                  , r = this._d
                  , h = this.Vd;
                e.clearRect(0, 0, i, n),
                e.fillStyle = nt.getComputed("--loop-accent");
                const l = Math.floor((a - s) * i / (o - s))
                  , c = n;
                e.fillRect(l, 0, 1, c),
                e.fillStyle = nt.getComputed("--loop-accent"),
                e.globalAlpha = .5;
                const d = Math.floor((r - s) * i / (o - s))
                  , p = d
                  , m = Math.floor((h - s) * i / (o - s)) - d
                  , u = n;
                e.fillRect(p, 0, m, u),
                e.globalAlpha = 1,
                null != this.Xd && null != this.tp && (e.fillStyle = nt.getComputed("--box-selection-fill"),
                e.globalAlpha = .5,
                e.fillRect(this.Xd, 0, this.tp - this.Xd, n),
                e.globalAlpha = 1)
            }
            ,
            this.ap = () => {
                this.wp.value = "" + this.$d,
                this.vp.value = "" + this.Hd,
                this.xp.value = "" + this._d,
                this.kp.value = "" + this.Vd,
                this.Mp.checked = this.Gd
            }
            ,
            this.Tp = t => {
                const e = Math.max(0, Math.min(1, +t.target.value))
                  , i = Math.max(0, Math.min(this.Qd, e * this.Qd));
                this.Yd = Math.min(this.Qd, i),
                this.fp.value = "" + this.Yd / this.Qd,
                this.Wd = 0 + this.Yd,
                this.jd = this.Jd + this.Yd,
                this.Up(),
                this.Rs()
            }
            ,
            this.Pp = t => {
                const e = Math.max(1, Math.min(this.Dd, this.Jd / 2));
                this.Jd = e,
                this.Qd = this.Dd - this.Jd;
                const i = this.Wd + this.Pd / 2 * (this.jd - this.Wd) / this.Pd;
                this.Yd = Math.max(0, Math.min(this.Qd, i - this.Pd / 2 * this.Jd / this.Pd)),
                this.Wd = 0 + this.Yd,
                this.jd = this.Jd + this.Yd,
                this.fp.value = "" + this.Yd / this.Qd,
                this.Up(),
                this.Rs()
            }
            ,
            this.Bp = t => {
                const e = Math.max(1, Math.min(this.Dd, 2 * this.Jd));
                this.Jd = e,
                this.Qd = this.Dd - this.Jd;
                const i = this.Wd + this.Pd / 2 * (this.jd - this.Wd) / this.Pd;
                this.Yd = Math.max(0, Math.min(this.Qd, i - this.cp.width / 2 * this.Jd / this.Pd)),
                this.Wd = 0 + this.Yd,
                this.jd = this.Jd + this.Yd,
                this.Jd === this.Dd ? this.fp.value = "0" : this.fp.value = "" + this.Yd / this.Qd,
                this.Up(),
                this.Rs()
            }
            ,
            this.Ip = t => {
                const e = this.Dd;
                this.Jd = e,
                this.Qd = this.Dd - this.Jd,
                this.Yd = Math.max(0, Math.min(this.Qd, 0)),
                this.Wd = 0 + this.Yd,
                this.jd = this.Jd + this.Yd,
                this.Jd === this.Dd ? this.fp.value = "0" : this.fp.value = "" + this.Yd / this.Qd,
                this.Up(),
                this.Rs()
            }
            ,
            this.Lp = t => {
                const e = +t.target.value;
                this.$d = e,
                this.ne.chipWaveLoopMode = this.$d
            }
            ,
            this.Dp = t => {
                const e = t.target
                  , i = this.ep(+e.value);
                this.Hd = i,
                this.ne.chipWaveStartOffset = this.Hd,
                e.value = "" + i,
                this.sp.update(i),
                this.sp.render(),
                this.op()
            }
            ,
            this.zp = t => {
                const e = t.target
                  , i = this.ip(+e.value);
                this._d = i,
                this.ne.chipWaveLoopStart = this._d,
                e.value = "" + i,
                this.rp.update(i),
                this.rp.render(),
                this.op()
            }
            ,
            this.qp = t => {
                const e = t.target
                  , i = this.np(+e.value);
                this.Vd = i,
                this.ne.chipWaveLoopEnd = this.Vd,
                e.value = "" + i,
                this.hp.update(i),
                this.hp.render(),
                this.op()
            }
            ,
            this.Np = t => {
                const e = t.target.checked;
                this.Gd = e,
                this.ne.chipWavePlayBackwards = this.Gd
            }
            ,
            this.Rp = t => {
                if (!this.Zd)
                    return;
                const e = this.pp.width
                  , i = this.pp.getBoundingClientRect()
                  , n = e / i.width
                  , s = ((t.clientX || t.pageX) - i.left) * n;
                this.tp = s,
                this.op()
            }
            ,
            this.$p = t => {
                this.Zd = !0;
                const e = this.pp.width
                  , i = this.pp.getBoundingClientRect()
                  , n = e / i.width
                  , s = ((t.clientX || t.pageX) - i.left) * n;
                this.Xd = s,
                this.tp = s,
                this.op()
            }
            ,
            this.Hp = t => {
                if (!this.Zd)
                    return;
                this.gotMouseUp = !0,
                setTimeout(( () => {
                    this.gotMouseUp = !1
                }
                ), 10),
                this.Zd = !1;
                const e = this.pp.width
                  , i = this.Wd
                  , n = this.jd
                  , s = this.pp.getBoundingClientRect()
                  , o = e / s.width
                  , a = ((t.clientX || t.pageX) - s.left) * o;
                if (this.tp = a,
                this.Xd = Math.max(0, Math.min(e, this.Xd)),
                this.tp = Math.max(0, Math.min(e, this.tp)),
                this.Xd > this.tp) {
                    const t = this.Xd;
                    this.Xd = this.tp,
                    this.tp = t
                }
                let r = !1;
                if (this.tp - this.Xd > 2) {
                    const t = i + this.Xd * (n - i) / e
                      , s = i + this.tp * (n - i) / e
                      , o = Math.max(1, Math.min(this.Dd, s - t));
                    this.Jd = o,
                    this.Qd = this.Dd - this.Jd;
                    const a = i + this.Xd * (this.jd - this.Wd) / this.Pd;
                    this.Yd = Math.max(0, Math.min(this.Qd, a)),
                    this.Wd = 0 + this.Yd,
                    this.jd = this.Jd + this.Yd,
                    this.Jd === this.Dd ? this.fp.value = "0" : this.fp.value = "" + this.Yd / this.Qd
                } else
                    r = !0;
                this.Xd = null,
                this.tp = null,
                r || (this.Up(),
                this.Rs()),
                this.op()
            }
            ,
            this._p = t => {
                t.preventDefault(),
                this.Zd = !0;
                const e = this.pp.width
                  , i = this.pp.getBoundingClientRect()
                  , n = e / i.width
                  , s = (t.touches[0].clientX - i.left) * n;
                this.Xd = s,
                this.tp = s,
                this.op()
            }
            ,
            this.Vp = t => {
                if (!this.Zd)
                    return;
                t.preventDefault();
                const e = this.pp.width
                  , i = this.pp.getBoundingClientRect()
                  , n = e / i.width
                  , s = (t.touches[0].clientX - i.left) * n;
                this.tp = s,
                this.op()
            }
            ,
            this.Gp = t => {
                if (t.preventDefault(),
                !this.Zd)
                    return;
                this.gotMouseUp = !0,
                setTimeout(( () => {
                    this.gotMouseUp = !1
                }
                ), 10),
                this.Zd = !1;
                const e = this.pp.width
                  , i = this.Wd
                  , n = this.jd;
                if (this.Xd = Math.max(0, Math.min(e, this.Xd)),
                this.tp = Math.max(0, Math.min(e, this.tp)),
                this.Xd > this.tp) {
                    const t = this.Xd;
                    this.Xd = this.tp,
                    this.tp = t
                }
                let s = !1;
                if (this.tp - this.Xd > 2) {
                    const t = i + this.Xd * (n - i) / e
                      , s = i + this.tp * (n - i) / e
                      , o = Math.max(1, Math.min(this.Dd, s - t));
                    this.Jd = o,
                    this.Qd = this.Dd - this.Jd;
                    const a = i + this.Xd * (this.jd - this.Wd) / this.Pd;
                    this.Yd = Math.max(0, Math.min(this.Qd, a)),
                    this.Wd = 0 + this.Yd,
                    this.jd = this.Jd + this.Yd,
                    this.Jd === this.Dd ? this.fp.value = "0" : this.fp.value = "" + this.Yd / this.Qd
                } else
                    s = !0;
                this.Xd = null,
                this.tp = null,
                s || (this.Up(),
                this.Rs()),
                this.op()
            }
            ,
            this.Ge = t => {
                "BUTTON" != t.target.tagName && 13 == t.keyCode && this.He(),
                32 == t.keyCode && (this.Op(),
                t.preventDefault())
            }
            ,
            this.Wp = () => {
                this.m.synth.playing ? (this.Sp.classList.remove("playButton"),
                this.Sp.classList.add("pauseButton"),
                this.Sp.title = "Pause (Space)",
                this.Sp.innerText = "Pause") : (this.Sp.classList.remove("pauseButton"),
                this.Sp.classList.add("playButton"),
                this.Sp.title = "Play (Space)",
                this.Sp.innerText = "Play")
            }
            ,
            this.Up = () => {
                this.sp.updateViewport(this.Wd, this.jd),
                this.rp.updateViewport(this.Wd, this.jd),
                this.hp.updateViewport(this.Wd, this.jd)
            }
            ,
            this.Rs = () => {
                this.lp || (this.jp(),
                this.sp.render(),
                this.rp.render(),
                this.hp.render(),
                this.op())
            }
            ,
            this.m = t,
            this.hi = e,
            this.dp = this.cp.getContext("2d"),
            this.mp = this.pp.getContext("2d"),
            this.ne = this.m.song.channels[this.m.channel].instruments[this.m.getCurrentInstrument()];
            const i = p.rawRawChipWaves[this.ne.chipWave];
            if ((!0 === i.isCustomSampled || 1 == i.isSampled) && 1 !== s.statusTable[this.ne.chipWave])
                this.Fp.style.display = "",
                this.Cp.style.display = "none",
                this.lp = !0;
            else {
                this.Fp.style.display = "none",
                this.Cp.style.display = "",
                this.lp = !1,
                this.Ld = i.samples,
                this.Dd = this.Ld.length - 1,
                this.zd = this.ne.chipWaveLoopMode,
                this.qd = this.ne.chipWaveStartOffset,
                this.Nd = this.ne.chipWaveLoopStart,
                this.Od = this.ne.chipWaveLoopEnd,
                this.Rd = this.ne.chipWavePlayBackwards,
                this.$d = this.zd,
                this.Hd = this.qd,
                this._d = this.Nd,
                this.Vd = this.Od,
                this.Gd = this.Rd;
                const t = this.Ep(0, this.Dd)
                  , e = Math.max(Math.abs(t[0]), Math.abs(t[1])) + .01;
                t[0] = -e,
                t[1] = e,
                this.Wd = 0,
                this.jd = this.Dd,
                this.Ud = t[0],
                this.Kd = t[1],
                this.Jd = this.jd - this.Wd,
                this.Yd = 0,
                this.Qd = this.Dd - this.Jd,
                this.sp.update(this.Hd),
                this.rp.update(this._d),
                this.hp.update(this.Vd),
                this.Up()
            }
            this.Wp(),
            this.Rs(),
            this.ap(),
            this.container.addEventListener("keydown", this.Ge),
            this.Re.addEventListener("click", this.He),
            this.Oe.addEventListener("click", this.$e),
            this.fp.addEventListener("input", this.Tp),
            this.yp.addEventListener("click", this.Pp),
            this.bp.addEventListener("click", this.Bp),
            this.gp.addEventListener("click", this.Ip),
            this.wp.addEventListener("change", this.Lp),
            this.vp.addEventListener("change", this.Dp),
            this.xp.addEventListener("change", this.zp),
            this.kp.addEventListener("change", this.qp),
            this.Mp.addEventListener("input", this.Np),
            this.Sp.addEventListener("click", this.Op),
            window.addEventListener("mousemove", this.Rp),
            this.pp.addEventListener("mousedown", this.$p),
            window.addEventListener("mouseup", this.Hp),
            this.pp.addEventListener("touchstart", this._p),
            this.pp.addEventListener("touchmove", this.Vp),
            this.pp.addEventListener("touchend", this.Gp),
            this.pp.addEventListener("touchcancel", this.Gp)
        }
    }
    const {div: Br, h2: Ir, span: Lr, input: Dr, button: zr} = J;
    class qr {
        constructor(t) {
            this.Kp = 2e3,
            this.Jp = null,
            this.Yp = !1,
            this.Oe = zr({
                class: "cancelButton"
            }),
            this.Qp = Br(),
            this.Zp = Br({
                style: "margin-top: 0.5em; display: none;"
            }, "There's no custom samples in this song."),
            this.container = Br({
                class: "prompt noSelection",
                style: "width: 350px;"
            }, Br(Ir("Sample Loading Status"), Br({
                style: "display: flex; flex-direction: column; align-items: center; margin-bottom: 0.5em;"
            }, this.Zp, Br({
                style: "width: 100%; max-height: 350px; overflow-y: scroll;"
            }, this.Qp))), this.Oe),
            this.$e = () => {
                this.m.prompt = null,
                this.m.undo()
            }
            ,
            this.cleanUp = () => {
                for (; null !== this.Qp.firstChild; )
                    this.Qp.removeChild(this.Qp.firstChild);
                this.Oe.removeEventListener("click", this.$e),
                clearInterval(this.Jp)
            }
            ,
            this.Rs = () => {
                const t = null == N.customSamples;
                if (t && (this.Zp.style.display = ""),
                t || this.Yp)
                    return void clearInterval(this.Jp);
                let e = !0;
                for (let t = 0; t < p.chipWaves.length; t++) {
                    const i = p.chipWaves[t];
                    if (!0 !== i.isCustomSampled && !0 !== i.isSampled)
                        continue;
                    if (0 === s.statusTable[t]) {
                        e = !1;
                        break
                    }
                }
                for (; null !== this.Qp.firstChild; )
                    this.Qp.removeChild(this.Qp.firstChild);
                for (let t = 0; t < p.chipWaves.length; t++) {
                    const e = p.chipWaves[t];
                    if (!0 !== e.isCustomSampled && !0 !== e.isSampled)
                        continue;
                    const i = e.name
                      , o = s.urlTable[t]
                      , a = n(s.statusTable[t])
                      , r = Dr({
                        style: `margin-left: 0.5em; color: ${nt.primaryText}; background-color: ${nt.editorBackground}; width: 100%; border: 1px solid ${nt.uiWidgetBackground}; -webkit-user-select: none; -webkit-touch-callout: none; -moz-user-select: none; -ms-user-select: none; user-select: none;`,
                        value: o,
                        title: o,
                        disabled: !0
                    })
                      , h = "loaded" === a ? nt.indicatorPrimary : nt.secondaryText
                      , l = Lr({
                        style: `margin-left: 0.5em; color: ${h}`
                    }, a)
                      , c = Br({
                        style: `padding: 0.6em; margin: 0.4em; border: 1px solid ${nt.uiWidgetBackground}; border-radius: 4px;`
                    }, Br({
                        class: "add-sample-prompt-sample-name",
                        style: `margin-bottom: 0.5em; color: ${nt.secondaryText}; text-overflow: ellipsis; overflow: hidden; white-space: nowrap;`,
                        title: i
                    }, i), Br({
                        style: "display: flex; flex-direction: row; align-items: center; justify-content: center; margin-bottom: 0.5em;"
                    }, Br({
                        style: `text-align: right; color: ${nt.primaryText};`
                    }, "URL"), r), Br({
                        style: "display: flex; flex-direction: row; align-items: center; justify-content: center; margin-bottom: 0.5em;"
                    }, Br({
                        style: `text-align: right; color: ${nt.primaryText};`
                    }, "Status"), l));
                    this.Qp.appendChild(c)
                }
                e && (this.Yp = !0)
            }
            ,
            this.m = t,
            this.Jp = setInterval(( () => this.Rs()), this.Kp),
            this.Rs(),
            this.Oe.addEventListener("click", this.$e)
        }
    }
    const {div: Nr, input: Or, button: Rr, a: $r, code: Hr, textarea: _r, details: Vr, summary: Gr, span: Wr, ul: jr, li: Ur, select: Kr, option: Jr, h2: Yr} = J;
    class Qr {
        constructor(t) {
            if (this.Xp = 64,
            this.tm = [],
            this.im = {},
            this.Oe = Rr({
                class: "cancelButton"
            }),
            this.Re = Rr({
                class: "okayButton",
                style: "width: 45%;"
            }, "Okay"),
            this.nm = Rr({
                style: "height: auto; min-height: var(--button-size);"
            }, "Add sample"),
            this.sm = Nr(),
            this.om = Rr({
                style: "height: auto; min-height: var(--button-size); margin-left: 0.5em;"
            }, "Add multiple samples"),
            this.am = Nr({
                style: "margin-top: 0.5em;"
            }, this.nm, this.om),
            this.rm = $r({
                href: "#"
            }, "Here's more information and some instructions on how to use custom samples in UltraBox."),
            this.hm = Nr(Nr({
                style: "margin-bottom: 0.5em; -webkit-user-select: text; -moz-user-select: text; -ms-user-select: text; user-select: text; cursor: text;"
            }, "In order to use the old UltraBox samples, you should add ", Hr("legacySamples"), " as an URL. You can also use ", Hr("nintariboxSamples"), " and ", Hr("marioPaintboxSamples"), " for more built-in sample packs."), Nr({
                style: "margin-bottom: 0.5em;"
            }, "The order of these samples is important - if you change it you'll break your song!"), Nr({
                style: "margin-bottom: 0.5em;"
            }, this.rm)),
            this.lm = Rr({
                style: "height: auto; min-height: var(--button-size); width: 100%;"
            }, "Close instructions"),
            this.dm = Nr({
                style: "display: none; margin-top: 0; -webkit-user-select: text; -moz-user-select: text; -ms-user-select: text; user-select: text; cursor: text; overflow-y: auto;"
            }, Yr("Add Samples"), Nr({
                style: "margin-top: 0.5em; margin-bottom: 0.5em;"
            }, "In UltraBox, custom samples are loaded from arbitrary URLs."), Nr({
                style: `margin-top: 0.5em; margin-bottom: 0.5em; color: ${nt.secondaryText};`
            }, "(Technically, the web server behind the URL needs to support ", $r({
                href: "https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS",
                target: "_blank"
            }, "CORS"), ", but you don't need to know about that: ", " the sample just won't load if that's not the case)"), Nr({
                style: "margin-top: 0.5em; margin-bottom: 0.5em;"
            }, Vr(Gr("Why arbitrary URLs?"), $r({
                href: "https://pandoras-box-archive.neptendo.repl.co/"
            }, "A certain BeepBox mod"), " did this with one central server, but it went down, taking down", " the samples with it, though thankfully it got archived.", " This is always an issue with servers: it may run out of space,", " stop working, and so on. With arbitrary URLs, you can always ", " change them to different ones if they stop working.")), Nr({
                style: "margin-top: 0.5em; margin-bottom: 0.5em;"
            }, "As for where to upload your samples, here are some suggestions:", jr({
                style: "text-align: left;"
            }, Ur($r({
                href: "https://filegarden.com"
            }, "File Garden")), Ur($r({
                href: "https://catbox.moe/"
            }, "Catbox")), Ur($r({
                href: "https://www.dropbox.com"
            }, "Dropbox"), " (domain needs to be ", Hr("https://dl.dropboxusercontent.com"), ")"))), Nr({
                style: "margin-top: 0.5em; margin-bottom: 0.5em;"
            }, "Static website hosting services may also work (such as ", $r({
                href: "https://pages.github.com"
            }, "GitHub Pages"), ")", " but those require a bit more setup."), Nr({
                style: "margin-top: 0.5em; margin-bottom: 1em;"
            }, "Finally, if have a soundfont you'd like to get samples from, consider using this ", $r({
                href: "./sample_extractor.html",
                target: "_blank"
            }, "sample extractor"), "."), Nr({
                style: "display: flex; flex-direction: row-reverse; justify-content: space-between; margin-top: 0.5em;"
            }, this.lm)),
            this.pm = Nr({
                style: "overflow-y: auto;"
            }, Yr("Add Samples"), Nr({
                style: "display: flex; flex-direction: column; align-items: center; margin-bottom: 0.5em;"
            }, this.hm, Nr({
                style: "width: 100%; max-height: 450px; overflow-y: scroll;"
            }, this.sm), this.am), Nr({
                style: "display: flex; flex-direction: row-reverse; justify-content: space-between;"
            }, this.Re)),
            this.um = _r({
                style: "width: 100%; height: 100%; resize: none; box-sizing: border-box;"
            }),
            this.fm = Rr({
                style: "height: auto; min-height: var(--button-size); width: 100%;"
            }, "Add"),
            this.ym = Nr({
                style: "display: none; overflow-y: auto;"
            }, Yr({
                style: "margin-bottom: 0.5em;"
            }, "Add Multiple Samples"), Nr({
                style: "display: flex; flex-direction: column; align-items: center;"
            }, Nr(`Add one URL per line. Remember that you can only have ${this.Xp} samples!`), Nr({
                style: `color: ${nt.secondaryText}`
            }, "(This supports the syntax used to store samples in the song URLs as well)"), Nr({
                style: "width: 100%; height: 250px; margin-top: 0.5em; margin-bottom: 0.5em;"
            }, this.um)), Nr({
                style: "display: flex; flex-direction: row-reverse; justify-content: space-between;"
            }, this.fm)),
            this.container = Nr({
                class: "prompt noSelection",
                style: "width: 450px; max-height: calc(100% - 100px);"
            }, this.pm, this.ym, this.dm, this.Oe),
            this.cleanUp = () => {
                for (; null !== this.sm.firstChild; )
                    this.sm.removeChild(this.sm.firstChild);
                this.nm.removeEventListener("click", this.bm),
                this.om.removeEventListener("click", this.gm),
                this.fm.removeEventListener("click", this.wm),
                this.Re.removeEventListener("click", this.He),
                this.Oe.removeEventListener("click", this.$e),
                this.rm.removeEventListener("click", this.vm),
                this.lm.removeEventListener("click", this.xm)
            }
            ,
            this.$e = () => {
                this.m.prompt = null,
                this.m.undo(),
                this.He()
            }
            ,
            this.He = () => {
                const t = this.km();
                N.customSamples = t.split("|").filter((t => "" !== t)),
                p.willReloadForCustomSamples = !0,
                window.location.hash = this.m.song.toBase64String(),
                setTimeout(( () => {
                    location.reload()
                }
                ), 50)
            }
            ,
            this.bm = t => {
                const e = this.tm.length;
                this.tm.push({
                    url: "",
                    sampleRate: 44100,
                    rootKey: 60,
                    percussion: !1,
                    chipWaveLoopStart: null,
                    chipWaveLoopEnd: null,
                    chipWaveStartOffset: null,
                    chipWaveLoopMode: null,
                    chipWavePlayBackwards: !1
                }),
                this.im[e] = !1,
                this.Mm(),
                this.Rs(!0)
            }
            ,
            this.gm = t => {
                this.pm.style.display = "none",
                this.ym.style.display = "",
                this.um.value = ""
            }
            ,
            this.vm = t => {
                t.preventDefault(),
                this.pm.style.display = "none",
                this.dm.style.display = ""
            }
            ,
            this.xm = t => {
                this.pm.style.display = "",
                this.dm.style.display = "none"
            }
            ,
            this.wm = t => {
                this.pm.style.display = "",
                this.ym.style.display = "none";
                const e = this.Sm(this.um.value.replace(/\n/g, "|").split("|").filter((t => "" !== t)), !1)
                  , i = new Map;
                for (const t of this.tm)
                    i.set(t.url, !0);
                for (const t of e.entries) {
                    if (this.tm.length >= this.Xp)
                        break;
                    if (i.has(t.url))
                        continue;
                    i.set(t.url, !0);
                    const e = this.tm.length;
                    this.tm.push(t),
                    this.im[e] = !1
                }
                this.Mm(),
                this.Rs(!1)
            }
            ,
            this.Fm = t => {
                const e = t.target
                  , i = +e.dataset.index;
                e.open ? this.im[i] = !0 : this.im[i] = !1
            }
            ,
            this.Cm = t => {
                var e, i;
                const n = t.target
                  , s = +n.dataset.index;
                this.tm[s].url = n.value;
                const o = null === (i = null === (e = n.parentNode) || void 0 === e ? void 0 : e.parentNode) || void 0 === i ? void 0 : i.querySelector(".add-sample-prompt-sample-name");
                if (null != o) {
                    const t = this.Am(this.tm[s]);
                    o.innerText = t,
                    o.title = t
                }
            }
            ,
            this.Em = t => {
                const e = t.target
                  , i = +e.dataset.index
                  , n = yt(8e3, 96001, gt(e.value, 44100));
                this.tm[i].sampleRate = n
            }
            ,
            this.Tm = t => {
                var e, i;
                const n = t.target
                  , s = +n.dataset.index
                  , o = gt(n.value, 60);
                this.tm[s].rootKey = o;
                const a = null === (i = null === (e = n.parentNode) || void 0 === e ? void 0 : e.parentNode) || void 0 === i ? void 0 : i.querySelector(".add-sample-prompt-root-key-display");
                if (null != a) {
                    const t = this.Pm(this.tm[s].rootKey);
                    "" !== t && (a.innerText = `(${t})`)
                }
            }
            ,
            this.Bm = t => {
                const e = t.target
                  , i = +e.dataset.index;
                this.tm[i].percussion = !!e.checked
            }
            ,
            this.Im = t => {
                const e = t.target
                  , i = +e.dataset.index
                  , n = wt(e.value, null);
                this.tm[i].chipWaveLoopStart = n
            }
            ,
            this.Lm = t => {
                const e = t.target
                  , i = +e.dataset.index
                  , n = wt(e.value, null);
                this.tm[i].chipWaveLoopEnd = n
            }
            ,
            this.Dm = t => {
                const e = t.target
                  , i = +e.dataset.index
                  , n = wt(e.value, null);
                this.tm[i].chipWaveStartOffset = n
            }
            ,
            this.zm = t => {
                const e = t.target
                  , i = +e.dataset.index
                  , n = +e.value;
                this.tm[i].chipWaveLoopMode = -1 === n ? null : n
            }
            ,
            this.qm = t => {
                const e = t.target
                  , i = +e.dataset.index
                  , n = e.checked;
                this.tm[i].chipWavePlayBackwards = n
            }
            ,
            this.Nm = t => {
                const e = +t.target.dataset.index;
                this.Om(this.Rm(this.tm[e]))
            }
            ,
            this.$m = t => {
                const e = +t.target.dataset.index;
                this.im[e] = !1,
                this.tm.splice(e, 1),
                this.Mm(),
                this.Rs(!1)
            }
            ,
            this.Hm = t => {
                const e = +t.target.dataset.index
                  , i = e - 1;
                if (this.tm.length >= 2 && i >= 0) {
                    const t = this.tm[i]
                      , n = this.tm[e]
                      , s = this.im[i]
                      , o = this.im[e];
                    this.tm[i] = n,
                    this.tm[e] = t,
                    this.im[i] = o,
                    this.im[e] = s,
                    this.Rs(!1)
                }
            }
            ,
            this._m = t => {
                const e = +t.target.dataset.index
                  , i = e + 1;
                if (this.tm.length >= 2 && i < this.tm.length) {
                    const t = this.tm[i]
                      , n = this.tm[e]
                      , s = this.im[i]
                      , o = this.im[e];
                    this.tm[i] = n,
                    this.tm[e] = t,
                    this.im[i] = o,
                    this.im[e] = s,
                    this.Rs(!1)
                }
            }
            ,
            this.Mm = () => {
                this.tm.length >= this.Xp ? this.nm.style.display = "none" : this.nm.style.display = ""
            }
            ,
            this.Sm = (t, e) => {
                function i(t) {
                    return [t.slice(0, t.indexOf(",")), yt(8e3, 96001, gt(t.slice(t.indexOf(",") + 1), 44100))]
                }
                function n(t) {
                    return [t.slice(0, t.indexOf("!")), gt(t.slice(t.indexOf("!") + 1), 60)]
                }
                let s = !1
                  , o = !1
                  , a = !1;
                const r = [];
                for (const h of t)
                    if ("" !== h)
                        if ("legacysamples" === h.toLowerCase())
                            s || r.push({
                                url: "legacySamples",
                                sampleRate: 44100,
                                rootKey: 60,
                                percussion: !1,
                                chipWaveLoopStart: null,
                                chipWaveLoopEnd: null,
                                chipWaveStartOffset: null,
                                chipWaveLoopMode: null,
                                chipWavePlayBackwards: !1
                            }),
                            s = !0;
                        else if ("nintariboxsamples" === h.toLowerCase())
                            o || r.push({
                                url: "nintariboxSamples",
                                sampleRate: 44100,
                                rootKey: 60,
                                percussion: !1,
                                chipWaveLoopStart: null,
                                chipWaveLoopEnd: null,
                                chipWaveStartOffset: null,
                                chipWaveLoopMode: null,
                                chipWavePlayBackwards: !1
                            }),
                            o = !0;
                        else if ("mariopaintboxsamples" === h.toLowerCase())
                            a || r.push({
                                url: "marioPaintboxSamples",
                                sampleRate: 44100,
                                rootKey: 60,
                                percussion: !1,
                                chipWaveLoopStart: null,
                                chipWaveLoopEnd: null,
                                chipWaveStartOffset: null,
                                chipWaveLoopMode: null,
                                chipWavePlayBackwards: !1
                            }),
                            a = !0;
                        else {
                            let t = h
                              , s = 44100
                              , o = 60
                              , a = !1
                              , l = null
                              , c = null
                              , d = null
                              , p = null
                              , m = !1
                              , u = h.indexOf("!")
                              , f = -1
                              , y = !1;
                            if (0 === u && (f = h.indexOf("!", u + 1),
                            -1 !== f)) {
                                const e = h.slice(u + 1, f).split(",");
                                for (const t of e) {
                                    const e = t.charAt(0)
                                      , i = t.slice(1, t.length);
                                    "s" === e ? s = yt(8e3, 96001, gt(i, 44100)) : "r" === e ? o = gt(i, 60) : "p" === e ? a = !0 : "a" === e ? l = wt(i, null) : "b" === e ? c = wt(i, null) : "c" === e ? d = wt(i, null) : "d" === e ? (p = wt(i, null),
                                    null != p && (p = yt(0, 4, p))) : "e" === e && (m = !0)
                                }
                                t = h.slice(f + 1, h.length),
                                y = !0
                            }
                            e && (y || (-1 != h.indexOf("@") && (t = h.replaceAll("@", ""),
                            a = !0),
                            -1 != h.indexOf(",") && -1 != h.indexOf("!") ? h.indexOf(",") < h.indexOf("!") ? ([t,o] = n(t),
                            [t,s] = i(t)) : ([t,s] = i(t),
                            [t,o] = n(t)) : (-1 != h.indexOf(",") && ([t,s] = i(t)),
                            -1 != h.indexOf("!") && ([t,o] = n(t))))),
                            r.push({
                                url: t,
                                sampleRate: s,
                                rootKey: o,
                                percussion: a,
                                chipWaveLoopStart: l,
                                chipWaveLoopEnd: c,
                                chipWaveStartOffset: d,
                                chipWaveLoopMode: p,
                                chipWavePlayBackwards: m
                            })
                        }
                return {
                    entries: r
                }
            }
            ,
            this.Rm = t => {
                const e = t.url.trim()
                  , i = t.sampleRate
                  , n = t.rootKey
                  , s = t.percussion
                  , o = t.chipWaveLoopStart
                  , a = t.chipWaveLoopEnd
                  , r = t.chipWaveStartOffset
                  , h = t.chipWaveLoopMode
                  , l = t.chipWavePlayBackwards
                  , c = e.toLowerCase()
                  , d = "legacysamples" === c || "nintariboxsamples" === c || "mariopaintboxsamples" === c
                  , p = [];
                return 44100 !== i && p.push("s" + i),
                60 !== n && p.push("r" + n),
                s && p.push("p"),
                null != o && p.push("a" + o),
                null != a && p.push("b" + a),
                null != r && p.push("c" + r),
                null != h && p.push("d" + h),
                l && p.push("e"),
                d || p.length <= 0 ? e : "!" + p.join(",") + "!" + e
            }
            ,
            this.km = () => {
                let t = "";
                for (const e of this.tm) {
                    "" !== e.url.trim() && (t += "|" + this.Rm(e))
                }
                return t
            }
            ,
            this.Am = t => {
                try {
                    const e = new URL(t.url);
                    return decodeURIComponent(e.pathname.replace(/^([^\/]*\/)+/, ""))
                } catch (e) {
                    return t.url
                }
            }
            ,
            this.Pm = t => {
                function e(t, e) {
                    return (t % e + e) % e
                }
                const i = e((t = Math.floor(t) - 12) + p.keys[this.m.song.key].basePitch, p.pitchesPerOctave);
                let n = "";
                if (p.keys[i].isWhiteKey)
                    n = p.keys[i].name;
                else {
                    const s = p.blackKeyNameParents[e(t, p.pitchesPerOctave)];
                    n = p.keys[e(i + p.pitchesPerOctave + s, p.pitchesPerOctave)].name,
                    1 == s ? n += "♭" : -1 == s && (n += "♯")
                }
                return n += Math.floor(t / p.pitchesPerOctave),
                n
            }
            ,
            this.Rs = t => {
                for (; null !== this.sm.firstChild; )
                    this.sm.removeChild(this.sm.firstChild);
                for (let e = 0; e < this.tm.length; e++) {
                    const i = this.tm.length >= 2 && e > 0
                      , n = this.tm.length >= 2 && e < this.tm.length - 1
                      , s = this.tm[e]
                      , o = Boolean(this.im[e])
                      , a = Or({
                        style: "flex-grow: 1; margin-left: 1em; width: 100%;",
                        value: s.url
                    })
                      , r = Or({
                        style: "flex-grow: 1; margin-left: 1em; width: 100%;",
                        type: "number",
                        value: "" + s.sampleRate,
                        min: "8000",
                        max: "96000",
                        step: "1"
                    })
                      , h = Or({
                        style: "flex-grow: 1; margin-left: 1em; width: 100%;",
                        type: "number",
                        value: "" + s.rootKey,
                        min: "0",
                        max: p.maxPitch + p.pitchesPerOctave,
                        step: "1"
                    })
                      , l = Wr({
                        class: "add-sample-prompt-root-key-display",
                        style: "margin-left: 0.4em; width: 3em; text-align: left; text-overflow: ellipsis; overflow: hidden; flex-shrink: 0;"
                    }, `(${this.Pm(s.rootKey)})`)
                      , c = Or({
                        style: "width: 1em; margin-left: 1em;",
                        type: "checkbox"
                    })
                      , d = Or({
                        style: "flex-grow: 1; margin-left: 1em; width: 100%;",
                        type: "number",
                        value: "" + (null != s.chipWaveLoopStart ? s.chipWaveLoopStart : ""),
                        min: "0",
                        step: "1"
                    })
                      , m = Or({
                        style: "flex-grow: 1; margin-left: 1em; width: 100%;",
                        type: "number",
                        value: "" + (null != s.chipWaveLoopEnd ? s.chipWaveLoopEnd : ""),
                        min: "0",
                        step: "1"
                    })
                      , u = Or({
                        style: "flex-grow: 1; margin-left: 1em; width: 100%;",
                        type: "number",
                        value: "" + (null != s.chipWaveStartOffset ? s.chipWaveStartOffset : ""),
                        min: "0",
                        step: "1"
                    })
                      , f = Kr({
                        style: "width: 100%; flex-grow: 1; margin-left: 0.5em;"
                    }, Jr({
                        value: -1
                    }, ""), Jr({
                        value: 0
                    }, "Loop"), Jr({
                        value: 1
                    }, "Ping-Pong"), Jr({
                        value: 2
                    }, "Play Once"), Jr({
                        value: 3
                    }, "Play Loop Once"));
                    null != s.chipWaveLoopMode && (f.value = "" + s.chipWaveLoopMode);
                    const y = Or({
                        type: "checkbox",
                        style: "width: 1em; padding: 0; margin-left: auto; margin-right: auto;"
                    });
                    y.checked = s.chipWavePlayBackwards;
                    const b = this.Am(s);
                    c.checked = s.percussion;
                    const g = Rr({
                        style: "height: auto; min-height: var(--button-size);",
                        title: 'For use with "Add multiple samples"'
                    }, "Copy link preset")
                      , w = Rr({
                        style: "height: auto; min-height: var(--button-size); margin-left: 0.5em;"
                    }, "Remove")
                      , v = Rr({
                        style: "height: auto; min-height: var(--button-size); margin-left: 0.5em;"
                    }, Y.svg({
                        width: "16",
                        height: "16",
                        viewBox: "-13 -14 26 26",
                        "pointer-events": "none",
                        style: "width: 100%; height: 100%;"
                    }, Y.path({
                        d: "M -6 6 L 0 -6 L 6 6 z",
                        fill: nt.primaryText
                    })))
                      , x = Rr({
                        style: "height: auto; min-height: var(--button-size); margin-left: 0.5em;"
                    }, Y.svg({
                        width: "16",
                        height: "16",
                        viewBox: "-13 -14 26 26",
                        "pointer-events": "none",
                        style: "width: 100%; height: 100%;"
                    }, Y.path({
                        d: "M -6 -6 L 6 -6 L 0 6 z",
                        fill: nt.primaryText
                    })))
                      , k = Vr({
                        open: o,
                        style: "margin-bottom: 2em; margin-top: 1em;"
                    }, Gr({
                        style: "margin-bottom: 1em;"
                    }, "Options"), Nr({
                        style: "display: flex; flex-direction: row; align-items: center; justify-content: flex-end; margin-bottom: 0.5em;"
                    }, Nr({
                        style: `flex-shrink: 0; :text-align: right; color: ${nt.primaryText};`
                    }, Wr({
                        title: "What rate to resample to"
                    }, "Sample rate")), r), Nr({
                        style: "display: flex; flex-direction: row; align-items: center; justify-content: flex-end; margin-bottom: 0.5em;"
                    }, Nr({
                        style: `text-align: right; color: ${nt.primaryText}; flex-shrink: 0;`
                    }, Wr({
                        title: "Pitch where the sample is played as-is"
                    }, "Root key")), l, h), Nr({
                        style: "display: flex; flex-direction: row; align-items: center; justify-content: space-between; margin-bottom: 0.5em;"
                    }, Nr({
                        style: `text-align: right; color: ${nt.primaryText};`
                    }, "Percussion (pitch doesn't change with key)"), c), Nr({
                        style: "display: flex; flex-direction: row; align-items: center; justify-content: flex-end; margin-bottom: 0.5em;"
                    }, Nr({
                        style: `flex-shrink: 0; text-align: right; color: ${nt.primaryText};`
                    }, Wr({
                        title: 'Applies to the "Loop Start" loop control option of the preset created for this sample'
                    }, "Loop Start")), d), Nr({
                        style: "display: flex; flex-direction: row; align-items: center; justify-content: flex-end; margin-bottom: 0.5em;"
                    }, Nr({
                        style: `flex-shrink: 0; text-align: right; color: ${nt.primaryText};`
                    }, Wr({
                        title: 'Applies to the "Loop End" loop control option of the preset created for this sample'
                    }, "Loop End")), m), Nr({
                        style: "display: flex; flex-direction: row; align-items: center; justify-content: flex-end; margin-bottom: 0.5em;"
                    }, Nr({
                        style: `flex-shrink: 0; text-align: right; color: ${nt.primaryText};`
                    }, Wr({
                        title: 'Applies to the "Offset" loop control option of the preset created for this sample'
                    }, "Sample Start Offset")), u), Nr({
                        style: "display: flex; flex-direction: row; align-items: center; justify-content: flex-end; margin-bottom: 0.5em;"
                    }, Nr({
                        style: `flex-shrink: 0; text-align: right; color: ${nt.primaryText};`
                    }, Wr({
                        title: 'Applies to the "Loop Mode" loop control option of the preset created for this sample'
                    }, "Loop Mode")), f), Nr({
                        style: "display: flex; flex-direction: row; align-items: center; justify-content: flex-end; margin-bottom: 0.5em;"
                    }, Nr({
                        style: `flex-shrink: 0; text-align: right; color: ${nt.primaryText};`
                    }, Wr({
                        title: 'Applies to the "Backwards" loop control option of the preset created for this sample'
                    }, "Backwards")), y));
                    a.dataset.index = "" + e,
                    r.dataset.index = "" + e,
                    h.dataset.index = "" + e,
                    c.dataset.index = "" + e,
                    d.dataset.index = "" + e,
                    m.dataset.index = "" + e,
                    u.dataset.index = "" + e,
                    f.dataset.index = "" + e,
                    y.dataset.index = "" + e,
                    g.dataset.index = "" + e,
                    w.dataset.index = "" + e,
                    v.dataset.index = "" + e,
                    x.dataset.index = "" + e,
                    k.dataset.index = "" + e;
                    const M = Nr({
                        style: "display: flex; flex-direction: row; align-items: center; justify-content: flex-end;"
                    }, g, w);
                    i && M.appendChild(v),
                    n && M.appendChild(x);
                    const S = Nr({
                        style: `padding: 0.6em; margin: 0.4em; border: 1px solid ${nt.uiWidgetBackground}; border-radius: 4px;`
                    }, Nr({
                        class: "add-sample-prompt-sample-name",
                        style: `margin-bottom: 0.5em; color: ${nt.secondaryText}; text-overflow: ellipsis; overflow: hidden; white-space: nowrap;`,
                        title: b
                    }, b), Nr({
                        style: "display: flex; flex-direction: row; align-items: center; justify-content: flex-end; margin-bottom: 0.5em;"
                    }, Nr({
                        style: `text-align: right; color: ${nt.primaryText};`
                    }, "URL"), a), k, M);
                    k.addEventListener("toggle", this.Fm),
                    a.addEventListener("change", this.Cm),
                    r.addEventListener("change", this.Em),
                    h.addEventListener("change", this.Tm),
                    c.addEventListener("change", this.Bm),
                    d.addEventListener("change", this.Im),
                    m.addEventListener("change", this.Lm),
                    u.addEventListener("change", this.Dm),
                    f.addEventListener("change", this.zm),
                    y.addEventListener("change", this.qm),
                    g.addEventListener("click", this.Nm),
                    w.addEventListener("click", this.$m),
                    i && v.addEventListener("click", this.Hm),
                    n && x.addEventListener("click", this._m),
                    this.sm.appendChild(S);
                    const F = e === this.tm.length - 1;
                    t && F && S.scrollIntoView({
                        block: "nearest",
                        inline: "nearest"
                    })
                }
            }
            ,
            this.m = t,
            null != N.customSamples) {
                const t = this.Sm(N.customSamples, !1);
                this.tm = t.entries
            }
            this.nm.addEventListener("click", this.bm),
            this.om.addEventListener("click", this.gm),
            this.fm.addEventListener("click", this.wm),
            this.Re.addEventListener("click", this.He),
            this.Oe.addEventListener("click", this.$e),
            this.rm.addEventListener("click", this.vm),
            this.lm.addEventListener("click", this.xm),
            this.Mm(),
            this.Rs(!1)
        }
        Om(t) {
            let e;
            if (e = navigator,
            e.clipboard && e.clipboard.writeText)
                return void e.clipboard.writeText(t).catch(( () => {
                    window.prompt("Copy to clipboard:", t)
                }
                ));
            const i = document.createElement("textarea");
            i.textContent = t,
            document.body.appendChild(i),
            i.select();
            const n = document.execCommand("copy");
            i.remove(),
            this.container.focus({
                preventScroll: !0
            }),
            n || window.prompt("Copy this:", t)
        }
    }
    const {button: Zr, div: Xr, h2: th, select: eh, option: ih} = J;
    class nh {
        constructor(t) {
            this.m = t,
            this.Vm = eh({
                style: "width: 100%;"
            }, ih({
                value: "tinyurl"
            }, "tinyurl.com"), ih({
                value: "isgd"
            }, "is.gd")),
            this.Oe = Zr({
                class: "cancelButton"
            }),
            this.Re = Zr({
                class: "okayButton",
                style: "width:45%;"
            }, "Okay"),
            this.container = Xr({
                class: "prompt noSelection",
                style: "width: 250px;"
            }, th("Configure Shortener"), Xr({
                style: "display: flex; flex-direction: row; align-items: center; height: 2em; justify-content: flex-end;"
            }, Xr({
                class: "selectContainer",
                style: "width: 100%;"
            }, this.Vm)), Xr({
                style: "display: flex; flex-direction: row-reverse; justify-content: space-between;"
            }, this.Re), this.Oe),
            this.$e = () => {
                this.m.undo()
            }
            ,
            this.cleanUp = () => {
                this.Re.removeEventListener("click", this.He),
                this.Oe.removeEventListener("click", this.$e),
                this.container.removeEventListener("keydown", this.Ge)
            }
            ,
            this.Ge = t => {
                "BUTTON" != t.target.tagName && 13 == t.keyCode && this.He()
            }
            ,
            this.He = () => {
                window.localStorage.setItem("shortenerStrategySelect", this.Vm.value),
                this.m.prompt = null,
                this.m.undo()
            }
            ;
            const e = window.localStorage.getItem("shortenerStrategySelect");
            null != e && (this.Vm.value = e),
            this.Re.addEventListener("click", this.He),
            this.Oe.addEventListener("click", this.$e),
            this.container.addEventListener("keydown", this.Ge)
        }
    }
    const {button: sh, div: oh, input: ah, select: rh, span: hh, optgroup: lh, option: ch, canvas: dh} = J;
    function ph(t, e) {
        for (let i = 0; i < e.length; i++)
            t.appendChild(ch({
                value: i
            }, e[i]));
        return t
    }
    function mh(t, e) {
        const i = rh({
            id: e
        });
        t ? (i.appendChild(ch({
            value: 2
        }, N.valueToPreset(2).name)),
        i.appendChild(ch({
            value: 3
        }, N.valueToPreset(3).name)),
        i.appendChild(ch({
            value: 4
        }, N.valueToPreset(4).name))) : (i.appendChild(ch({
            value: 0
        }, N.valueToPreset(0).name)),
        i.appendChild(ch({
            value: 9
        }, N.valueToPreset(9).name)),
        i.appendChild(ch({
            value: 6
        }, N.valueToPreset(6).name)),
        i.appendChild(ch({
            value: 8
        }, N.valueToPreset(8).name)),
        i.appendChild(ch({
            value: 1
        }, N.valueToPreset(1).name)),
        i.appendChild(ch({
            value: 11
        }, N.instrumentToPreset(11).name)),
        i.appendChild(ch({
            value: 5
        }, N.valueToPreset(5).name)),
        i.appendChild(ch({
            value: 7
        }, N.valueToPreset(7).name)),
        i.appendChild(ch({
            value: 3
        }, N.valueToPreset(3).name)),
        i.appendChild(ch({
            value: 2
        }, N.valueToPreset(2).name)));
        const n = lh({
            label: "Randomize ▾"
        });
        n.appendChild(ch({
            value: "randomPreset"
        }, "Random Preset")),
        n.appendChild(ch({
            value: "randomGenerated"
        }, "Random Generated")),
        i.appendChild(n);
        let s = null
          , o = null;
        for (let e = 1; e < N.presetCategories.length; e++) {
            const n = N.presetCategories[e]
              , a = lh({
                label: n.name + " ▾"
            });
            let r = !1;
            for (let i = 0; i < n.presets.length; i++) {
                const s = n.presets[i];
                1 == s.isNoise == t && (a.appendChild(ch({
                    value: (e << 6) + i
                }, s.name)),
                r = !0)
            }
            if (1 === e && r ? s = a : "Custom Sample Presets" === n.name && r && (o = a),
            "String Presets" == n.name && r) {
                let t = a.removeChild(a.children[11]);
                a.insertBefore(t, a.children[1])
            }
            if ("Flute Presets" == n.name && r) {
                let t = a.removeChild(a.children[11]);
                a.insertBefore(t, a.children[1])
            }
            if ("Keyboard Presets" == n.name && r) {
                let t = a.removeChild(a.children[9])
                  , e = a.removeChild(a.children[9]);
                a.insertBefore(e, a.children[1]),
                a.insertBefore(t, a.children[1])
            }
            r && i.appendChild(a)
        }
        if (null != s && null != o) {
            const t = o.parentNode;
            t.removeChild(o),
            t.insertBefore(o, s)
        }
        return i
    }
    function uh(t, e, i=!1) {
        const n = e.toString();
        t.value != n && (t.value = n,
        i && $(t).val(e).trigger("change.select2"))
    }
    class fh {
        constructor(t, e, i) {
            this.canvas = t,
            this.m = e,
            this.Po = i,
            this.Fo = null,
            this._r = t => {
                if (this.mouseDown) {
                    var e = (t.clientX || t.pageX) - this.canvas.getBoundingClientRect().left
                      , i = Math.floor((t.clientY || t.pageY) - this.canvas.getBoundingClientRect().top);
                    i < 2 && (i = 2),
                    i > 50 && (i = 50);
                    var n = this.canvas.getContext("2d");
                    if (1 == this.continuousEdit && Math.abs(this.lastX - e) < 40) {
                        var s = e < this.lastX ? e : this.lastX
                          , o = e < this.lastX ? this.lastX : e;
                        for (let t = s; t <= o; t += 2) {
                            var a = Math.abs(e - this.lastX) > 2 ? e > this.lastX ? 1 - (t - s) / (o - s) : (t - s) / (o - s) : 0
                              , r = Math.round(i + (this.lastY - i) * a);
                            n.fillStyle = nt.getComputed("--editor-background"),
                            n.fillRect(2 * Math.floor(t / 2), 0, 2, 53),
                            n.fillStyle = nt.getComputed("--ui-widget-background"),
                            n.fillRect(2 * Math.floor(t / 2), 25, 2, 2),
                            n.fillStyle = nt.getComputed("--track-editor-bg-pitch-dim"),
                            n.fillRect(2 * Math.floor(t / 2), 13, 2, 1),
                            n.fillRect(2 * Math.floor(t / 2), 39, 2, 1),
                            n.fillStyle = nt.getComputedChannelColor(this.m.song, this.m.channel).primaryNote,
                            n.fillRect(2 * Math.floor(t / 2), r - 2, 2, 4),
                            this.newArray[Math.floor(t / 2)] = r - 26
                        }
                    } else
                        n.fillStyle = nt.getComputed("--editor-background"),
                        n.fillRect(2 * Math.floor(e / 2), 0, 2, 52),
                        n.fillStyle = nt.getComputed("--ui-widget-background"),
                        n.fillRect(2 * Math.floor(e / 2), 25, 2, 2),
                        n.fillStyle = nt.getComputed("--track-editor-bg-pitch-dim"),
                        n.fillRect(2 * Math.floor(e / 2), 13, 2, 1),
                        n.fillRect(2 * Math.floor(e / 2), 39, 2, 1),
                        n.fillStyle = nt.getComputedChannelColor(this.m.song, this.m.channel).primaryNote,
                        n.fillRect(2 * Math.floor(e / 2), i - 2, 2, 4),
                        this.newArray[Math.floor(e / 2)] = i - 26;
                    this.continuousEdit = !0,
                    this.lastX = e,
                    this.lastY = i;
                    let h = this.m.song.channels[this.m.channel].instruments[this.m.getCurrentInstrument()]
                      , l = 0;
                    for (let t = 0; t < this.newArray.length; t++)
                        l += this.newArray[t];
                    const c = l / this.newArray.length;
                    let d = 0
                      , p = 0;
                    for (let t = 0; t < this.newArray.length; t++)
                        d += p,
                        p = this.newArray[t] - c,
                        h.customChipWaveIntegral[t] = d;
                    h.customChipWaveIntegral[64] = 0
                }
            }
            ,
            this.Gm = t => {
                this.mouseDown = !0,
                this._r(t)
            }
            ,
            this.Wm = () => {
                this.mouseDown = !1,
                this.continuousEdit = !1,
                this.Do()
            }
            ,
            this.Do = () => {
                this.Fo = this.Po(this.newArray),
                this.m.record(this.Fo),
                this.Fo = null
            }
            ,
            t.addEventListener("mousemove", this._r),
            t.addEventListener("mousedown", this.Gm),
            t.addEventListener("mouseup", this.Wm),
            t.addEventListener("mouseleave", this.Wm),
            this.mouseDown = !1,
            this.continuousEdit = !1,
            this.lastX = 0,
            this.lastY = 0,
            this.newArray = new Float32Array(64),
            this.renderedArray = new Float32Array(64),
            this.renderedColor = "",
            this.redrawCanvas()
        }
        redrawCanvas() {
            const t = this.m.song.channels[this.m.channel].instruments[this.m.getCurrentInstrument()].customChipWave
              , e = nt.getComputedChannelColor(this.m.song, this.m.channel).primaryNote;
            let i = !1;
            if (e != this.renderedColor)
                i = !0;
            else
                for (let e = 0; e < 64; e++)
                    t[e] != this.renderedArray[e] && (i = !0,
                    e = 64);
            if (i) {
                this.renderedArray.set(t);
                var n = this.canvas.getContext("2d");
                n.fillStyle = nt.getComputed("--editor-background"),
                n.fillRect(0, 0, 128, 52),
                n.fillStyle = nt.getComputed("--ui-widget-background"),
                n.fillRect(0, 25, 128, 2),
                n.fillStyle = nt.getComputed("--track-editor-bg-pitch-dim"),
                n.fillRect(0, 13, 128, 1),
                n.fillRect(0, 39, 128, 1),
                n.fillStyle = e;
                for (let e = 0; e < 64; e++) {
                    var s = t[e] + 26;
                    n.fillRect(2 * e, s - 2, 2, 4),
                    this.newArray[e] = s - 26
                }
            }
        }
    }
    class yh {
        constructor(t, e, i) {
            this.canvas = t,
            this.m = e,
            this.Po = i,
            this.Fo = null,
            this._r = t => {
                var e, i, n, s;
                if (this.mouseDown) {
                    var o = (t.clientX || t.pageX) - this.canvas.getBoundingClientRect().left
                      , a = Math.floor((t.clientY || t.pageY) - this.canvas.getBoundingClientRect().top)
                      , r = this.canvas.getContext("2d");
                    r.fillStyle = nt.getComputedChannelColor(this.m.song, this.m.channel).primaryNote;
                    var h = Math.ceil(a / 12)
                      , l = Math.ceil(o / 12);
                    if (h = (h = h / 2 - Math.floor(h / 2) >= .5 ? Math.floor(h / 2) : -1) >= 0 && h <= 5 ? h : -1,
                    l = (l = l / 2 + .5 - Math.floor(l / 2) <= .5 ? Math.floor(l / 2) - 1 : -1) >= 0 && l <= 5 ? l : -1,
                    r.fillRect(24 * l + 12, 24 * h, 2, 2),
                    -1 == this.selected)
                        null != (null === (i = null === (e = this.drawArray) || void 0 === e ? void 0 : e[h]) || void 0 === i ? void 0 : i[l]) && (this.selected = this.drawArray[h][l],
                        r.fillRect(24 * l + 12, 24 * h, 12, 12),
                        r.fillStyle = nt.getComputed("--editor-background"),
                        r.fillText(this.drawArray[h][l] + "", 24 * l + 14, 24 * h + 10),
                        this.mouseDown = !1);
                    else if (null != (null === (s = null === (n = this.drawArray) || void 0 === n ? void 0 : n[h]) || void 0 === s ? void 0 : s[l])) {
                        if ("feedback" == this.mode) {
                            const t = this.drawArray[h][l];
                            let e = this.feedback[t - 1].indexOf(this.selected);
                            -1 != e ? this.feedback[t - 1].splice(e, 1) : this.feedback[t - 1].push(this.selected)
                        } else if (this.drawArray[h][l] == this.selected)
                            this.selected == this.carriers ? this.selected > 1 && this.carriers-- : this.selected - 1 == this.carriers && this.carriers++;
                        else {
                            const t = this.drawArray[h][l];
                            if (this.selected > t) {
                                let e = this.newMods[t - 1].indexOf(this.selected);
                                -1 != e ? this.newMods[t - 1].splice(e, 1) : this.newMods[t - 1].push(this.selected)
                            } else {
                                let e = this.newMods[this.selected - 1].indexOf(t);
                                -1 != e ? this.newMods[this.selected - 1].splice(e, 1) : this.newMods[this.selected - 1].push(t)
                            }
                        }
                        this.selected = -1,
                        this.redrawCanvas(!0),
                        this.mouseDown = !1
                    } else
                        this.selected = -1,
                        this.redrawCanvas(!0),
                        this.mouseDown = !1
                }
            }
            ,
            this.Gm = t => {
                this.mouseDown = !0,
                this._r(t)
            }
            ,
            this.Wm = () => {
                this.mouseDown = !1,
                this.Do()
            }
            ,
            this.Do = () => {
                this.Fo = this.Po("algorithm" == this.mode ? this.newMods : this.feedback, this.carriers, this.mode),
                this.m.record(this.Fo),
                this.Fo = null
            }
            ,
            t.addEventListener("mousemove", this._r),
            t.addEventListener("mousedown", this.Gm),
            t.addEventListener("mouseup", this.Wm),
            t.addEventListener("mouseleave", this.Wm),
            this.mouseDown = !1,
            this.drawArray = [[], [], [], [], [], []],
            this.lookUpArray = [[], [], [], [], [], []],
            this.carriers = 1,
            this.selected = -1,
            this.newMods = [[], [], [], [], [], []],
            this.inverseModulation = [[], [], [], [], [], []],
            this.feedback = [[], [], [], [], [], []],
            this.inverseFeedback = [[], [], [], [], [], []],
            this.mode = "algorithm",
            this.redrawCanvas()
        }
        reset() {
            this.redrawCanvas(!1),
            this.selected = -1
        }
        fillDrawArray(t=!1) {
            if (t) {
                this.drawArray = [],
                this.drawArray = [[], [], [], [], [], []],
                this.inverseModulation = [[], [], [], [], [], []],
                this.lookUpArray = [[], [], [], [], [], []];
                for (let t = 0; t < this.newMods.length; t++)
                    for (let e = 0; e < this.newMods[t].length; e++)
                        this.inverseModulation[this.newMods[t][e] - 1].push(t + 1);
                if ("feedback" == this.mode) {
                    this.inverseFeedback = [[], [], [], [], [], []];
                    for (let t = 0; t < this.feedback.length; t++)
                        for (let e = 0; e < this.feedback[t].length; e++)
                            this.inverseFeedback[this.feedback[t][e] - 1].push(t + 1)
                }
            } else {
                this.drawArray = [],
                this.drawArray = [[], [], [], [], [], []],
                this.carriers = 1,
                this.newMods = [[], [], [], [], [], []],
                this.inverseModulation = [[], [], [], [], [], []],
                this.lookUpArray = [[], [], [], [], [], []];
                var e = this.m.song.channels[this.m.channel].instruments[this.m.getCurrentInstrument()].customAlgorithm;
                this.carriers = e.carrierCount;
                for (let t = 0; t < e.modulatedBy.length; t++)
                    for (let i = 0; i < e.modulatedBy[t].length; i++)
                        this.inverseModulation[e.modulatedBy[t][i] - 1].push(t + 1),
                        this.newMods[t][i] = e.modulatedBy[t][i];
                if ("feedback" == this.mode) {
                    this.feedback = [[], [], [], [], [], []],
                    this.inverseFeedback = [[], [], [], [], [], []];
                    var i = this.m.song.channels[this.m.channel].instruments[this.m.getCurrentInstrument()].customFeedbackType.indices;
                    for (let t = 0; t < i.length; t++)
                        for (let e = 0; e < i[t].length; e++)
                            this.inverseFeedback[i[t][e] - 1].push(t + 1),
                            this.feedback[t][e] = i[t][e]
                }
            }
            for (let t = 0; t < this.inverseModulation.length; t++)
                if (t < this.carriers)
                    this.drawArray[this.drawArray.length - 1][t] = t + 1,
                    this.lookUpArray[t] = [0, t];
                else if (null != this.inverseModulation[t][0]) {
                    let e = [this.drawArray.length - (this.lookUpArray[this.inverseModulation[t][this.inverseModulation[t].length - 1] - 1][0] + 2), this.lookUpArray[this.inverseModulation[t][this.inverseModulation[t].length - 1] - 1][1]];
                    if (null != this.drawArray[e[0]][e[1]]) {
                        for (; null != this.drawArray[e[0]][e[1]] && e[1] < 6; )
                            if (e[1]++,
                            null == this.drawArray[e[0]][e[1]]) {
                                this.drawArray[e[0]][e[1]] = t + 1,
                                this.lookUpArray[t] = [this.drawArray.length - (e[0] + 1), e[1]];
                                break
                            }
                    } else
                        this.drawArray[e[0]][e[1]] = t + 1,
                        this.lookUpArray[t] = [this.drawArray.length - (e[0] + 1), e[1]]
                } else {
                    let e = [5, 0];
                    for (; null != this.drawArray[e[0]][e[1]] && e[1] < 6; )
                        if (e[1]++,
                        null == this.drawArray[e[0]][e[1]]) {
                            this.drawArray[e[0]][e[1]] = t + 1,
                            this.lookUpArray[t] = [this.drawArray.length - (e[0] + 1), e[1]];
                            break
                        }
                }
        }
        drawLines(t) {
            if ("feedback" != this.mode)
                for (let e = 0; e < 6; e++) {
                    t.strokeStyle = nt.getArbitaryChannelColor("pitch", e).primaryChannel;
                    const i = 2 * e - 1 + .5;
                    for (let n = 0; n < this.inverseModulation[e].length; n++) {
                        let s = this.inverseModulation[e][n] - 1
                          , o = this.lookUpArray[e]
                          , a = this.lookUpArray[s];
                        t.beginPath(),
                        t.moveTo(24 * o[1] + 12 + i, 24 * (6 - o[0] - 1) + 12),
                        t.lineTo(24 * o[1] + 12 + i, 24 * (6 - o[0] - 1) + 12 + i),
                        a[1] != o[1] ? (t.lineTo(24 * o[1] + i, 24 * (6 - o[0] - 1) + 12 + i),
                        a[1] == o[1] - 1 && a[0] <= o[0] - 1 || (t.lineTo(24 * o[1] + i, 24 * (6 - a[0] - 1) + 12 + i),
                        t.lineTo(24 * (a[1] + 1) + i, 24 * (6 - a[0] - 1) + 12 + i)),
                        t.lineTo(24 * (a[1] + 1) + i, 24 * (6 - a[0] - 1) + i - 12),
                        t.lineTo(24 * a[1] + 12 + i, 24 * (6 - a[0] - 1) + i - 12),
                        t.lineTo(24 * a[1] + 12 + i, 24 * (6 - a[0] - 1))) : 1 == Math.abs(a[0] - o[0]) ? t.lineTo(24 * a[1] + 12 + i, 24 * (6 - a[0] - 1)) : (t.lineTo(24 * o[1] + i, 24 * (6 - o[0] - 1) + 12 + i),
                        t.lineTo(24 * o[1] + i, 24 * (6 - a[0] - 1) + i - 12),
                        t.lineTo(24 * o[1] + 12 + i, 24 * (6 - a[0] - 1) + i - 12),
                        t.lineTo(24 * o[1] + 12 + i, 24 * (6 - a[0] - 1))),
                        t.lineWidth = 1,
                        t.stroke()
                    }
                }
            else
                for (let e = 0; e < 6; e++) {
                    t.strokeStyle = nt.getArbitaryChannelColor("pitch", e).primaryChannel;
                    const i = 2 * e + .5;
                    for (let n = 0; n < this.inverseFeedback[e].length; n++) {
                        let s = this.inverseFeedback[e][n] - 1
                          , o = this.lookUpArray[e]
                          , a = this.lookUpArray[s];
                        if (t.beginPath(),
                        t.moveTo(24 * o[1] + 12 + i, 24 * (6 - o[0] - 1) + 12),
                        t.lineTo(24 * o[1] + 12 + i, 24 * (6 - o[0] - 1) + 12 + i),
                        a[1] != o[1]) {
                            let e = 0;
                            a[0] >= o[0] && (e = 24),
                            t.lineTo(24 * o[1] + e + i, 24 * (6 - o[0] - 1) + 12 + i),
                            a[1] == o[1] - 1 && a[0] <= o[0] - 1 || (a[0] >= o[0] ? (t.lineTo(24 * (a[1] + 1) + i, 24 * (6 - o[0] - 1) + 12 + i),
                            t.lineTo(24 * (a[1] + 1) + i, 24 * (6 - a[0] - 1) + 12 + i)) : (t.lineTo(24 * o[1] + i, 24 * (6 - a[0] - 1) + 12 + i),
                            t.lineTo(24 * (a[1] + 1) + i, 24 * (6 - a[0] - 1) + 12 + i))),
                            t.lineTo(24 * (a[1] + 1) + i, 24 * (6 - a[0] - 1) + i - 12),
                            t.lineTo(24 * a[1] + 12 + i, 24 * (6 - a[0] - 1) + i - 12),
                            t.lineTo(24 * a[1] + 12 + i, 24 * (6 - a[0] - 1))
                        } else
                            o[0] - a[0] == 1 ? t.lineTo(24 * a[1] + 12 + i, 24 * (6 - a[0] - 1)) : a[0] >= o[0] ? (t.lineTo(24 * o[1] + 24 + i, 24 * (6 - o[0] - 1) + 12 + i),
                            t.lineTo(24 * o[1] + 24 + i, 24 * (6 - a[0] - 1) + i - 12),
                            t.lineTo(24 * a[1] + i + 12, 24 * (6 - a[0] - 1) + i - 12),
                            t.lineTo(24 * a[1] + i + 12, 24 * (6 - a[0] - 1))) : (t.lineTo(24 * o[1] + i, 24 * (6 - o[0] - 1) + 12 + i),
                            t.lineTo(24 * o[1] + i, 24 * (6 - a[0] - 1) + i - 12),
                            t.lineTo(24 * a[1] + 12 + i, 24 * (6 - a[0] - 1) + i - 12),
                            t.lineTo(24 * a[1] + 12 + i, 24 * (6 - a[0] - 1)));
                        t.lineWidth = 1,
                        t.stroke()
                    }
                }
        }
        redrawCanvas(t=!1) {
            this.fillDrawArray(t);
            var e = this.canvas.getContext("2d");
            e.fillStyle = nt.getComputed("--editor-background"),
            e.fillRect(0, 0, 144, 144);
            for (let t = 0; t < 6; t++)
                for (let i = 0; i < 6; i++)
                    e.fillStyle = nt.getComputed("--track-editor-bg-pitch-dim"),
                    e.fillRect(24 * t + 12, 24 * i, 12, 12),
                    e.fillStyle = nt.getComputed("--editor-background"),
                    e.fillRect(24 * t + 13, 24 * i + 1, 10, 10),
                    null != this.drawArray[i][t] && (this.drawArray[i][t] <= this.carriers ? (e.fillStyle = nt.getComputed("--primary-text"),
                    e.fillRect(24 * t + 12, 24 * i, 12, 12),
                    e.fillStyle = nt.getComputed("--editor-background"),
                    e.fillRect(24 * t + 13, 24 * i + 1, 10, 10),
                    e.fillStyle = nt.getComputedChannelColor(this.m.song, this.m.channel).primaryNote,
                    e.fillText(this.drawArray[i][t] + "", 24 * t + 14, 24 * i + 10)) : (e.fillStyle = nt.getComputedChannelColor(this.m.song, this.m.channel).primaryNote,
                    e.fillRect(24 * t + 12, 24 * i, 12, 12),
                    e.fillStyle = nt.getComputed("--editor-background"),
                    e.fillRect(24 * t + 13, 24 * i + 1, 10, 10),
                    e.fillStyle = nt.getComputed("--primary-text"),
                    e.fillText(this.drawArray[i][t] + "", 24 * t + 14, 24 * i + 10)));
            this.drawLines(e)
        }
    }
    class bh {
        constructor(t) {
            this.m = t,
            this.prompt = null,
            this.rc = new sa(this.m),
            this.jm = new aa(this.m,!1,-1),
            this.Um = new aa(this.m,!0,0),
            this.Km = new aa(this.m,!1,1),
            this.Ua = new wr(this.m,this),
            this.Jm = new Xo(this.m,this),
            this.Ym = new Vo(this.m,this.Ua),
            this.Gr = new ra(this.m),
            this.Qm = new ta(this.m,this.Gr),
            this.ci = sh({
                class: "playButton",
                type: "button",
                title: "Play (Space)"
            }, hh("Play")),
            this.Zm = sh({
                class: "pauseButton",
                style: "display: none;",
                type: "button",
                title: "Pause (Space)"
            }, "Pause"),
            this.Xm = sh({
                class: "recordButton",
                style: "display: none;",
                type: "button",
                title: "Record (Ctrl+Space)"
            }, hh("Record")),
            this.tu = sh({
                class: "stopButton",
                style: "display: none;",
                type: "button",
                title: "Stop Recording (Space)"
            }, "Stop Recording"),
            this.eu = sh({
                class: "prevBarButton",
                type: "button",
                title: "Previous Bar (left bracket)"
            }),
            this.iu = sh({
                class: "nextBarButton",
                type: "button",
                title: "Next Bar (right bracket)"
            }),
            this.nu = new lo(ah({
                title: "main volume",
                style: "width: 5em; flex-grow: 1; margin: 0;",
                type: "range",
                min: "0",
                max: "75",
                value: "50",
                step: "1"
            }),this.m,null,!1),
            this.su = Y.rect({
                "pointer-events": "none",
                width: "90%",
                height: "50%",
                x: "5%",
                y: "25%",
                fill: nt.uiWidgetBackground
            }),
            this.Ba = Y.rect({
                "pointer-events": "none",
                height: "50%",
                width: "0%",
                x: "5%",
                y: "25%",
                fill: "url('#volumeGrad2')"
            }),
            this.Ia = Y.rect({
                "pointer-events": "none",
                width: "2px",
                height: "50%",
                x: "5%",
                y: "25%",
                fill: nt.uiWidgetFocus
            }),
            this.La = Y.stop({
                "stop-color": "lime",
                offset: "60%"
            }),
            this.Da = Y.stop({
                "stop-color": "orange",
                offset: "90%"
            }),
            this.za = Y.stop({
                "stop-color": "red",
                offset: "100%"
            }),
            this.qa = Y.linearGradient({
                id: "volumeGrad2",
                gradientUnits: "userSpaceOnUse"
            }, this.La, this.Da, this.za),
            this.Na = Y.defs({}, this.qa),
            this.ou = Y.svg({
                style: "touch-action: none; overflow: visible; margin: auto; max-width: 20vw;",
                width: "160px",
                height: "100%",
                preserveAspectRatio: "none",
                viewBox: "0 0 160 12"
            }, this.Na, this.su, this.Ba, this.Ia),
            this.au = oh({
                class: "playback-volume-bar",
                style: "height: 12px; align-self: center;"
            }, this.ou),
            this.ru = rh({
                style: "width: 100%;"
            }, ch({
                selected: !0,
                disabled: !0,
                hidden: !1
            }, "File"), ch({
                value: "new"
            }, "+ New Blank Song (⇧`)"), ch({
                value: "import"
            }, "↑ Import Song... (" + N.ctrlSymbol + "O)"), ch({
                value: "export"
            }, "↓ Export Song... (" + N.ctrlSymbol + "S)"), ch({
                value: "copyUrl"
            }, "⎘ Copy Song URL"), ch({
                value: "shareUrl"
            }, "⤳ Share Song URL"), ch({
                value: "configureShortener"
            }, "🛠 Customize Url Shortener..."), ch({
                value: "shortenUrl"
            }, "… Shorten Song URL"), ch({
                value: "viewPlayer"
            }, "▶ View in Song Player (⇧P)"), ch({
                value: "copyEmbed"
            }, "⎘ Copy HTML Embed Code"), ch({
                value: "songRecovery"
            }, "⚠ Recover Recent Song... (`)")),
            this.hu = rh({
                style: "width: 100%;"
            }, ch({
                selected: !0,
                disabled: !0,
                hidden: !1
            }, "Edit"), ch({
                value: "undo"
            }, "Undo (Z)"), ch({
                value: "redo"
            }, "Redo (Y)"), ch({
                value: "copy"
            }, "Copy Pattern (C)"), ch({
                value: "pasteNotes"
            }, "Paste Pattern Notes (V)"), ch({
                value: "pasteNumbers"
            }, "Paste Pattern Numbers (" + N.ctrlSymbol + "⇧V)"), ch({
                value: "insertBars"
            }, "Insert Bar (⏎)"), ch({
                value: "deleteBars"
            }, "Delete Selected Bars (⌫)"), ch({
                value: "insertChannel"
            }, "Insert Channel (" + N.ctrlSymbol + "⏎)"), ch({
                value: "deleteChannel"
            }, "Delete Selected Channels (" + N.ctrlSymbol + "⌫)"), ch({
                value: "selectChannel"
            }, "Select Channel (⇧A)"), ch({
                value: "selectAll"
            }, "Select All (A)"), ch({
                value: "duplicatePatterns"
            }, "Duplicate Reused Patterns (D)"), ch({
                value: "transposeUp"
            }, "Move Notes Up (+ or ⇧+)"), ch({
                value: "transposeDown"
            }, "Move Notes Down (- or ⇧-)"), ch({
                value: "moveNotesSideways"
            }, "Move All Notes Sideways... (W)"), ch({
                value: "generateEuclideanRhythm"
            }, "Generate Euclidean Rhythm... (E)"), ch({
                value: "beatsPerBar"
            }, "Change Beats Per Bar... (⇧B)"), ch({
                value: "barCount"
            }, "Change Song Length... (L)"), ch({
                value: "channelSettings"
            }, "Channel Settings... (Q)"), ch({
                value: "limiterSettings"
            }, "Limiter Settings... (⇧L)"), ch({
                value: "addExternal"
            }, "Add Custom Samples... (⇧Q)")),
            this.lu = rh({
                style: "width: 100%;"
            }, ch({
                selected: !0,
                disabled: !0,
                hidden: !1
            }, "Preferences"), lh({
                label: "Technical"
            }, ch({
                value: "autoPlay"
            }, "Auto Play on Load"), ch({
                value: "autoFollow"
            }, "Auto Follow Playhead"), ch({
                value: "enableNotePreview"
            }, "Hear Added Notes"), ch({
                value: "notesOutsideScale"
            }, "Place Notes Out of Scale"), ch({
                value: "setDefaultScale"
            }, "Set Current Scale as Default"), ch({
                value: "alwaysFineNoteVol"
            }, "Always Fine Note Volume"), ch({
                value: "enableChannelMuting"
            }, "Enable Channel Muting"), ch({
                value: "instrumentCopyPaste"
            }, "Enable Copy/Paste Buttons"), ch({
                value: "instrumentImportExport"
            }, "Enable Import/Export Buttons"), ch({
                value: "displayBrowserUrl"
            }, "Enable Song Data in URL"), ch({
                value: "closePromptByClickoff"
            }, "Close Prompts on Click Off"), ch({
                value: "recordingSetup"
            }, "Note Recording...")), lh({
                label: "Appearance"
            }, ch({
                value: "showFifth"
            }, 'Highlight "Fifth" Note'), ch({
                value: "notesFlashWhenPlayed"
            }, "Notes Flash When Played"), ch({
                value: "instrumentButtonsAtTop"
            }, "Instrument Buttons at Top"), ch({
                value: "frostedGlassBackground"
            }, "Frosted Glass Prompt Backdrop"), ch({
                value: "showChannels"
            }, "Show All Channels"), ch({
                value: "showScrollBar"
            }, "Show Octave Scroll Bar"), ch({
                value: "showInstrumentScrollbars"
            }, "Show Intsrument Scrollbars"), ch({
                value: "showLetters"
            }, "Show Piano Keys"), ch({
                value: "displayVolumeBar"
            }, "Show Playback Volume"), ch({
                value: "showOscilloscope"
            }, "Show Oscilloscope"), ch({
                value: "showSampleLoadingStatus"
            }, "Show Sample Loading Status"), ch({
                value: "showDescription"
            }, "Show Description"), ch({
                value: "layout"
            }, "Set Layout..."), ch({
                value: "colorTheme"
            }, "Set Theme..."), ch({
                value: "customTheme"
            }, "Custom Theme..."))),
            this.cu = ph(rh(), p.scales.map((t => t.name))),
            this.du = ph(rh(), p.keys.map((t => t.name)).reverse()),
            this.pu = ah({
                style: "width: 59.5%;",
                type: "number",
                min: p.octaveMin,
                max: p.octaveMax,
                value: "0"
            }),
            this.mu = new lo(ah({
                style: "margin: 0; vertical-align: middle;",
                type: "range",
                min: "1",
                max: "500",
                value: "160",
                step: "1"
            }),this.m,( (t, e) => new mn(this.m,t,e)),!1),
            this.uu = ah({
                style: "width: 4em; font-size: 80%; margin-left: 0.4em; vertical-align: middle;",
                type: "number",
                step: "1"
            }),
            this.fu = new lo(ah({
                style: "margin: 0;",
                type: "range",
                min: "0",
                max: p.chorusRange - 1,
                value: "0",
                step: "1"
            }),this.m,( (t, e) => new yn(this.m,t,e)),!1),
            this.yu = oh({
                class: "selectRow"
            }, hh({
                class: "tip",
                onclick: () => this.bu("chorus")
            }, "Chorus:"), this.fu.container),
            this.gu = new lo(ah({
                style: "margin: 0; position: sticky,",
                type: "range",
                min: "0",
                max: p.reverbRange - 1,
                value: "0",
                step: "1"
            }),this.m,( (t, e) => new bn(this.m,t,e)),!1),
            this.wu = oh({
                class: "selectRow"
            }, hh({
                class: "tip",
                onclick: () => this.bu("reverb")
            }, "Reverb:"), this.gu.container),
            this.vu = new lo(ah({
                style: "margin: 0;",
                type: "range",
                min: "0",
                max: p.echoSustainRange - 1,
                value: "0",
                step: "1"
            }),this.m,( (t, e) => new fn(this.m,t,e)),!1),
            this.xu = oh({
                class: "selectRow"
            }, hh({
                class: "tip",
                onclick: () => this.bu("echoSustain")
            }, "Echo:"), this.vu.container),
            this.ku = new lo(ah({
                style: "margin: 0;",
                type: "range",
                min: "0",
                max: p.echoDelayRange - 1,
                value: "0",
                step: "1"
            }),this.m,( (t, e) => new un(this.m,t,e)),!1),
            this.Mu = oh({
                class: "selectRow"
            }, hh({
                class: "tip",
                onclick: () => this.bu("echoDelay")
            }, "Echo Delay:"), this.ku.container),
            this.Su = ph(rh(), p.rhythms.map((t => t.name))),
            this.Fu = mh(!1, "pitchPresetSelect"),
            this.Cu = mh(!0, "drumPresetSelect"),
            this.Au = ph(rh(), p.algorithms.map((t => t.name))),
            this.Eu = oh({
                class: "selectRow"
            }, hh({
                class: "tip",
                onclick: () => this.bu("algorithm")
            }, "Algorithm: "), oh({
                class: "selectContainer"
            }, this.Au)),
            this.Tu = [],
            this.Pu = sh({
                type: "button",
                class: "add-instrument last-button"
            }),
            this.Bu = sh({
                type: "button",
                class: "remove-instrument"
            }),
            this.Iu = oh({
                class: "instrument-bar"
            }, this.Bu, this.Pu),
            this.Lu = oh({
                class: "selectRow",
                style: "display: none;"
            }, hh({
                class: "tip",
                onclick: () => this.bu("instrumentIndex")
            }, "Instrument:"), this.Iu),
            this.Du = new lo(ah({
                style: "margin: 0; position: sticky;",
                type: "range",
                min: Math.floor(-p.volumeRange / 2),
                max: Math.floor(p.volumeRange / 2),
                value: "0",
                step: "1"
            }),this.m,( (t, e) => new Pn(this.m,t,e)),!0),
            this.zu = ah({
                style: "width: 4em; font-size: 80%",
                id: "volumeSliderInputBox",
                type: "number",
                step: "1",
                min: Math.floor(-p.volumeRange / 2),
                max: Math.floor(p.volumeRange / 2),
                value: "0"
            }),
            this.qu = oh({
                class: "selectRow",
                style: "height: 1em"
            }, hh({
                class: "tip",
                style: "font-size: smaller;",
                onclick: () => this.bu("instrumentVolume")
            }, "Volume: ")),
            this.Nu = oh({
                class: "selectRow"
            }, oh({}, oh({
                style: `color: ${nt.secondaryText};`
            }, hh({
                class: "tip"
            }, this.qu)), oh({
                style: `color: ${nt.secondaryText}; margin-top: -3px;`
            }, this.zu)), this.Du.container),
            this.Ou = new lo(ah({
                style: "margin: 0; position: sticky;",
                type: "range",
                min: "0",
                max: p.panMax,
                value: p.panCenter,
                step: "1"
            }),this.m,( (t, e) => new Ln(this.m,t,e)),!0),
            this.Ru = sh({
                style: "margin-left:0em; height:1.5em; width: 10px; padding: 0px; font-size: 8px;",
                onclick: () => this.$u(1)
            }, "▼"),
            this.Hu = ah({
                style: "width: 4em; font-size: 80%; ",
                id: "panSliderInputBox",
                type: "number",
                step: "1",
                min: "0",
                max: "100",
                value: "0"
            }),
            this._u = oh({
                class: "selectRow"
            }, oh({}, hh({
                class: "tip",
                tabindex: "0",
                style: "height:1em; font-size: smaller;",
                onclick: () => this.bu("pan")
            }, "Pan: "), oh({
                style: "color: " + nt.secondaryText + "; margin-top: -3px;"
            }, this.Hu)), this.Ru, this.Ou.container),
            this.Vu = new lo(ah({
                style: "margin: 0;",
                type: "range",
                min: "0",
                max: p.modulators.dictionary["pan delay"].maxRawVol,
                value: "0",
                step: "1"
            }),this.m,( (t, e) => new Dn(this.m,t,e)),!1),
            this.Gu = oh({
                class: "selectRow dropFader"
            }, hh({
                class: "tip",
                style: "margin-left:4px;",
                onclick: () => this.bu("panDelay")
            }, "‣ Delay:"), this.Vu.container),
            this.Wu = oh({
                class: "editor-controls",
                style: "display: none;"
            }, this.Gu),
            this.ju = ph(rh(), p.chipWaves.map((t => t.name))),
            this.Uu = ph(rh(), p.chipNoises.map((t => t.name))),
            this.Ku = ah({
                type: "checkbox",
                style: "width: 1em; padding: 0; margin-left: 0.4em; margin-right: 4em;"
            }),
            this.Ju = ph(rh(), ["Loop", "Ping-Pong", "Play Once", "Play Loop Once"]),
            this.Yu = ah({
                type: "number",
                min: "0",
                step: "1",
                value: "0",
                style: "width: 100%; height: 1.5em; font-size: 80%; margin-left: 0.4em; vertical-align: middle;"
            }),
            this.Qu = ah({
                type: "number",
                min: "0",
                step: "1",
                value: "0",
                style: "width: 100%; height: 1.5em; font-size: 80%; margin-left: 0.4em; vertical-align: middle;"
            }),
            this.Zu = sh({
                type: "button",
                style: "width: 1.5em; height: 1.5em; padding: 0; margin-left: 0.5em;"
            }, Y.svg({
                width: "16",
                height: "16",
                viewBox: "-13 -14 26 26",
                "pointer-events": "none",
                style: "width: 100%; height: 100%;"
            }, Y.rect({
                x: "4",
                y: "-6",
                width: "2",
                height: "12",
                fill: nt.primaryText
            }), Y.path({
                d: "M -6 -6 L -6 6 L 3 0 z",
                fill: nt.primaryText
            }))),
            this.Xu = ah({
                type: "number",
                min: "0",
                step: "1",
                value: "0",
                style: "width: 100%; height: 1.5em; font-size: 80%; margin-left: 0.4em; vertical-align: middle;"
            }),
            this.tf = ah({
                type: "checkbox",
                style: "width: 1em; padding: 0; margin-left: 0.4em; margin-right: 4em;"
            }),
            this.ef = oh({
                class: "selectRow"
            }, hh({
                class: "tip",
                onclick: () => this.bu("chipWave")
            }, "Wave: "), oh({
                class: "selectContainer"
            }, this.ju)),
            this.if = oh({
                class: "selectRow"
            }, hh({
                class: "tip",
                onclick: () => this.bu("chipNoise")
            }, "Noise: "), oh({
                class: "selectContainer"
            }, this.Uu)),
            this.nf = sh({
                style: "margin-left: 0em; padding-left: 0.2em; height: 1.5em; max-width: 12px;",
                onclick: () => this.bu("visualLoopControls")
            }, "+"),
            this.sf = oh({
                class: "selectRow"
            }, hh({
                class: "tip",
                style: "flex-shrink: 0;",
                onclick: () => this.bu("loopControls")
            }, "Loop Controls: "), this.Ku),
            this.af = oh({
                class: "selectRow"
            }, hh({
                class: "tip",
                style: "font-size: x-small;",
                onclick: () => this.bu("loopMode")
            }, "Loop Mode: "), oh({
                class: "selectContainer"
            }, this.Ju)),
            this.rf = oh({
                class: "selectRow"
            }, hh({
                class: "tip",
                style: "font-size: x-small;",
                onclick: () => this.bu("loopStart")
            }, "Loop Start: "), this.nf, hh({
                style: "display: flex;"
            }, this.Yu)),
            this.hf = oh({
                class: "selectRow"
            }, hh({
                class: "tip",
                style: "font-size: x-small;",
                onclick: () => this.bu("loopEnd")
            }, "Loop End: "), hh({
                style: "display: flex;"
            }, this.Qu, this.Zu)),
            this.lf = oh({
                class: "selectRow"
            }, hh({
                class: "tip",
                onclick: () => this.bu("offset")
            }, "Offset: "), hh({
                style: "display: flex;"
            }, this.Xu)),
            this.cf = oh({
                class: "selectRow"
            }, hh({
                class: "tip",
                onclick: () => this.bu("backwards")
            }, "Backwards: "), this.tf),
            this.df = new Po(this.m),
            this.pf = oh({
                class: "selectRow"
            }, hh({
                class: "tip",
                onclick: () => this.bu("fadeInOut")
            }, "Fade:"), this.df.container),
            this.mf = ph(rh(), p.transitions.map((t => t.name))),
            this.uf = sh({
                style: "margin-left:0em; height:1.5em; width: 10px; padding: 0px; font-size: 8px;",
                onclick: () => this.$u(3)
            }, "▼"),
            this.ff = oh({
                class: "selectRow"
            }, hh({
                class: "tip",
                onclick: () => this.bu("transition")
            }, "Transition:"), this.uf, oh({
                class: "selectContainer",
                style: "width: 52.5%;"
            }, this.mf)),
            this.yf = ah({
                type: "checkbox",
                style: "width: 1em; padding: 0; margin-right: 4em;"
            }),
            this.bf = oh({
                class: "selectRow dropFader"
            }, hh({
                class: "tip",
                style: "margin-left:4px;",
                onclick: () => this.bu("clicklessTransition")
            }, "‣ Clickless:"), this.yf),
            this.gf = oh({
                class: "editor-controls",
                style: "display: none;"
            }, this.bf),
            this.wf = rh(ch({
                selected: !0,
                disabled: !0,
                hidden: !1
            })),
            this.vf = sh({
                style: "font-size: x-small; width: 50%; height: 40%",
                class: "no-underline",
                onclick: () => this.xf(!0)
            }, "simple"),
            this.kf = sh({
                style: "font-size: x-small; width: 50%; height: 40%",
                class: "last-button no-underline",
                onclick: () => this.xf(!1)
            }, "advanced"),
            this.Mf = oh({
                class: "selectRow",
                style: "padding-top: 4px; margin-bottom: 0px;"
            }, hh({
                style: "font-size: x-small;",
                class: "tip",
                onclick: () => this.bu("filterType")
            }, "EQ Filt.Type:"), oh({
                class: "instrument-bar"
            }, this.vf, this.kf)),
            this.Sf = new fs(this.m),
            this.Ff = sh({
                style: "margin-left:0em; padding-left:0.2em; height:1.5em; max-width: 12px;",
                onclick: () => this.bu("customEQFilterSettings")
            }, "+"),
            this.Cf = oh({
                class: "selectRow"
            }, hh({
                class: "tip",
                onclick: () => this.bu("eqFilter")
            }, "EQ Filt:"), this.Ff, this.Sf.container),
            this.Af = new lo(ah({
                style: "margin: 0;",
                type: "range",
                min: "0",
                max: p.filterSimpleCutRange - 1,
                value: "6",
                step: "1"
            }),this.m,( (t, e) => new mi(this.m,t,e)),!1),
            this.Ef = oh({
                class: "selectRow",
                title: "Low-pass Filter Cutoff Frequency"
            }, hh({
                class: "tip",
                onclick: () => this.bu("filterCutoff")
            }, "Filter Cut:"), this.Af.container),
            this.Tf = new lo(ah({
                style: "margin: 0;",
                type: "range",
                min: "0",
                max: p.filterSimplePeakRange - 1,
                value: "6",
                step: "1"
            }),this.m,( (t, e) => new ui(this.m,t,e)),!1),
            this.Pf = oh({
                class: "selectRow",
                title: "Low-pass Filter Peak Resonance"
            }, hh({
                class: "tip",
                onclick: () => this.bu("filterResonance")
            }, "Filter Peak:"), this.Tf.container),
            this.Bf = sh({
                style: "font-size: x-small; width: 50%; height: 40%",
                class: "no-underline",
                onclick: () => this.If(!0)
            }, "simple"),
            this.Lf = sh({
                style: "font-size: x-small; width: 50%; height: 40%",
                class: "last-button no-underline",
                onclick: () => this.If(!1)
            }, "advanced"),
            this.Df = oh({
                class: "selectRow",
                style: "padding-top: 4px; margin-bottom: 0px;"
            }, hh({
                style: "font-size: x-small;",
                class: "tip",
                onclick: () => this.bu("filterType")
            }, "Note Filt.Type:"), oh({
                class: "instrument-bar"
            }, this.Bf, this.Lf)),
            this.zf = new fs(this.m,!0),
            this.qf = sh({
                style: "margin-left:0em; padding-left:0.2em; height:1.5em; max-width: 12px;",
                onclick: () => this.bu("customNoteFilterSettings")
            }, "+"),
            this.Nf = oh({
                class: "selectRow"
            }, hh({
                class: "tip",
                onclick: () => this.bu("noteFilter")
            }, "Note Filt:"), this.qf, this.zf.container),
            this.Of = new lo(ah({
                style: "margin: 0;",
                type: "range",
                min: "0",
                max: p.filterSimpleCutRange - 1,
                value: "6",
                step: "1"
            }),this.m,( (t, e) => new fi(this.m,t,e)),!1),
            this.Rf = oh({
                class: "selectRow",
                title: "Low-pass Filter Cutoff Frequency"
            }, hh({
                class: "tip",
                onclick: () => this.bu("filterCutoff")
            }, "Filter Cut:"), this.Of.container),
            this.$f = new lo(ah({
                style: "margin: 0;",
                type: "range",
                min: "0",
                max: p.filterSimplePeakRange - 1,
                value: "6",
                step: "1"
            }),this.m,( (t, e) => new yi(this.m,t,e)),!1),
            this.Hf = oh({
                class: "selectRow",
                title: "Low-pass Filter Peak Resonance"
            }, hh({
                class: "tip",
                onclick: () => this.bu("filterResonance")
            }, "Filter Peak:"), this.$f.container),
            this._f = new lo(ah({
                style: "margin: 0;",
                type: "range",
                min: "0",
                max: p.supersawDynamismMax,
                value: "0",
                step: "1"
            }),this.m,( (t, e) => new ei(this.m,t,e)),!1),
            this.Vf = oh({
                class: "selectRow"
            }, hh({
                class: "tip",
                onclick: () => this.bu("supersawDynamism")
            }, "Dynamism:"), this._f.container),
            this.Gf = new lo(ah({
                style: "margin: 0;",
                type: "range",
                min: "0",
                max: p.supersawSpreadMax,
                value: "0",
                step: "1"
            }),this.m,( (t, e) => new ii(this.m,t,e)),!1),
            this.Wf = oh({
                class: "selectRow"
            }, hh({
                class: "tip",
                onclick: () => this.bu("supersawSpread")
            }, "Spread:"), this.Gf.container),
            this.jf = new lo(ah({
                style: "margin: 0;",
                type: "range",
                min: "0",
                max: p.supersawShapeMax,
                value: "0",
                step: "1"
            }),this.m,( (t, e) => new ni(this.m,t,e)),!1),
            this.Uf = oh({
                class: "selectRow"
            }, hh({
                class: "tip",
                onclick: () => this.bu("supersawShape"),
                style: "overflow: clip;"
            }, "Saw↔Pulse:"), this.jf.container),
            this.Kf = new lo(ah({
                style: "margin: 0;",
                type: "range",
                min: "1",
                max: p.pulseWidthRange,
                value: "1",
                step: "1"
            }),this.m,( (t, e) => new Xe(this.m,t,e)),!1),
            this.Jf = sh({
                style: "margin-left:53px; position: absolute; margin-top: 15px; height:1.5em; width: 10px; padding: 0px; font-size: 8px;",
                onclick: () => this.$u(5)
            }, "▼"),
            this.Yf = ah({
                style: "width: 4em; font-size: 70%;",
                id: "pwmSliderInputBox",
                type: "number",
                step: "1",
                min: "1",
                max: p.pulseWidthRange,
                value: "1"
            }),
            this.Qf = oh({
                class: "selectRow"
            }, oh({}, hh({
                class: "tip",
                tabindex: "0",
                style: "height:1em; font-size: smaller; white-space: nowrap;",
                onclick: () => this.bu("pulseWidth")
            }, "Pulse Width:"), oh({
                style: `color: ${nt.secondaryText}; margin-top: -3px;`
            }, this.Yf)), this.Jf, this.Kf.container),
            this.Zf = new lo(ah({
                style: "margin: 0;",
                type: "range",
                min: "0",
                max: "99",
                value: "0",
                step: "1"
            }),this.m,( (t, e) => new ti(this.m,t,99 - e)),!1),
            this.Xf = oh({
                class: "selectRow dropFader"
            }, hh({
                class: "tip",
                style: "margin-left:10px;",
                onclick: () => this.bu("decimalOffset")
            }, "‣ Offset:"), this.Zf.container),
            this.ty = oh({
                class: "editor-controls",
                style: "display: none;"
            }, this.Xf),
            this.ey = new lo(ah({
                style: "margin: 0;",
                type: "range",
                min: "0",
                max: p.pitchShiftRange - 1,
                value: "0",
                step: "1"
            }),this.m,( (t, e) => new si(this.m,t,e)),!0),
            this.iy = [oh({
                class: "pitchShiftMarker",
                style: {
                    color: nt.tonic
                }
            }), oh({
                class: "pitchShiftMarker",
                style: {
                    color: nt.tonic,
                    left: "50%"
                }
            }), oh({
                class: "pitchShiftMarker",
                style: {
                    color: nt.tonic,
                    left: "100%"
                }
            })],
            this.ny = [oh({
                class: "pitchShiftMarker",
                style: {
                    color: nt.fifthNote,
                    left: 700 / 24 + "%"
                }
            }), oh({
                class: "pitchShiftMarker",
                style: {
                    color: nt.fifthNote,
                    left: 1900 / 24 + "%"
                }
            })],
            this.sy = oh({
                style: "display: flex; position: relative;"
            }, this.ey.container, oh({
                class: "pitchShiftMarkerContainer"
            }, this.iy, this.ny)),
            this.oy = oh({
                class: "selectRow"
            }, hh({
                class: "tip",
                onclick: () => this.bu("pitchShift")
            }, "Pitch Shift:"), this.sy),
            this.hy = new lo(ah({
                style: "margin: 0;",
                type: "range",
                min: p.detuneMin - p.detuneCenter,
                max: p.detuneMax - p.detuneCenter,
                value: 0,
                step: "4"
            }),this.m,( (t, e) => new oi(this.m,t,e)),!0),
            this.ly = ah({
                style: "width: 4em; font-size: 80%; ",
                id: "detuneSliderInputBox",
                type: "number",
                step: "1",
                min: p.detuneMin - p.detuneCenter,
                max: p.detuneMax - p.detuneCenter,
                value: 0
            }),
            this.py = oh({
                class: "selectRow"
            }, oh({}, hh({
                class: "tip",
                style: "height:1em; font-size: smaller;",
                onclick: () => this.bu("detune")
            }, "Detune: "), oh({
                style: `color: ${nt.secondaryText}; margin-top: -3px;`
            }, this.ly)), this.hy.container),
            this.my = new lo(ah({
                style: "margin: 0; position: sticky;",
                type: "range",
                min: "0",
                max: p.distortionRange - 1,
                value: "0",
                step: "1"
            }),this.m,( (t, e) => new ai(this.m,t,e)),!1),
            this.uy = oh({
                class: "selectRow"
            }, hh({
                class: "tip",
                onclick: () => this.bu("distortion")
            }, "Distortion:"), this.my.container),
            this.yy = ah({
                type: "checkbox",
                style: "width: 1em; padding: 0; margin-right: 4em;"
            }),
            this.by = oh({
                class: "selectRow"
            }, hh({
                class: "tip",
                style: "margin-left:10px;",
                onclick: () => this.bu("aliases")
            }, "Aliasing:"), this.yy),
            this.gy = new lo(ah({
                style: "margin: 0;",
                type: "range",
                min: "0",
                max: p.bitcrusherQuantizationRange - 1,
                value: "0",
                step: "1"
            }),this.m,( (t, e) => new hi(this.m,t,e)),!1),
            this.wy = oh({
                class: "selectRow"
            }, hh({
                class: "tip",
                onclick: () => this.bu("bitcrusherQuantization")
            }, "Bit Crush:"), this.gy.container),
            this.vy = new lo(ah({
                style: "margin: 0;",
                type: "range",
                min: "0",
                max: p.bitcrusherFreqRange - 1,
                value: "0",
                step: "1"
            }),this.m,( (t, e) => new ri(this.m,t,e)),!1),
            this.xy = oh({
                class: "selectRow"
            }, hh({
                class: "tip",
                onclick: () => this.bu("bitcrusherFreq")
            }, "Freq Crush:"), this.vy.container),
            this.ky = new lo(ah({
                style: "margin: 0;",
                type: "range",
                min: "0",
                max: p.stringSustainRange - 1,
                value: "0",
                step: "1"
            }),this.m,( (t, e) => new li(this.m,t,e)),!1),
            this.My = hh({
                class: "tip",
                onclick: () => this.bu("stringSustain")
            }, "Sustain:"),
            this.Sy = oh({
                class: "selectRow"
            }, this.My, this.ky.container),
            this.Fy = sh({
                style: "margin-left:0em; height:1.5em; width: 10px; padding: 0px; font-size: 8px;",
                onclick: () => this.$u(6)
            }, "▼"),
            this.Cy = ph(rh(), p.unisons.map((t => t.name))),
            this.Ay = oh({
                class: "selectRow"
            }, hh({
                class: "tip",
                onclick: () => this.bu("unison")
            }, "Unison:"), this.Fy, oh({
                class: "selectContainer",
                style: "width: 61.5%;"
            }, this.Cy)),
            this.Ey = ah({
                style: "width: 150%; height: 1.5em; font-size: 80%; margin-left: 0.4em; vertical-align: middle;",
                id: "unisonVoicesInputBox",
                type: "number",
                step: "1",
                min: p.unisonVoicesMin,
                max: p.unisonVoicesMax,
                value: 1
            }),
            this.Ty = oh({
                class: "selectRow dropFader"
            }, oh({}, hh({
                class: "tip",
                style: "height:1em; font-size: smaller;",
                onclick: () => this.bu("unisonVoices")
            }, "‣ Voices: "), oh({
                style: "color: " + nt.secondaryText + "; margin-top: -3px;"
            }, this.Ey))),
            this.Py = ah({
                style: "width: 150%; height: 1.5em; font-size: 80%; margin-left: 0.4em; vertical-align: middle;",
                id: "unisonSpreadInputBox",
                type: "number",
                step: "0.001",
                min: p.unisonSpreadMin,
                max: p.unisonSpreadMax,
                value: 0
            }),
            this.By = oh({
                class: "selectRow dropFader"
            }, oh({}, hh({
                class: "tip",
                style: "height:1em; font-size: smaller;",
                onclick: () => this.bu("unisonSpread")
            }, "‣ Spread: "), oh({
                style: "color: " + nt.secondaryText + "; margin-top: -3px;"
            }, this.Py))),
            this.Iy = ah({
                style: "width: 150%; height: 1.5em; font-size: 80%; margin-left: 0.4em; vertical-align: middle;",
                id: "unisonOffsetInputBox",
                type: "number",
                step: "0.001",
                min: p.unisonOffsetMin,
                max: p.unisonOffsetMax,
                value: 0
            }),
            this.Ly = oh({
                class: "selectRow dropFader"
            }, oh({}, hh({
                class: "tip",
                style: "height:1em; font-size: smaller;",
                onclick: () => this.bu("unisonOffset")
            }, "‣ Offset: "), oh({
                style: "color: " + nt.secondaryText + "; margin-top: -3px;"
            }, this.Iy))),
            this.Dy = ah({
                style: "width: 150%; height: 1.5em; font-size: 80%; margin-left: 0.4em; vertical-align: middle;",
                id: "unisonExpressionInputBox",
                type: "number",
                step: "0.001",
                min: p.unisonExpressionMin,
                max: p.unisonExpressionMax,
                value: 1.4
            }),
            this.zy = oh({
                class: "selectRow dropFader"
            }, oh({}, hh({
                class: "tip",
                style: "height:1em; font-size: smaller;",
                onclick: () => this.bu("unisonExpression")
            }, "‣ Volume: "), oh({
                style: "color: " + nt.secondaryText + "; margin-top: -3px;"
            }, this.Dy))),
            this.qy = ah({
                style: "width: 150%; height: 1.5em; font-size: 80%; margin-left: 0.4em; vertical-align: middle;",
                id: "unisonSignInputBox",
                type: "number",
                step: "0.001",
                min: p.unisonSignMin,
                max: p.unisonSignMax,
                value: 1
            }),
            this.Ny = oh({
                class: "selectRow dropFader"
            }, oh({}, hh({
                class: "tip",
                style: "height:1em; font-size: smaller;",
                onclick: () => this.bu("unisonSign")
            }, "‣ Sign: "), oh({
                style: "color: " + nt.secondaryText + "; margin-top: -3px;"
            }, this.qy))),
            this.Oy = oh({
                class: "editor-controls",
                style: "display: none; gap: 3px; margin-bottom: 0.5em;"
            }, this.Ty, this.By, this.Ly, this.zy, this.Ny),
            this.Ry = ph(rh(), p.chords.map((t => t.name))),
            this.$y = sh({
                style: "margin-left:0em; height:1.5em; width: 10px; padding: 0px; font-size: 8px;",
                onclick: () => this.$u(2)
            }, "▼"),
            this.Hy = oh({
                class: "selectRow"
            }, hh({
                class: "tip",
                onclick: () => this.bu("chords")
            }, "Chords:"), this.$y, oh({
                class: "selectContainer"
            }, this.Ry)),
            this._y = hh({
                style: `color: ${nt.secondaryText}; font-size: smaller; text-overflow: clip;`
            }, "x1"),
            this.Vy = new lo(ah({
                style: "margin: 0;",
                type: "range",
                min: "0",
                max: p.modulators.dictionary["arp speed"].maxRawVol,
                value: "0",
                step: "1"
            }),this.m,( (t, e) => new Ge(this.m,t,e)),!1),
            this.Gy = oh({
                class: "selectRow dropFader"
            }, hh({
                class: "tip",
                style: "margin-left:4px;",
                onclick: () => this.bu("arpeggioSpeed")
            }, "‣ Spd:"), this._y, this.Vy.container),
            this.Wy = ah({
                type: "checkbox",
                style: "width: 1em; padding: 0; margin-right: 4em;"
            }),
            this.jy = oh({
                class: "selectRow dropFader"
            }, hh({
                class: "tip",
                style: "margin-left:4px;",
                onclick: () => this.bu("twoNoteArpeggio")
            }, "‣ Fast Two-Note:"), this.Wy),
            this.Uy = oh({
                class: "editor-controls",
                style: "display: none;"
            }, this.Gy, this.jy),
            this.Ky = ph(rh(), p.vibratos.map((t => t.name))),
            this.Jy = sh({
                style: "margin-left:0em; height:1.5em; width: 10px; padding: 0px; font-size: 8px;",
                onclick: () => this.$u(0)
            }, "▼"),
            this.Yy = oh({
                class: "selectRow"
            }, hh({
                class: "tip",
                onclick: () => this.bu("vibrato")
            }, "Vibrato:"), this.Jy, oh({
                class: "selectContainer",
                style: "width: 61.5%;"
            }, this.Ky)),
            this.Qy = new lo(ah({
                style: "margin: 0;",
                type: "range",
                min: "0",
                max: p.modulators.dictionary["vibrato depth"].maxRawVol,
                value: "0",
                step: "1"
            }),this.m,( (t, e) => new Re(this.m,t,e)),!1),
            this.Zy = oh({
                class: "selectRow dropFader"
            }, hh({
                class: "tip",
                style: "margin-left:4px;",
                onclick: () => this.bu("vibratoDepth")
            }, "‣ Depth:"), this.Qy.container),
            this.Xy = hh({
                style: `color: ${nt.secondaryText}; font-size: smaller; text-overflow: clip;`
            }, "x1"),
            this.tb = new lo(ah({
                style: "margin: 0; text-overflow: clip;",
                type: "range",
                min: "0",
                max: p.modulators.dictionary["vibrato speed"].maxRawVol,
                value: "0",
                step: "1"
            }),this.m,( (t, e) => new He(this.m,t,e)),!1),
            this.eb = oh({
                class: "selectRow dropFader"
            }, hh({
                class: "tip",
                style: "margin-left:4px;",
                onclick: () => this.bu("vibratoSpeed")
            }, "‣ Spd:"), this.Xy, this.tb.container),
            this.ib = new lo(ah({
                style: "margin: 0;",
                type: "range",
                min: "0",
                max: p.modulators.dictionary["vibrato delay"].maxRawVol,
                value: "0",
                step: "1"
            }),this.m,( (t, e) => new _e(this.m,t,e)),!1),
            this.nb = oh({
                class: "selectRow dropFader"
            }, hh({
                class: "tip",
                style: "margin-left:4px;",
                onclick: () => this.bu("vibratoDelay")
            }, "‣ Delay:"), this.ib.container),
            this.sb = ph(rh(), p.vibratoTypes.map((t => t.name))),
            this.ob = oh({
                class: "selectRow dropFader"
            }, hh({
                class: "tip",
                style: "margin-left:4px;",
                onclick: () => this.bu("vibratoType")
            }, "‣ Type:"), oh({
                class: "selectContainer",
                style: "width: 61.5%;"
            }, this.sb)),
            this.ab = oh({
                class: "editor-controls",
                style: "display: none;"
            }, this.Zy, this.eb, this.nb, this.ob),
            this.rb = oh({
                class: "editor-controls"
            }),
            this.hb = ph(rh(), p.feedbacks.map((t => t.name))),
            this.lb = oh({
                class: "selectRow"
            }, hh({
                class: "tip",
                onclick: () => this.bu("feedbackType")
            }, "Feedback:"), oh({
                class: "selectContainer"
            }, this.hb)),
            this.cb = new Ya(this.m,null),
            this.pb = sh({
                style: "margin-left:0em; padding-left:0.2em; height:1.5em; max-width: 12px;",
                onclick: () => this.bu("spectrumSettings")
            }, "+"),
            this.mb = oh({
                class: "selectRow"
            }, hh({
                class: "tip",
                onclick: () => this.bu("spectrum"),
                style: "font-size: smaller"
            }, "Spectrum:"), this.pb, this.cb.container),
            this.ub = new oo(this.m),
            this.fb = sh({
                style: "padding-left:0.2em; height:1.5em; max-width: 12px;",
                onclick: () => this.bu("harmonicsSettings")
            }, "+"),
            this.yb = oh({
                class: "selectRow"
            }, hh({
                class: "tip",
                onclick: () => this.bu("harmonics"),
                style: "font-size: smaller"
            }, "Harmonics:"), this.fb, this.ub.container),
            this.bb = new To(this.m),
            this.gb = ah({
                type: "checkbox",
                style: "width: 1em; padding: 0; margin-right: 4em;"
            }),
            this.wb = oh({
                class: "selectRow dropFader"
            }, hh({
                class: "tip",
                style: "margin-left:4px;",
                onclick: () => this.bu("discreteEnvelope")
            }, "‣ Discrete:"), this.gb),
            this.vb = hh({
                style: `color: ${nt.secondaryText}; font-size: smaller; text-overflow: clip;`
            }, "x1"),
            this.xb = new lo(ah({
                style: "margin: 0;",
                type: "range",
                min: "0",
                max: p.modulators.dictionary["envelope speed"].maxRawVol,
                value: "0",
                step: "1"
            }),this.m,( (t, e) => new $e(this.m,t,e)),!1),
            this.kb = oh({
                class: "selectRow dropFader"
            }, hh({
                class: "tip",
                style: "margin-left:4px;",
                onclick: () => this.bu("envelopeSpeed")
            }, "‣ Spd:"), this.vb, this.xb.container),
            this.Mb = oh({
                class: "editor-controls",
                style: "display: none;"
            }, this.wb, this.kb),
            this.Sb = sh({
                style: "margin-left:0em; margin-right: 1em; height:1.5em; width: 10px; padding: 0px; font-size: 8px;",
                onclick: () => this.$u(7)
            }, "▼"),
            this.Fb = oh({
                class: "editor-controls"
            }),
            this.Cb = sh({
                style: "margin-left:0em; padding-left:0.3em; margin-right:0.5em; height:1.5em; max-width: 16px;",
                onclick: () => this.bu("drumsetSettings")
            }, "+"),
            this.Ab = oh({
                class: "editor-controls"
            }),
            this.Eb = ph(rh(), p.feedbacks6Op.map((t => t.name))),
            this.Tb = oh({
                class: "selectRow"
            }, hh({
                class: "tip",
                onclick: () => this.bu("feedbackType")
            }, "Feedback:"), oh({
                class: "selectContainer"
            }, this.Eb)),
            this.Pb = sh({
                style: "margin-left:0em; height:1.5em; width: 10px; padding: 0px; font-size: 8px;",
                onclick: t => this.Bb(t)
            }, "A"),
            this.Ib = new yh(dh({
                width: 144,
                height: 144,
                style: "border:2px solid " + nt.uiWidgetBackground,
                id: "customAlgorithmCanvas"
            }),this.m,( (t, e, i) => new fe(this.m,t,e,i))),
            this.Lb = ph(rh(), p.algorithms6Op.map((t => t.name))),
            this.Db = oh(oh({
                class: "selectRow"
            }, hh({
                class: "tip",
                onclick: () => this.bu("algorithm")
            }, "Algorithm: "), oh({
                class: "selectContainer"
            }, this.Lb)), oh({
                style: "height:144px; display:flex; flex-direction: row; align-items:center; justify-content:center;"
            }, oh({
                style: "display:block; width:10px; margin-right: 0.2em"
            }, this.Pb), oh({
                style: "width:144px; height:144px;"
            }, this.Ib.canvas))),
            this.zb = sh({
                style: "max-width:86px; width: 86px;",
                class: "copyButton",
                title: "Copy Instrument (⇧C)"
            }, ["Copy", Y.svg({
                style: "flex-shrink: 0; position: absolute; left: 0; top: 50%; margin-top: -1em; pointer-events: none;",
                width: "2em",
                height: "2em",
                viewBox: "-5 -21 26 26"
            }, [Y.path({
                d: "M 0 -15 L 1 -15 L 1 0 L 13 0 L 13 1 L 0 1 L 0 -15 z M 2 -1 L 2 -17 L 10 -17 L 14 -13 L 14 -1 z M 3 -2 L 13 -2 L 13 -12 L 9 -12 L 9 -16 L 3 -16 z",
                fill: "currentColor"
            })])]),
            this.qb = sh({
                style: "max-width:86px;",
                class: "pasteButton",
                title: "Paste Instrument (⇧V)"
            }, ["Paste", Y.svg({
                style: "flex-shrink: 0; position: absolute; left: 0; top: 50%; margin-top: -1em; pointer-events: none;",
                width: "2em",
                height: "2em",
                viewBox: "0 0 26 26"
            }, [Y.path({
                d: "M 8 18 L 6 18 L 6 5 L 17 5 L 17 7 M 9 8 L 16 8 L 20 12 L 20 22 L 9 22 z",
                stroke: "currentColor",
                fill: "none"
            }), Y.path({
                d: "M 9 3 L 14 3 L 14 6 L 9 6 L 9 3 z M 16 8 L 20 12 L 16 12 L 16 8 z",
                fill: "currentColor"
            })])]),
            this.Nb = sh({
                style: "max-width:86px; width: 86px;",
                class: "exportInstrumentButton"
            }, ["Export", Y.svg({
                style: "flex-shrink: 0; position: absolute; left: 0; top: 50%; margin-top: -1em; pointer-events: none;",
                width: "2em",
                height: "2em",
                viewBox: "0 -960 960 960"
            }, [Y.path({
                d: "M200-120v-40h560v40H200Zm279.231-150.769L254.615-568.462h130.769V-840h188.462v271.538h130.77L479.231-270.769Zm0-65.385 142.923-191.538h-88.308V-800H425.385v272.308h-88.308l142.154 191.538ZM480-527.692Z",
                fill: "currentColor"
            })])]),
            this.Ob = sh({
                style: "max-width:86px;",
                class: "importInstrumentButton"
            }, ["Import", Y.svg({
                style: "flex-shrink: 0; position: absolute; left: 0; top: 50%; margin-top: -1em; pointer-events: none;",
                width: "2em",
                height: "2em",
                viewBox: "0 -960 960 960"
            }, [Y.path({
                d: "M200-120v-40h560v40H200Zm185.384-150.769v-271.539H254.615L480-840l224.616 297.692h-130.77v271.539H385.384Zm40.001-40h108.461v-272.308h88.308L480-774.615 337.077-583.077h88.308v272.308ZM480-583.077Z",
                fill: "currentColor"
            })])]),
            this.Rb = new vr(dh({
                width: 144,
                height: 32,
                style: `border: 2px solid ${nt.uiWidgetBackground}; position: static;`,
                id: "oscilloscopeAll"
            }),1),
            this.$b = oh({
                style: "height: 38px; margin-left: auto; margin-right: auto;"
            }, this.Rb.canvas),
            this.Hb = new fh(dh({
                width: 128,
                height: 52,
                style: "border:2px solid " + nt.uiWidgetBackground,
                id: "customWaveDrawCanvas"
            }),this.m,(t => new ue(this.m,t))),
            this._b = function(t, e, i) {
                e.appendChild(ch({
                    selected: !0,
                    disabled: !0,
                    value: t
                }, t));
                for (const t of i)
                    e.appendChild(ch({
                        value: t
                    }, t));
                return e
            }("Load Preset", rh({
                style: "width: 50%; height:1.5em; text-align: center; text-align-last: center;"
            }), p.chipWaves.map((t => t.name))),
            this.Vb = sh({
                style: "margin-left:0.5em; height:1.5em; max-width: 20px;",
                onclick: () => this.bu("customChipSettings")
            }, "+"),
            this.Gb = oh({
                style: "height:80px; margin-top:10px; margin-bottom:5px"
            }, [oh({
                style: "height:54px; display:flex; justify-content:center;"
            }, [this.Hb.canvas]), oh({
                style: "margin-top:5px; display:flex; justify-content:center;"
            }, [this._b, this.Vb])]),
            this.Wb = new ho(ah({
                style: "font-weight:bold; border:none; width: 98%; background-color:${ColorConfig.editorBackground}; color:${ColorConfig.primaryText}; text-align:center",
                maxlength: "30",
                type: "text",
                value: N.versionDisplayName
            }),this.m,( (t, e) => new Bn(this.m,t,e))),
            this.jb = new lo(ah({
                type: "range",
                min: "0",
                max: p.operatorAmplitudeMax,
                value: "0",
                step: "1",
                title: "Feedback Amplitude"
            }),this.m,( (t, e) => new Pi(this.m,t,e)),!1),
            this.Ub = oh({
                class: "selectRow"
            }, hh({
                class: "tip",
                onclick: () => this.bu("feedbackVolume")
            }, "Fdback Vol:"), this.jb.container),
            this.Kb = sh({
                type: "button",
                class: "add-envelope"
            }),
            this.Jb = oh({
                class: "editor-controls"
            }, this._u, this.Wu, this.ef, this.if, this.sf, this.af, this.rf, this.hf, this.lf, this.cf, this.Gb, this.Mf, this.Cf, this.Ef, this.Pf, this.pf, this.Eu, this.Db, this.rb, this.lb, this.Tb, this.Ub, this.mb, this.yb, this.Fb, this.Vf, this.Wf, this.Uf, this.Qf, this.ty, this.Sy, this.Ay, this.Oy, oh({
                style: "padding: 2px 0; margin-left: 2em; display: flex; align-items: center;"
            }, hh({
                style: "flex-grow: 1; text-align: center;"
            }, hh({
                class: "tip",
                onclick: () => this.bu("effects")
            }, "Effects")), oh({
                class: "effects-menu"
            }, this.wf)), this.ff, this.gf, this.Hy, this.Uy, this.oy, this.py, this.Yy, this.ab, this.Df, this.Nf, this.Rf, this.Hf, this.uy, this.by, this.wy, this.xy, this.yu, this.xu, this.Mu, this.wu, oh({
                style: "padding: 2px 0; margin-left: 2em; display: flex; align-items: center;"
            }, hh({
                style: "flex-grow: 1; text-align: center;"
            }, hh({
                class: "tip",
                onclick: () => this.bu("envelopes")
            }, "Envelopes")), this.Sb, this.Kb), this.Mb, this.bb.container),
            this.Yb = oh({
                class: "editor-controls"
            }, oh({
                class: "selectRow"
            }, this.zb, this.qb)),
            this.Qb = oh({
                class: "editor-controls"
            }, oh({
                class: "selectRow"
            }, this.Nb, this.Ob)),
            this.Zb = oh({
                id: "instrumentSettingsText",
                style: `padding: 3px 0; max-width: 15em; text-align: center; color: ${nt.secondaryText};`
            }, "Instrument Settings"),
            this.Xb = oh({
                class: "selectRow",
                id: "typeSelectRow"
            }, hh({
                class: "tip",
                onclick: () => this.bu("instrumentType")
            }, "Type:"), oh(oh({
                class: "pitchSelect"
            }, this.Fu), oh({
                class: "drumSelect"
            }, this.Cu))),
            this.tg = oh({
                class: "editor-controls"
            }, this.Zb, this.Lu, this.Xb, this.Nu, this.Jb),
            this.eg = Y.path({
                d: "M -6 -6 H 6 V 6 H -6 V -6 M -2 -3 L -2 -3 L -1 -4 H 1 V 4 H -1 V -1.2 L -1.2 -1 H -2 V -3 z",
                fill: nt.indicatorSecondary,
                "fill-rule": "evenodd"
            }),
            this.ig = Y.path({
                d: "M -6 -0.8 H -3.8 V -6 H 0.8 V 4.4 H 2.2 V -0.8 H 6 V 0.8 H 3.8 V 6 H -0.8 V -4.4 H -2.2 V 0.8 H -6 z",
                fill: nt.indicatorSecondary
            }),
            this.ng = Y.svg({
                style: "width: 92%; height: 1.3em; flex-shrink: 0; position: absolute;",
                viewBox: "0 0 200 200"
            }, [Y.path({
                d: "M90 155 l0 -45 -45 0 c-25 0 -45 -4 -45 -10 0 -5 20 -10 45 -10 l45 0 0 -45 c0 -25 5 -45 10 -45 6 0 10 20 10 45 l0 45 45 0 c25 0 45 5 45 10 0 6 -20 10 -45 10 l -45 0 0 45 c0 25 -4 45 -10 45 -5 0 -10 -20 -10 -45z"
            }), Y.path({
                d: "M42 158 c-15 -15 -16 -38 -2 -38 6 0 10 7 10 15 0 8 7 15 15 15 8 0 15 5 15 10 0 14 -23 13 -38 -2z"
            }), Y.path({
                d: "M120 160 c0 -5 7 -10 15 -10 8 0 15 -7 15 -15 0 -8 5 -15 10 -15 14 0 13 23 -2 38 -15 15 -38 16 -38 2z"
            }), Y.path({
                d: "M32 58 c3 -23 48 -40 48 -19 0 6 -7 11 -15 11 -8 0 -15 7 -15 15 0 8 -5 15 -11 15 -6 0 -9 -10 -7 -22z"
            }), Y.path({
                d: "M150 65 c0 -8 -7 -15 -15 -15 -8 0 -15 -4 -15 -10 0 -14 23 -13 38 2 15 15 16 38 2 38 -5 0 -10 -7 -10 -15z"
            })]),
            this.sg = oh({
                class: "promptContainer",
                style: "display: none;"
            }),
            this.og = oh({
                class: "promptContainerBG",
                style: "display: none; height: 100%; width: 100%; position: fixed; z-index: 99; overflow-x: hidden; pointer-events: none;"
            }),
            this.yp = sh({
                class: "zoomInButton",
                type: "button",
                title: "Zoom In"
            }),
            this.bp = sh({
                class: "zoomOutButton",
                type: "button",
                title: "Zoom Out"
            }),
            this.ag = oh({
                style: "flex: 1; height: 100%; display: flex; overflow: hidden; justify-content: center;"
            }, this.jm.container, this.Um.container, this.Km.container),
            this.rg = oh({
                class: "pattern-area"
            }, this.Gr.container, this.ag, this.Qm.container, this.yp, this.bp),
            this.hg = oh({
                class: "trackContainer"
            }, this.Ua.container, this.Ym.container),
            this.lg = oh({
                style: "position: absolute; width: 100%; height: 100%; pointer-events: none;"
            }),
            this.cg = oh({
                class: "trackAndMuteContainer"
            }, this.Jm.container, this.hg, this.lg),
            this.nd = new ot(this.m),
            this.dg = oh({
                class: "track-area"
            }, this.cg, this.nd.container),
            this.pg = oh({
                class: "menu-area"
            }, oh({
                class: "selectContainer menu file"
            }, this.ru), oh({
                class: "selectContainer menu edit"
            }, this.hu), oh({
                class: "selectContainer menu preferences"
            }, this.lu)),
            this.mg = oh({
                style: `width: 0%; height: 100%; background-color: ${nt.indicatorPrimary};`
            }),
            this.ug = oh({
                style: `width: 80%; height: 4px; overflow: hidden; margin-left: auto; margin-right: auto; margin-top: 0.5em; cursor: pointer; background-color: ${nt.indicatorSecondary};`
            }, this.mg),
            this.fg = oh({
                style: "cursor: pointer;"
            }, oh({
                style: `margin-top: 0.5em; text-align: center; color: ${nt.secondaryText};`
            }, "Sample Loading Status"), oh({
                class: "selectRow",
                style: "height: 6px; margin-bottom: 0.5em;"
            }, this.ug)),
            this.yg = oh({
                class: "song-settings-area"
            }, oh({
                class: "editor-controls"
            }, oh({
                class: "editor-song-settings"
            }, oh({
                style: "margin: 3px 0; position: relative; text-align: center; color: ${ColorConfig.secondaryText};"
            }, oh({
                class: "tip",
                style: "flex-shrink: 0; position:absolute; left: 0; top: 0; width: 12px; height: 12px",
                onclick: () => this.bu("usedPattern")
            }, Y.svg({
                style: "flex-shrink: 0; position: absolute; left: 0; top: 0; pointer-events: none;",
                width: "12px",
                height: "12px",
                "margin-right": "0.5em",
                viewBox: "-6 -6 12 12"
            }, this.eg)), oh({
                class: "tip",
                style: "flex-shrink: 0; position: absolute; left: 14px; top: 0; width: 12px; height: 12px",
                onclick: () => this.bu("usedInstrument")
            }, Y.svg({
                style: "flex-shrink: 0; position: absolute; left: 0; top: 0; pointer-events: none;",
                width: "12px",
                height: "12px",
                "margin-right": "1em",
                viewBox: "-6 -6 12 12"
            }, this.ig)), "Song Settings", oh({
                style: "width: 100%; left: 0; top: -1px; position:absolute; overflow-x:clip;"
            }, this.ng))), oh({
                class: "selectRow"
            }, hh({
                class: "tip",
                onclick: () => this.bu("scale")
            }, "Scale: "), oh({
                class: "selectContainer"
            }, this.cu)), oh({
                class: "selectRow"
            }, hh({
                class: "tip",
                onclick: () => this.bu("key")
            }, "Key: "), oh({
                class: "selectContainer"
            }, this.du)), oh({
                class: "selectRow"
            }, hh({
                class: "tip",
                onclick: () => this.bu("key_octave")
            }, "Octave: "), this.pu), oh({
                class: "selectRow"
            }, hh({
                class: "tip",
                onclick: () => this.bu("tempo")
            }, "Tempo: "), hh({
                style: "display: flex;"
            }, this.mu.container, this.uu)), oh({
                class: "selectRow"
            }, hh({
                class: "tip",
                onclick: () => this.bu("rhythm")
            }, "Rhythm: "), oh({
                class: "selectContainer"
            }, this.Su)), this.fg)),
            this.bg = oh({
                class: "instrument-settings-area"
            }, this.tg, this.Ab),
            this.gg = oh({
                class: "settings-area noSelection"
            }, oh({
                class: "version-area"
            }, oh({
                style: `text-align: center; margin: 3px 0; color: ${nt.secondaryText};`
            }, this.Wb.input)), oh({
                class: "play-pause-area"
            }, this.au, oh({
                class: "playback-bar-controls"
            }, this.ci, this.Zm, this.Xm, this.tu, this.eu, this.iu), oh({
                class: "playback-volume-controls"
            }, hh({
                class: "volume-speaker"
            }), this.nu.container), this.$b), this.pg, this.yg, this.bg),
            this.mainLayer = oh({
                class: "beepboxEditor",
                tabIndex: "0"
            }, this.rg, this.dg, this.gg, this.sg),
            this.wg = !1,
            this.vg = null,
            this.xg = -1,
            this.kg = 0,
            this.Mg = !1,
            this.Sg = !1,
            this.Fg = !1,
            this.Cg = !1,
            this.Ag = !1,
            this.Nh = !1,
            this.Eg = !1,
            this.Tg = [],
            this.Pg = [],
            this.Bg = [],
            this.Ig = [],
            this.Lg = [],
            this.Dg = [],
            this.zg = [],
            this.qg = [],
            this.Ng = [],
            this.Fc = [],
            this.Og = [],
            this.Rg = [],
            this.$g = [],
            this.Hg = [],
            this._g = !1,
            this.Vg = !1,
            this.Gg = !1,
            this.Wg = !1,
            this.jg = !1,
            this.Ug = !1,
            this.Kg = [],
            this.Jg = !1,
            this.Yg = !1,
            this.outVolumeHistoricTimer = 0,
            this.outVolumeHistoricCap = 0,
            this.lastOutVolumeCap = 0,
            this.patternUsed = !1,
            this.Qg = -1,
            this.Zg = () => {
                this.bu("sampleLoadingStatus")
            }
            ,
            this.refocusStage = () => {
                this.mainLayer.focus({
                    preventScroll: !0
                })
            }
            ,
            this.Xg = t => {
                this.m.synth.recording && t.target != this.mainLayer && t.target != this.tu && t.target != this.nu.input && this.refocusStage()
            }
            ,
            this.tw = () => {
                this.Um.editingModLabel || this.mainLayer.focus({
                    preventScroll: !0
                })
            }
            ,
            this.whenUpdated = () => {
                const t = this.m.prefs;
                this.Jm.container.style.display = t.enableChannelMuting ? "" : "none";
                const e = this.lg.getBoundingClientRect();
                this.m.trackVisibleBars = Math.floor((e.right - e.left - (t.enableChannelMuting ? 32 : 0)) / this.m.getBarWidth()),
                this.m.trackVisibleChannels = Math.floor((e.bottom - e.top - 30) / xo.patternHeight);
                for (let t = this.m.song.pitchChannelCount + this.m.song.noiseChannelCount; t < this.m.song.channels.length; t++) {
                    const e = this.m.song.channels[t];
                    for (let t = 0; t < e.instruments.length; t++)
                        this.m.synth.determineInvalidModulators(e.instruments[t])
                }
                if (this.nd.render(),
                this.Ua.render(),
                this.Jm.render(),
                this.cg.scrollLeft = this.m.barScrollPos * this.m.getBarWidth(),
                this.cg.scrollTop = this.m.channelScrollPos * xo.patternHeight,
                document.activeElement != this.Um.modDragValueLabel && this.Um.editingModLabel && this.Um.stopEditingModLabel(!1),
                this.Gr.container.style.display = t.showLetters ? "" : "none",
                this.Qm.container.style.display = t.showScrollBar ? "" : "none",
                this.nd.container.style.display = this.m.song.barCount > this.m.trackVisibleBars ? "" : "none",
                this.au.style.display = this.m.prefs.displayVolumeBar ? "" : "none",
                this.$b.style.display = this.m.prefs.showOscilloscope ? "" : "none",
                this.m.synth.oscEnabled = this.m.prefs.showOscilloscope,
                this.fg.style.display = this.m.prefs.showSampleLoadingStatus ? "" : "none",
                this.Yb.style.display = this.m.prefs.instrumentCopyPaste ? "" : "none",
                this.Qb.style.display = this.m.prefs.instrumentImportExport ? "" : "none",
                this.bg.style.scrollbarWidth = this.m.prefs.showInstrumentScrollbars ? "" : "none",
                document.getElementById("text-content") && (document.getElementById("text-content").style.display = this.m.prefs.showDescription ? "" : "none"),
                this.m.getFullScreen()) {
                    const e = 5 * (this.ag.clientHeight / this.m.getVisiblePitchCount())
                      , i = this.ag.clientWidth / (3 * this.m.song.beatsPerBar)
                      , n = this.ag.clientWidth / (this.m.song.beatsPerBar + 2)
                      , s = Math.max(i, Math.min(n, e)) * this.m.song.beatsPerBar
                      , o = document.getElementById("beepboxEditorContainer");
                    0 == this.m.prefs.showDescription ? (o.style.paddingBottom = "0",
                    o.style.borderStyle = "none") : (o.style.paddingBottom = "",
                    o.style.borderStyle = ""),
                    this.jm.container.style.width = s + "px",
                    this.Um.container.style.width = s + "px",
                    this.Km.container.style.width = s + "px",
                    this.jm.container.style.flexShrink = "0",
                    this.Um.container.style.flexShrink = "0",
                    this.Km.container.style.flexShrink = "0",
                    this.jm.container.style.display = "",
                    this.Km.container.style.display = "",
                    this.jm.render(),
                    this.Km.render(),
                    this.yp.style.display = this.m.channel < this.m.song.pitchChannelCount ? "" : "none",
                    this.bp.style.display = this.m.channel < this.m.song.pitchChannelCount ? "" : "none",
                    this.yp.style.right = t.showScrollBar ? "24px" : "4px",
                    this.bp.style.right = t.showScrollBar ? "24px" : "4px"
                } else
                    this.Um.container.style.width = "",
                    this.Um.container.style.flexShrink = "",
                    this.jm.container.style.display = "none",
                    this.Km.container.style.display = "none",
                    this.yp.style.display = "none",
                    this.bp.style.display = "none";
                this.Um.render();
                const i = nt.getComputed("--text-enabled-icon")
                  , n = nt.getComputed("--text-disabled-icon")
                  , s = nt.getComputed("--text-spacing-icon")
                  , o = ["Technical", (t.autoPlay ? i : n) + "Auto Play on Load", (t.autoFollow ? i : n) + "Auto Follow Playhead", (t.enableNotePreview ? i : n) + "Hear Added Notes", (t.notesOutsideScale ? i : n) + "Place Notes Out of Scale", (t.defaultScale == this.m.song.scale ? i : n) + "Set Current Scale as Default", (t.alwaysFineNoteVol ? i : n) + "Always Fine Note Volume", (t.enableChannelMuting ? i : n) + "Enable Channel Muting", (t.instrumentCopyPaste ? i : n) + "Enable Copy/Paste Buttons", (t.instrumentImportExport ? i : n) + "Enable Import/Export Buttons", (t.displayBrowserUrl ? i : n) + "Enable Song Data in URL", (t.closePromptByClickoff ? i : n) + "Close Prompts on Click Off", s + "Note Recording...", s + "Appearance", (t.showFifth ? i : n) + 'Highlight "Fifth" Note', (t.notesFlashWhenPlayed ? i : n) + "Notes Flash When Played", (t.instrumentButtonsAtTop ? i : n) + "Instrument Buttons at Top", (t.frostedGlassBackground ? i : n) + "Frosted Glass Prompt Backdrop", (t.showChannels ? i : n) + "Show All Channels", (t.showScrollBar ? i : n) + "Show Octave Scroll Bar", (t.showInstrumentScrollbars ? i : n) + "Show Instrument Scrollbars", (t.showLetters ? i : n) + "Show Piano Keys", (t.displayVolumeBar ? i : n) + "Show Playback Volume", (t.showOscilloscope ? i : n) + "Show Oscilloscope", (t.showSampleLoadingStatus ? i : n) + "Show Sample Loading Status", (t.showDescription ? i : n) + "Show Description", s + "Set Layout...", s + "Set Theme...", s + "Custom Theme..."]
                  , a = this.lu.children[1];
                for (let t = 0; t < a.children.length; t++) {
                    const e = a.children[t];
                    e.textContent != o[t + 1] && (e.textContent = o[t + 1])
                }
                const r = this.lu.children[2];
                for (let t = 0; t < r.children.length; t++) {
                    const e = r.children[t];
                    e.textContent != o[t + a.children.length + 2] && (e.textContent = o[t + a.children.length + 2])
                }
                const h = this.m.song.channels[this.m.channel]
                  , l = this.m.getCurrentInstrument()
                  , c = h.instruments[l]
                  , d = this.mainLayer.contains(document.activeElement)
                  , m = document.activeElement
                  , u = nt.getChannelColor(this.m.song, this.m.channel);
                for (let t = this.wf.childElementCount - 1; t < p.effectOrder.length; t++)
                    this.wf.appendChild(ch({
                        value: t
                    }));
                this.wf.selectedIndex = -1;
                for (let t = 0; t < p.effectOrder.length; t++) {
                    let e = p.effectOrder[t];
                    const s = (0 != (c.effects & 1 << e) ? i : n) + p.effectNames[e]
                      , o = this.wf.children[t + 1];
                    o.textContent != s && (o.textContent = s)
                }
                if (uh(this.cu, this.m.song.scale),
                this.cu.title = p.scales[this.m.song.scale].realName,
                uh(this.du, p.keys.length - 1 - this.m.song.key),
                this.pu.value = Math.round(this.m.song.octave).toString(),
                this.mu.updateValue(Math.max(0, Math.round(this.m.song.tempo))),
                this.uu.value = Math.round(this.m.song.tempo).toString(),
                this.Wb.updateValue(this.m.song.title),
                this.Mf.style.setProperty("--text-color-lit", u.primaryNote),
                this.Mf.style.setProperty("--text-color-dim", u.secondaryNote),
                this.Mf.style.setProperty("--background-color-lit", u.primaryChannel),
                this.Mf.style.setProperty("--background-color-dim", u.secondaryChannel),
                c.eqFilterType ? (this.vf.classList.remove("deactivated"),
                this.kf.classList.add("deactivated"),
                this.Cf.style.display = "none",
                this.Ef.style.display = "",
                this.Pf.style.display = "") : (this.vf.classList.add("deactivated"),
                this.kf.classList.remove("deactivated"),
                this.Cf.style.display = "",
                this.Ef.style.display = "none",
                this.Pf.style.display = "none"),
                uh(this.Su, this.m.song.rhythm),
                this.m.song.getChannelIsMod(this.m.channel)) {
                    this.ew(this.m.channel, l),
                    this.Fu.style.display = "none",
                    this.Cu.style.display = "none",
                    $("#pitchPresetSelect").parent().hide(),
                    $("#drumPresetSelect").parent().hide(),
                    t.instrumentButtonsAtTop ? (this.Ab.insertBefore(this.Qb, this.Ab.firstChild),
                    this.Ab.insertBefore(this.Yb, this.Ab.firstChild)) : (this.Ab.appendChild(this.Yb),
                    this.Ab.appendChild(this.Qb)),
                    this.Ab.insertBefore(this.Lu, this.Ab.firstChild),
                    this.Ab.insertBefore(this.Zb, this.Ab.firstChild),
                    "" == this.m.song.channels[this.m.channel].name ? this.Zb.textContent = "Modulator Settings" : this.Zb.textContent = this.m.song.channels[this.m.channel].name,
                    this.if.style.display = "none",
                    this.ef.style.display = "none",
                    this.sf.style.display = "none",
                    this.af.style.display = "none",
                    this.rf.style.display = "none",
                    this.hf.style.display = "none",
                    this.lf.style.display = "none",
                    this.cf.style.display = "none",
                    this.mb.style.display = "none",
                    this.yb.style.display = "none",
                    this.ff.style.display = "none",
                    this.Hy.style.display = "none",
                    this.Uy.style.display = "none",
                    this.Fb.style.display = "none",
                    this.Gb.style.display = "none",
                    this.Vf.style.display = "none",
                    this.Wf.style.display = "none",
                    this.Uf.style.display = "none",
                    this.Eu.style.display = "none",
                    this.rb.style.display = "none",
                    this.lb.style.display = "none",
                    this.Ub.style.display = "none",
                    this.Qf.style.display = "none",
                    this.Yy.style.display = "none",
                    this.ab.style.display = "none",
                    this.Mb.style.display = "none",
                    this.py.style.display = "none",
                    this._u.style.display = "none",
                    this.Wu.style.display = "none",
                    this.ty.style.display = "none",
                    this.Oy.style.display = "none",
                    this.Ab.style.display = "",
                    this.Ab.style.color = nt.getChannelColor(this.m.song, this.m.channel).primaryNote;
                    for (let t = 0; t < p.modCount; t++) {
                        let e = this.m.song.channels[this.m.channel].instruments[this.m.getCurrentInstrument()]
                          , i = Math.max(0, e.modChannels[t])
                          , n = e.modInstruments[t];
                        if ((n >= this.m.song.channels[i].instruments.length + 2 || n > 0 && this.m.song.channels[i].instruments.length <= 1) && (n = 0,
                        e.modInstruments[t] = 0),
                        i >= this.m.song.pitchChannelCount + this.m.song.noiseChannelCount && (e.modInstruments[t] = 0,
                        e.modulators[t] = 0),
                        this.m.recalcChannelNames || this.iw[t].children.length != 2 + this.m.song.pitchChannelCount + this.m.song.noiseChannelCount) {
                            for (; this.iw[t].firstChild; )
                                this.iw[t].remove(0);
                            const e = [];
                            e.push("none"),
                            e.push("song");
                            for (let t = 0; t < this.m.song.pitchChannelCount; t++)
                                "" == this.m.song.channels[t].name ? e.push("pitch " + (t + 1)) : e.push(this.m.song.channels[t].name);
                            for (let t = 0; t < this.m.song.noiseChannelCount; t++)
                                "" == this.m.song.channels[t + this.m.song.pitchChannelCount].name ? e.push("noise " + (t + 1)) : e.push(this.m.song.channels[t + this.m.song.pitchChannelCount].name);
                            ph(this.iw[t], e)
                        }
                        this.iw[t].selectedIndex = e.modChannels[t] + 2;
                        let s = this.m.song.channels[i];
                        if (this.nw[t].children.length != s.instruments.length + 2) {
                            for (; this.nw[t].firstChild; )
                                this.nw[t].remove(0);
                            const e = [];
                            for (let t = 0; t < s.instruments.length; t++)
                                e.push("" + t + 1);
                            e.push("all"),
                            e.push("active"),
                            ph(this.nw[t], e)
                        }
                        if (s.bars[this.m.bar] > 0) {
                            let e = s.patterns[s.bars[this.m.bar] - 1].instruments;
                            for (let i = 0; i < s.instruments.length; i++)
                                e.includes(i) ? this.nw[t].options[i].label = "🢒" + (i + 1) : this.nw[t].options[i].label = "" + (i + 1)
                        } else
                            for (let e = 0; e < s.instruments.length; e++)
                                this.nw[t].options[e].label = "" + (e + 1);
                        if (this.nw[t].selectedIndex = e.modInstruments[t],
                        -2 != e.modChannels[t]) {
                            for (; this.sw[t].firstChild; )
                                this.sw[t].remove(0);
                            const i = []
                              , o = [];
                            if (i.push("none"),
                            -1 == e.modChannels[t])
                                i.push("song volume"),
                                i.push("tempo"),
                                i.push("song reverb"),
                                i.push("next bar"),
                                i.push("song detune");
                            else {
                                i.push("note volume"),
                                i.push("mix volume");
                                let t = []
                                  , e = !1
                                  , a = !1
                                  , r = !1
                                  , h = !1
                                  , l = !1
                                  , c = !1
                                  , d = !1
                                  , p = !1
                                  , m = !1
                                  , u = !1
                                  , f = !1
                                  , y = !1
                                  , b = !1
                                  , g = !1
                                  , w = !1
                                  , v = !1
                                  , x = !0
                                  , k = !0
                                  , M = !0
                                  , z = !0
                                  , q = !0
                                  , N = !0
                                  , O = !0
                                  , R = !0
                                  , $ = !0
                                  , H = [];
                                if (n >= s.instruments.length)
                                    for (let t = 0; t < s.instruments.length; t++)
                                        H.push(t);
                                else
                                    H.push(n);
                                for (let i = 0; i < H.length; i++) {
                                    let n = H[i];
                                    t.includes(s.instruments[n].type) || t.push(s.instruments[n].type),
                                    s.instruments[n].eqFilterType ? a = !0 : e = !0,
                                    S(s.instruments[n].effects) && s.instruments[n].getChord().arpeggiates && (l = !0),
                                    F(s.instruments[n].effects) && (c = !0),
                                    C(s.instruments[n].effects) ? d = !0 : k = !1,
                                    A(s.instruments[n].effects) ? p = !0 : M = !1,
                                    E(s.instruments[n].effects) ? (m = !0,
                                    s.instruments[n].noteFilterType ? h = !0 : r = !0) : x = !1,
                                    T(s.instruments[n].effects) ? u = !0 : z = !1,
                                    P(s.instruments[n].effects) ? f = !0 : q = !1,
                                    B(s.instruments[n].effects) ? y = !0 : N = !1,
                                    I(s.instruments[n].effects) ? b = !0 : O = !1,
                                    L(s.instruments[n].effects) ? g = !0 : R = !1,
                                    D(s.instruments[n].effects) ? w = !0 : $ = !1,
                                    s.instruments[n].envelopes.length > 0 && (v = !0)
                                }
                                e && i.push("eq filter"),
                                a && (i.push("eq filt cut"),
                                i.push("eq filt peak")),
                                t.includes(1) && (i.push("fm slider 1"),
                                i.push("fm slider 2"),
                                i.push("fm slider 3"),
                                i.push("fm slider 4"),
                                i.push("fm feedback")),
                                t.includes(11) && (i.push("fm slider 1"),
                                i.push("fm slider 2"),
                                i.push("fm slider 3"),
                                i.push("fm slider 4"),
                                i.push("fm slider 5"),
                                i.push("fm slider 6"),
                                i.push("fm feedback")),
                                (t.includes(6) || t.includes(8)) && (i.push("pulse width"),
                                i.push("decimal offset")),
                                t.includes(8) && (i.push("dynamism"),
                                i.push("spread"),
                                i.push("saw shape")),
                                t.includes(7) && i.push("sustain"),
                                l && (i.push("arp speed"),
                                i.push("reset arp")),
                                c && i.push("pitch shift"),
                                d && i.push("detune"),
                                k || o.push("+ detune"),
                                p && (i.push("vibrato depth"),
                                i.push("vibrato speed"),
                                i.push("vibrato delay")),
                                M || (o.push("+ vibrato depth"),
                                o.push("+ vibrato speed"),
                                o.push("+ vibrato delay")),
                                m && (r && i.push("note filter"),
                                h && (i.push("note filt cut"),
                                i.push("note filt peak"))),
                                x || o.push("+ note filter"),
                                u && i.push("distortion"),
                                z || o.push("+ distortion"),
                                f && (i.push("bit crush"),
                                i.push("freq crush")),
                                q || (o.push("+ bit crush"),
                                o.push("+ freq crush")),
                                y && (i.push("pan"),
                                i.push("pan delay")),
                                N || (o.push("+ pan"),
                                o.push("+ pan delay")),
                                b && i.push("chorus"),
                                O || o.push("+ chorus"),
                                g && i.push("echo"),
                                R || o.push("+ echo"),
                                w && i.push("reverb"),
                                $ || o.push("+ reverb"),
                                v && i.push("envelope speed")
                            }
                            ph(this.sw[t], i),
                            o.length > 0 && (this.sw[t].appendChild(ch({
                                selected: !1,
                                disabled: !0,
                                value: "Add Effect"
                            }, "Add Effect")),
                            ph(this.sw[t], o));
                            let a = i.indexOf(p.modulators[e.modulators[t]].name);
                            -1 == a ? (this.sw[t].insertBefore(ch({
                                value: p.modulators[e.modulators[t]].name,
                                style: "color: red;"
                            }, p.modulators[e.modulators[t]].name), this.sw[t].children[0]),
                            this.sw[t].selectedIndex = 0,
                            this.ow(t, !0)) : (this.sw[t].selectedIndex = a,
                            this.sw[t].classList.remove("invalidSetting"),
                            e.invalidModulators[t] = !1)
                        } else
                            this.sw[t].selectedIndex > 0 && (this.sw[t].selectedIndex = 0,
                            this.ow(t));
                        e.modChannels[t] < 0 ? (this.nw[t].parentElement.style.display = "none",
                        $("#modInstrumentText" + t).get(0).style.display = "none",
                        $("#modChannelText" + t).get(0).innerText = "Channel:",
                        -2 == e.modChannels[t] ? ($("#modSettingText" + t).get(0).style.display = "none",
                        this.sw[t].parentElement.style.display = "none") : ($("#modSettingText" + t).get(0).style.display = "",
                        this.sw[t].parentElement.style.display = ""),
                        this.aw[t].style.setProperty("fill", nt.uiWidgetFocus),
                        this.aw[t].classList.remove("modTarget")) : (this.nw[t].parentElement.style.display = s.instruments.length > 1 ? "" : "none",
                        $("#modInstrumentText" + t).get(0).style.display = s.instruments.length > 1 ? "" : "none",
                        $("#modChannelText" + t).get(0).innerText = s.instruments.length > 1 ? "Ch:" : "Channel:",
                        $("#modSettingText" + t).get(0).style.display = "",
                        this.sw[t].parentElement.style.display = "",
                        this.aw[t].style.setProperty("fill", nt.indicatorPrimary),
                        this.aw[t].classList.add("modTarget"));
                        let o = p.modulators[e.modulators[t]].name;
                        if ("eq filter" == o || "note filter" == o) {
                            $("#modFilterText" + t).get(0).style.display = "",
                            $("#modSettingText" + t).get(0).style.setProperty("margin-bottom", "2px");
                            let i = e.modInstruments[t]
                              , n = this.m.song.channels[Math.max(0, e.modChannels[t])]
                              , a = -1;
                            if (i >= n.instruments.length)
                                for (let t = 0; t < n.instruments.length; t++)
                                    "eq filter" == o ? n.instruments[t].eqFilter.controlPointCount > a && (a = n.instruments[t].eqFilter.controlPointCount,
                                    i = t) : n.instruments[t].noteFilter.controlPointCount > a && (a = n.instruments[t].noteFilter.controlPointCount,
                                    i = t);
                            let r = "eq filter" == o ? s.instruments[i].getLargestControlPointCount(!1) : s.instruments[i].getLargestControlPointCount(!0);
                            const h = "eq filter" == o ? s.instruments[i].eqFilterType : s.instruments[i].noteFilterType;
                            if (h && (r = 0),
                            h || this.rw[t].children.length != 1 + 2 * r) {
                                for (; this.rw[t].firstChild; )
                                    this.rw[t].remove(0);
                                const e = [];
                                h || e.push("morph");
                                for (let t = 0; t < r; t++)
                                    e.push("dot " + (t + 1) + " x"),
                                    e.push("dot " + (t + 1) + " y");
                                ph(this.rw[t], e)
                            }
                            if (h || e.modFilterTypes[t] >= this.rw[t].length) {
                                this.rw[t].classList.add("invalidSetting"),
                                e.invalidModulators[t] = !0;
                                let i = (e.modFilterTypes[t] - 1) % 2 == 1 ? "dot " + (Math.floor((e.modFilterTypes[t] - 1) / 2) + 1) + " y" : "dot " + (Math.floor((e.modFilterTypes[t] - 1) / 2) + 1) + " x";
                                0 == e.modFilterTypes[t] && (i = "morph"),
                                this.rw[t].insertBefore(ch({
                                    value: i,
                                    style: "color: red;"
                                }, i), this.rw[t].children[0]),
                                this.rw[t].selectedIndex = 0
                            } else
                                this.rw[t].classList.remove("invalidSetting"),
                                e.invalidModulators[t] = !1,
                                this.rw[t].selectedIndex = e.modFilterTypes[t]
                        } else
                            $("#modFilterText" + t).get(0).style.display = "none",
                            $("#modSettingText" + t).get(0).style.setProperty("margin-bottom", "0.9em")
                    }
                    this.m.recalcChannelNames = !1;
                    for (let t = 0; t < p.chords.length; t++) {
                        const e = this.Ry.children[t];
                        e.hasAttribute("hidden") || e.setAttribute("hidden", "")
                    }
                    this.Jb.style.display = "none",
                    this._u.style.display = "none",
                    this.Wu.style.display = "none",
                    this.Nu.style.display = "none",
                    this.Xb.style.setProperty("display", "none"),
                    this.tg.style.color = nt.getChannelColor(this.m.song, this.m.channel).primaryNote,
                    this.m.channel >= this.m.song.pitchChannelCount + this.m.song.noiseChannelCount && this.Gr.forceRender(),
                    this.hw(h, l, u)
                } else {
                    if (this.Jb.style.display = "",
                    this._u.style.display = "",
                    this.Wu.style.display = this.Vg ? "" : "none",
                    this.py.style.display = "",
                    this.Nu.style.display = "",
                    this.Xb.style.setProperty("display", ""),
                    t.instrumentButtonsAtTop ? (this.tg.insertBefore(this.Qb, this.tg.firstChild),
                    this.tg.insertBefore(this.Yb, this.tg.firstChild)) : (this.tg.appendChild(this.Yb),
                    this.tg.appendChild(this.Qb)),
                    this.tg.insertBefore(this.Lu, this.tg.firstChild),
                    this.tg.insertBefore(this.Zb, this.tg.firstChild),
                    "" == this.m.song.channels[this.m.channel].name ? this.Zb.textContent = "Instrument Settings" : this.Zb.textContent = this.m.song.channels[this.m.channel].name,
                    this.Ab.style.display = "none",
                    this.ew(this.m.channel, l),
                    this.m.song.getChannelIsNoise(this.m.channel) ? (this.Fu.style.display = "none",
                    this.Cu.style.display = "",
                    $("#pitchPresetSelect").parent().hide(),
                    $("#drumPresetSelect").parent().show(),
                    uh(this.Cu, c.preset, !0)) : (this.Fu.style.display = "",
                    this.Cu.style.display = "none",
                    $("#pitchPresetSelect").parent().show(),
                    $("#drumPresetSelect").parent().hide(),
                    uh(this.Fu, c.preset, !0)),
                    2 == c.type ? (this.ef.style.display = "none",
                    this.sf.style.display = "none",
                    this.af.style.display = "none",
                    this.rf.style.display = "none",
                    this.hf.style.display = "none",
                    this.lf.style.display = "none",
                    this.cf.style.display = "none",
                    this.if.style.display = "",
                    uh(this.Uu, c.chipNoise, !0)) : this.if.style.display = "none",
                    3 == c.type ? (this.ef.style.display = "none",
                    this.sf.style.display = "none",
                    this.af.style.display = "none",
                    this.rf.style.display = "none",
                    this.hf.style.display = "none",
                    this.lf.style.display = "none",
                    this.cf.style.display = "none",
                    this.mb.style.display = "",
                    this.cb.render()) : this.mb.style.display = "none",
                    5 == c.type || 7 == c.type ? (this.ef.style.display = "none",
                    this.sf.style.display = "none",
                    this.af.style.display = "none",
                    this.rf.style.display = "none",
                    this.hf.style.display = "none",
                    this.lf.style.display = "none",
                    this.cf.style.display = "none",
                    this.yb.style.display = "",
                    this.ub.render()) : this.yb.style.display = "none",
                    7 == c.type ? (this.ef.style.display = "none",
                    this.sf.style.display = "none",
                    this.af.style.display = "none",
                    this.rf.style.display = "none",
                    this.hf.style.display = "none",
                    this.lf.style.display = "none",
                    this.cf.style.display = "none",
                    this.Sy.style.display = "",
                    this.ky.updateValue(c.stringSustain),
                    this.My.textContent = p.enableAcousticSustain ? "Sustain (" + p.sustainTypeNames[c.stringSustainType].substring(0, 1).toUpperCase() + "):" : "Sustain:") : this.Sy.style.display = "none",
                    4 == c.type) {
                        this.Fb.style.display = "",
                        this.ef.style.display = "none",
                        this.sf.style.display = "none",
                        this.af.style.display = "none",
                        this.rf.style.display = "none",
                        this.hf.style.display = "none",
                        this.lf.style.display = "none",
                        this.cf.style.display = "none",
                        this.pf.style.display = "none";
                        for (let t = 0; t < p.drumCount; t++)
                            uh(this.Og[t], c.drumsetEnvelopes[t]),
                            this.Fc[t].render()
                    } else
                        this.Fb.style.display = "none",
                        this.pf.style.display = "",
                        this.df.render();
                    if (0 == c.type && (this.ef.style.display = "",
                    this.sf.style.display = "",
                    c.isUsingAdvancedLoopControls ? (this.af.style.display = "",
                    this.rf.style.display = "",
                    this.hf.style.display = "",
                    this.lf.style.display = "",
                    this.cf.style.display = "") : (this.af.style.display = "none",
                    this.rf.style.display = "none",
                    this.hf.style.display = "none",
                    this.lf.style.display = "none",
                    this.cf.style.display = "none"),
                    uh(this.ju, c.chipWave),
                    this.Ku.checked = !!c.isUsingAdvancedLoopControls,
                    uh(this.Ju, c.chipWaveLoopMode),
                    this.Yu.value = c.chipWaveLoopStart + "",
                    this.Qu.value = c.chipWaveLoopEnd + "",
                    this.Xu.value = c.chipWaveStartOffset + "",
                    this.tf.checked = !!c.chipWavePlayBackwards),
                    9 == c.type ? (this.Gb.style.display = "",
                    this.ef.style.display = "none",
                    this.sf.style.display = "none",
                    this.af.style.display = "none",
                    this.rf.style.display = "none",
                    this.hf.style.display = "none",
                    this.lf.style.display = "none",
                    this.cf.style.display = "none") : this.Gb.style.display = "none",
                    8 == c.type ? (this.Vf.style.display = "",
                    this.Wf.style.display = "",
                    this.Uf.style.display = "",
                    this._f.updateValue(c.supersawDynamism),
                    this.Gf.updateValue(c.supersawSpread),
                    this.jf.updateValue(c.supersawShape)) : (this.Vf.style.display = "none",
                    this.Wf.style.display = "none",
                    this.Uf.style.display = "none"),
                    6 == c.type || 8 == c.type ? (this.ef.style.display = "none",
                    this.sf.style.display = "none",
                    this.af.style.display = "none",
                    this.rf.style.display = "none",
                    this.hf.style.display = "none",
                    this.lf.style.display = "none",
                    this.cf.style.display = "none",
                    this.Qf.style.display = "",
                    this.Kf.input.title = q(c.pulseWidth) + "%",
                    this.Kf.updateValue(c.pulseWidth),
                    this.Zf.input.title = c.decimalOffset / 100 <= 0 ? "none" : "-" + q(c.decimalOffset / 100) + "%",
                    this.Zf.updateValue(99 - c.decimalOffset),
                    this.ty.style.display = this.Jg ? "" : "none") : (this.Qf.style.display = "none",
                    this.ty.style.display = "none"),
                    1 == c.type || 11 == c.type) {
                        this.rb.style.display = "",
                        this.Ub.style.display = "",
                        this.ef.style.display = "none",
                        this.sf.style.display = "none",
                        this.af.style.display = "none",
                        this.rf.style.display = "none",
                        this.hf.style.display = "none",
                        this.lf.style.display = "none",
                        this.cf.style.display = "none",
                        uh(this.Au, c.algorithm),
                        uh(this.hb, c.feedbackType),
                        this.jb.updateValue(c.feedbackAmplitude);
                        for (let t = 0; t < p.operatorCount + (11 == c.type ? 2 : 0); t++) {
                            const e = 1 == c.type ? t < p.algorithms[c.algorithm].carrierCount : t < c.customAlgorithm.carrierCount;
                            this.Tg[t].style.color = e ? nt.primaryText : "",
                            uh(this.Bg[t], c.operators[t].frequency),
                            this.Pg[t].updateValue(c.operators[t].amplitude),
                            uh(this.Lg[t], c.operators[t].waveform),
                            this.zg[t].updateValue(c.operators[t].pulseWidth),
                            this.zg[t].input.title = "" + p.pwmOperatorWaves[c.operators[t].pulseWidth].name,
                            this.Ng[t].style.color = e ? nt.primaryText : "";
                            const i = (e ? "Voice " : "Modulator ") + (t + 1);
                            this.Bg[t].title = i + " Frequency",
                            this.Pg[t].input.title = i + (e ? " Volume" : " Amplitude"),
                            this.Ng[t].style.display = this.Kg[t] ? "" : "none",
                            2 == c.operators[t].waveform ? (this.zg[t].container.style.display = "",
                            this.Dg[t].style.display = "none") : (this.zg[t].container.style.display = "none",
                            this.Dg[t].style.display = "")
                        }
                        11 == c.type ? (uh(this.Lb, c.algorithm6Op),
                        uh(this.Eb, c.feedbackType6Op),
                        this.Ib.redrawCanvas(),
                        this.Db.style.display = "",
                        this.Tb.style.display = "",
                        this.Tg[4].style.display = "",
                        this.Tg[5].style.display = "",
                        this.Ng[4].style.display = this.Kg[4] ? "" : "none",
                        this.Ng[5].style.display = this.Kg[5] ? "" : "none",
                        this.Eu.style.display = "none",
                        this.lb.style.display = "none") : (this.Db.style.display = "none",
                        this.Tb.style.display = "none",
                        this.Tg[4].style.display = "none",
                        this.Tg[5].style.display = "none",
                        this.Ng[4].style.display = "none",
                        this.Ng[5].style.display = "none",
                        this.lb.style.display = "",
                        this.Eu.style.display = "")
                    } else
                        this.Db.style.display = "none",
                        this.Tb.style.display = "none",
                        this.Eu.style.display = "none",
                        this.rb.style.display = "none",
                        this.lb.style.display = "none",
                        this.Ub.style.display = "none";
                    if (this.Kf.input.title = q(c.pulseWidth) + "%",
                    M(c.effects) ? (this.ff.style.display = "",
                    this.Ug && (this.gf.style.display = ""),
                    uh(this.mf, c.transition)) : (this.gf.style.display = "none",
                    this.ff.style.display = "none"),
                    S(c.effects) ? (this.Hy.style.display = "",
                    this.$y.style.display = c.chord == p.chords.dictionary.arpeggio.index ? "" : "none",
                    this.Uy.style.display = c.chord == p.chords.dictionary.arpeggio.index && this.jg ? "" : "none",
                    uh(this.Ry, c.chord)) : (this.Hy.style.display = "none",
                    this.$y.style.display = "none",
                    this.Uy.style.display = "none"),
                    F(c.effects)) {
                        this.oy.style.display = "",
                        this.ey.updateValue(c.pitchShift),
                        this.ey.input.title = c.pitchShift - p.pitchShiftCenter + " semitone(s)";
                        for (const e of this.ny)
                            e.style.display = t.showFifth ? "" : "none"
                    } else
                        this.oy.style.display = "none";
                    C(c.effects) ? (this.py.style.display = "",
                    this.hy.updateValue(c.detune - p.detuneCenter),
                    this.hy.input.title = Jt.detuneToCents(c.detune) + " cent(s)") : this.py.style.display = "none",
                    A(c.effects) ? (this.Yy.style.display = "",
                    this.Gg && (this.ab.style.display = ""),
                    uh(this.Ky, c.vibrato)) : (this.ab.style.display = "none",
                    this.Yy.style.display = "none"),
                    E(c.effects) ? (this.Df.style.setProperty("--text-color-lit", u.primaryNote),
                    this.Df.style.setProperty("--text-color-dim", u.secondaryNote),
                    this.Df.style.setProperty("--background-color-lit", u.primaryChannel),
                    this.Df.style.setProperty("--background-color-dim", u.secondaryChannel),
                    this.Df.style.display = "",
                    this.m.synth.isFilterModActive(!0, this.m.channel, this.m.getCurrentInstrument()) ? this.zf.render(!0, this.Ag || this.Nh) : this.zf.render(),
                    c.noteFilterType ? (this.Bf.classList.remove("deactivated"),
                    this.Lf.classList.add("deactivated"),
                    this.Nf.style.display = "none",
                    this.Rf.style.display = "",
                    this.Hf.style.display = "") : (this.Bf.classList.add("deactivated"),
                    this.Lf.classList.remove("deactivated"),
                    this.Nf.style.display = "",
                    this.Rf.style.display = "none",
                    this.Hf.style.display = "none")) : (this.Nf.style.display = "none",
                    this.Rf.style.display = "none",
                    this.Hf.style.display = "none",
                    this.Df.style.display = "none"),
                    T(c.effects) ? (this.uy.style.display = "",
                    0 == c.type || 9 == c.type || 6 == c.type || 8 == c.type ? this.by.style.display = "" : this.by.style.display = "none",
                    this.my.updateValue(c.distortion)) : (this.uy.style.display = "none",
                    this.by.style.display = "none"),
                    P(c.effects) ? (this.wy.style.display = "",
                    this.xy.style.display = "",
                    this.gy.updateValue(c.bitcrusherQuantization),
                    this.vy.updateValue(c.bitcrusherFreq)) : (this.wy.style.display = "none",
                    this.xy.style.display = "none"),
                    B(c.effects) ? (this._u.style.display = "",
                    this.Vg && (this.Wu.style.display = ""),
                    this.Ou.updateValue(c.pan)) : (this._u.style.display = "none",
                    this.Wu.style.display = "none"),
                    I(c.effects) ? (this.yu.style.display = "",
                    this.fu.updateValue(c.chorus)) : this.yu.style.display = "none",
                    L(c.effects) ? (this.xu.style.display = "",
                    this.vu.updateValue(c.echoSustain),
                    this.Mu.style.display = "",
                    this.ku.updateValue(c.echoDelay),
                    this.ku.input.title = Math.round((c.echoDelay + 1) * p.echoDelayStepTicks / (p.ticksPerPart * p.partsPerBeat) * 1e3) / 1e3 + " beat(s)") : (this.xu.style.display = "none",
                    this.Mu.style.display = "none"),
                    D(c.effects) ? (this.wu.style.display = "",
                    this.gu.updateValue(c.reverb)) : this.wu.style.display = "none",
                    0 == c.type || 9 == c.type || 5 == c.type || 7 == c.type || 3 == c.type || 6 == c.type || 2 == c.type ? (this.Ay.style.display = "",
                    uh(this.Cy, c.unison),
                    this.Ey.value = c.unisonVoices + "",
                    this.Py.value = c.unisonSpread + "",
                    this.Iy.value = c.unisonOffset + "",
                    this.Dy.value = c.unisonExpression + "",
                    this.qy.value = c.unisonSign + "",
                    this.Oy.style.display = this.Yg ? "" : "none") : (this.Ay.style.display = "none",
                    this.Oy.style.display = "none"),
                    this.Wg ? this.Mb.style.display = "" : this.Mb.style.display = "none",
                    this.bb.render();
                    for (let t = 0; t < p.chords.length; t++) {
                        let e = !p.instrumentTypeHasSpecialInterval[c.type] && p.chords[t].customInterval;
                        const i = this.Ry.children[t];
                        e ? i.hasAttribute("hidden") || i.setAttribute("hidden", "") : i.removeAttribute("hidden")
                    }
                    this.tg.style.color = nt.getChannelColor(this.m.song, this.m.channel).primaryNote,
                    uh(this.mf, c.transition),
                    uh(this.Ky, c.vibrato),
                    uh(this.sb, c.vibratoType),
                    uh(this.Ry, c.chord),
                    this.Hu.value = c.pan + "",
                    this.Yf.value = c.pulseWidth + "",
                    this.ly.value = c.detune - p.detuneCenter + "",
                    this.Du.updateValue(c.volume),
                    this.zu.value = "" + c.volume,
                    this.Qy.updateValue(Math.round(25 * c.vibratoDepth)),
                    this.ib.updateValue(Math.round(c.vibratoDelay)),
                    this.tb.updateValue(c.vibratoSpeed),
                    uh(this.sb, c.vibratoType),
                    this.Vy.updateValue(c.arpeggioSpeed),
                    this.Vu.updateValue(c.panDelay),
                    this.ib.input.title = "" + Math.round(c.vibratoDelay),
                    this.Qy.input.title = "" + c.vibratoDepth,
                    this.tb.input.title = "x" + c.vibratoSpeed / 10,
                    this.Xy.textContent = "x" + c.vibratoSpeed / 10,
                    this.Vu.input.title = "" + c.panDelay,
                    this.Vy.input.title = "x" + q(p.arpSpeedScale[c.arpeggioSpeed]),
                    this._y.textContent = "x" + q(p.arpSpeedScale[c.arpeggioSpeed]),
                    this.Af.updateValue(c.eqFilterSimpleCut),
                    this.Tf.updateValue(c.eqFilterSimplePeak),
                    this.Of.updateValue(c.noteFilterSimpleCut),
                    this.$f.updateValue(c.noteFilterSimplePeak),
                    this.xb.updateValue(c.envelopeSpeed),
                    this.xb.input.title = "x" + q(p.arpSpeedScale[c.envelopeSpeed]),
                    this.vb.textContent = "x" + q(p.arpSpeedScale[c.envelopeSpeed]),
                    9 == c.type && (this.Hb.redrawCanvas(),
                    this.prompt instanceof us && this.prompt.customChipCanvas.render()),
                    this.hw(h, l, u)
                }
                if (this.tg.style.color = u.primaryNote,
                this.m.synth.isFilterModActive(!1, this.m.channel, this.m.getCurrentInstrument()) ? this.Sf.render(!0, this.Ag || this.Nh) : this.Sf.render(),
                this.Du.updateValue(c.volume),
                this.hy.updateValue(c.detune - p.detuneCenter),
                this.Wy.checked = !!c.fastTwoNoteArp,
                this.yf.checked = !!c.clicklessTransition,
                this.yy.checked = !!c.aliases,
                this.Kb.disabled = c.envelopeCount >= p.maxEnvelopeCount,
                this.gb.checked = !!c.discreteEnvelope,
                this.nu.updateValue(t.volume),
                d && null != m && 0 == m.clientWidth && this.refocusStage(),
                this.lw(this.m.prompt),
                t.autoFollow && !this.m.synth.playing && this.m.synth.goToBar(this.m.bar),
                this.m.addedEffect) {
                    const t = this.Kb.getBoundingClientRect()
                      , e = this.bg.getBoundingClientRect()
                      , i = this.gg.getBoundingClientRect();
                    this.bg.scrollTop += Math.max(0, t.top - (e.top + e.height)),
                    this.gg.scrollTop += Math.max(0, t.top - (i.top + i.height)),
                    this.m.addedEffect = !1
                }
                this.m.addedEnvelope && (this.bg.scrollTop = this.bg.scrollHeight,
                this.gg.scrollTop = this.gg.scrollHeight,
                this.m.addedEnvelope = !1),
                this.handleModRecording()
            }
            ,
            this.updatePlayButton = () => {
                this.Mg == this.m.synth.playing && this.Sg == this.m.synth.recording && this.Fg == this.m.prefs.showRecordButton && this.Cg == this.Ag || (this.Mg = this.m.synth.playing,
                this.Sg = this.m.synth.recording,
                this.Fg = this.m.prefs.showRecordButton,
                this.Cg = this.Ag,
                document.activeElement != this.ci && document.activeElement != this.Zm && document.activeElement != this.Xm && document.activeElement != this.tu || this.refocusStage(),
                this.ci.style.display = "none",
                this.Zm.style.display = "none",
                this.Xm.style.display = "none",
                this.tu.style.display = "none",
                this.eu.style.display = "",
                this.iu.style.display = "",
                this.ci.classList.remove("shrunk"),
                this.Xm.classList.remove("shrunk"),
                this.ag.style.pointerEvents = "",
                this.Qm.container.style.pointerEvents = "",
                this.Qm.container.style.opacity = "",
                this.hg.style.pointerEvents = "",
                this.Ym.container.style.opacity = "",
                this.bg.style.pointerEvents = "",
                this.bg.style.opacity = "",
                this.pg.style.pointerEvents = "",
                this.pg.style.opacity = "",
                this.yg.style.pointerEvents = "",
                this.yg.style.opacity = "",
                this.m.synth.recording ? (this.tu.style.display = "",
                this.eu.style.display = "none",
                this.iu.style.display = "none",
                this.ag.style.pointerEvents = "none",
                this.Qm.container.style.pointerEvents = "none",
                this.Qm.container.style.opacity = "0.5",
                this.hg.style.pointerEvents = "none",
                this.Ym.container.style.opacity = "0.5",
                this.bg.style.pointerEvents = "none",
                this.bg.style.opacity = "0.5",
                this.pg.style.pointerEvents = "none",
                this.pg.style.opacity = "0.5",
                this.yg.style.pointerEvents = "none",
                this.yg.style.opacity = "0.5") : this.m.synth.playing ? this.Zm.style.display = "" : this.m.prefs.showRecordButton ? (this.ci.style.display = "",
                this.Xm.style.display = "",
                this.ci.classList.add("shrunk"),
                this.Xm.classList.add("shrunk")) : this.Ag ? this.Xm.style.display = "" : this.ci.style.display = ""),
                window.requestAnimationFrame(this.updatePlayButton)
            }
            ,
            this.cw = t => {
                this.m.barScrollPos = this.cg.scrollLeft / this.m.getBarWidth(),
                this.m.channelScrollPos = this.cg.scrollTop / xo.patternHeight
            }
            ,
            this.dw = t => !t.ctrlKey || (t.preventDefault(),
            !1),
            this.pw = t => {
                switch (t.keyCode) {
                case 8:
                case 13:
                case 38:
                case 40:
                case 37:
                case 39:
                case 48:
                case 49:
                case 50:
                case 51:
                case 52:
                case 53:
                case 54:
                case 55:
                case 56:
                case 57:
                    t.stopPropagation()
                }
            }
            ,
            this.Ge = t => {
                if (this.Ag = t.ctrlKey,
                this.Nh = t.shiftKey,
                this.prompt)
                    return (this.prompt instanceof us || this.prompt instanceof qo || this.prompt instanceof _o || this.prompt instanceof vs) && this.prompt.whenKeyPressed(t),
                    void (27 == t.keyCode && this.m.undo());
                if (document.activeElement == this.Wb.input || this.Um.editingModLabel || document.activeElement == this.Jm.Cr.input)
                    return void (13 != t.keyCode && 27 != t.keyCode || (this.mainLayer.focus(),
                    this.Um.stopEditingModLabel(27 == t.keyCode)));
                if (document.activeElement == this.Hu || document.activeElement == this.Yf || document.activeElement == this.ly || document.activeElement == this.zu || document.activeElement == this.Yu || document.activeElement == this.Qu || document.activeElement == this.Xu || document.activeElement == this.pu || document.activeElement == this.Ey || document.activeElement == this.Py || document.activeElement == this.Iy || document.activeElement == this.Dy || document.activeElement == this.qy)
                    return void (13 != t.keyCode && 27 != t.keyCode || this.mainLayer.focus());
                if (this.m.synth.recording)
                    return t.ctrlKey || t.metaKey || this.rc.handleKeyEvent(t, !0),
                    void ((32 == t.keyCode || 80 == t.keyCode && (t.ctrlKey || t.metaKey)) && (this.mw(),
                    t.preventDefault(),
                    this.refocusStage()));
                const e = this.m.prefs.pressControlForShortcuts != t.getModifierState("CapsLock")
                  , i = !t.ctrlKey && !t.metaKey && e;
                switch (i && this.rc.handleKeyEvent(t, !0),
                t.keyCode) {
                case 27:
                    t.ctrlKey || t.metaKey || (new Fn(this.m,0,0),
                    this.m.selection.resetBoxSelection());
                    break;
                case 16:
                    this.Um.shiftMode = !0;
                    break;
                case 17:
                    this.Um.controlMode = !0;
                    break;
                case 32:
                    t.ctrlKey ? this.mw() : t.shiftKey ? ((this.Ua.movePlayheadToMouse() || this.Um.movePlayheadToMouse()) && (this.m.synth.playing || this.m.performance.play()),
                    (Math.floor(this.m.synth.playhead) < this.m.synth.loopBarStart || Math.floor(this.m.synth.playhead) > this.m.synth.loopBarEnd) && (this.m.synth.loopBarStart = -1,
                    this.m.synth.loopBarEnd = -1,
                    this.Ym.setLoopAt(this.m.synth.loopBarStart, this.m.synth.loopBarEnd))) : this.togglePlay(),
                    t.preventDefault(),
                    this.refocusStage();
                    break;
                case 80:
                    if (i)
                        break;
                    if (t.ctrlKey || t.metaKey)
                        this.mw(),
                        this.m.synth.loopBarStart = -1,
                        this.m.synth.loopBarEnd = -1,
                        this.Ym.setLoopAt(this.m.synth.loopBarStart, this.m.synth.loopBarEnd),
                        t.preventDefault(),
                        this.refocusStage();
                    else if (i)
                        break;
                    e == (t.ctrlKey || t.metaKey) && t.shiftKey && (location.href = "player/#song=" + this.m.song.toBase64String(),
                    t.preventDefault());
                    break;
                case 192:
                    if (i)
                        break;
                    if (t.shiftKey) {
                        this.m.goBackToStart(),
                        this.m.song.restoreLimiterDefaults();
                        for (const t of this.m.song.channels)
                            t.muted = !1,
                            t.name = "";
                        this.m.record(new rn(this.m,""), !1, !0)
                    } else
                        e == (t.ctrlKey || t.metaKey) && this.bu("songRecovery");
                    t.preventDefault();
                    break;
                case 90:
                    if (i)
                        break;
                    t.shiftKey ? this.m.redo() : this.m.undo(),
                    t.preventDefault();
                    break;
                case 88:
                    if (i)
                        break;
                    this.m.selection.cutNotes(),
                    t.preventDefault();
                    break;
                case 89:
                    if (i)
                        break;
                    this.m.redo(),
                    t.preventDefault();
                    break;
                case 66:
                    if (i)
                        break;
                    if (e == (t.ctrlKey || t.metaKey))
                        if (t.shiftKey)
                            this.bu("beatsPerBar");
                        else {
                            const t = Math.min(this.m.selection.boxSelectionX0, this.m.selection.boxSelectionX1)
                              , e = Math.max(this.m.selection.boxSelectionX0, this.m.selection.boxSelectionX1);
                            t < this.m.synth.loopBarStart || -1 == this.m.synth.loopBarStart || e > this.m.synth.loopBarEnd || -1 == this.m.synth.loopBarEnd ? (this.m.synth.loopBarStart = t,
                            this.m.synth.loopBarEnd = e,
                            this.m.synth.playing || (this.m.synth.snapToBar(),
                            this.m.performance.play())) : (this.m.synth.loopBarStart = -1,
                            this.m.synth.loopBarEnd = -1),
                            this.m.bar != Math.floor(this.m.synth.playhead) && -1 != this.m.synth.loopBarStart && (this.m.synth.goToBar(this.m.bar),
                            this.m.synth.snapToBar(),
                            this.m.synth.initModFilters(this.m.song),
                            this.m.synth.computeLatestModValues(),
                            this.m.prefs.autoFollow && this.m.selection.setChannelBar(this.m.channel, Math.floor(this.m.synth.playhead))),
                            this.Ym.setLoopAt(this.m.synth.loopBarStart, this.m.synth.loopBarEnd)
                        }
                    t.preventDefault();
                    break;
                case 67:
                    if (i)
                        break;
                    t.shiftKey ? this.uw() : (this.m.selection.copy(),
                    this.m.selection.resetBoxSelection(),
                    this.m.selection.selectionUpdated()),
                    t.preventDefault();
                    break;
                case 13:
                    if (this.m.synth.loopBarStart = -1,
                    this.m.synth.loopBarEnd = -1,
                    this.Ym.setLoopAt(this.m.synth.loopBarStart, this.m.synth.loopBarEnd),
                    t.shiftKey && !t.ctrlKey) {
                        const t = this.m.selection.boxSelectionWidth;
                        this.m.bar -= t,
                        this.m.selection.boxSelectionX0 -= t,
                        this.m.selection.boxSelectionX1 -= t,
                        this.m.selection.insertBars()
                    } else
                        !t.ctrlKey && !t.metaKey || t.shiftKey ? this.m.selection.insertBars() : this.m.selection.insertChannel();
                    t.preventDefault();
                    break;
                case 8:
                    this.m.synth.loopBarStart = -1,
                    this.m.synth.loopBarEnd = -1,
                    this.Ym.setLoopAt(this.m.synth.loopBarStart, this.m.synth.loopBarEnd),
                    t.ctrlKey || t.metaKey ? this.m.selection.deleteChannel() : this.m.selection.deleteBars(),
                    this.nd.animatePlayhead(),
                    t.preventDefault();
                    break;
                case 65:
                    if (i)
                        break;
                    t.shiftKey ? this.m.selection.selectChannel() : this.m.selection.selectAll(),
                    t.preventDefault();
                    break;
                case 68:
                    if (i)
                        break;
                    e == (t.ctrlKey || t.metaKey) && (this.m.selection.duplicatePatterns(),
                    t.preventDefault());
                    break;
                case 69:
                    if (i)
                        break;
                    if (t.shiftKey) {
                        !this.m.song.channels[this.m.channel].instruments[this.m.getCurrentInstrument()].eqFilterType && this.m.channel < this.m.song.pitchChannelCount + this.m.song.noiseChannelCount && this.bu("customEQFilterSettings")
                    } else if (e == (t.ctrlKey || t.metaKey)) {
                        this.bu("generateEuclideanRhythm"),
                        t.preventDefault();
                        break
                    }
                    break;
                case 70:
                    if (i)
                        break;
                    t.shiftKey ? (this.m.synth.loopBarStart = -1,
                    this.m.synth.loopBarEnd = -1,
                    this.Ym.setLoopAt(this.m.synth.loopBarStart, this.m.synth.loopBarEnd),
                    this.m.synth.goToBar(this.m.song.loopStart),
                    this.m.synth.snapToBar(),
                    this.m.synth.initModFilters(this.m.song),
                    this.m.synth.computeLatestModValues(),
                    this.m.prefs.autoFollow && this.m.selection.setChannelBar(this.m.channel, Math.floor(this.m.synth.playhead)),
                    t.preventDefault()) : e == (t.ctrlKey || t.metaKey) && (this.m.synth.loopBarStart = -1,
                    this.m.synth.loopBarEnd = -1,
                    this.Ym.setLoopAt(this.m.synth.loopBarStart, this.m.synth.loopBarEnd),
                    this.m.synth.snapToStart(),
                    this.m.synth.initModFilters(this.m.song),
                    this.m.synth.computeLatestModValues(),
                    this.m.prefs.autoFollow && this.m.selection.setChannelBar(this.m.channel, Math.floor(this.m.synth.playhead)),
                    t.preventDefault());
                    break;
                case 72:
                    if (i)
                        break;
                    e == (t.ctrlKey || t.metaKey) && (this.m.synth.goToBar(this.m.bar),
                    this.m.synth.snapToBar(),
                    this.m.synth.initModFilters(this.m.song),
                    this.m.synth.computeLatestModValues(),
                    (Math.floor(this.m.synth.playhead) < this.m.synth.loopBarStart || Math.floor(this.m.synth.playhead) > this.m.synth.loopBarEnd) && (this.m.synth.loopBarStart = -1,
                    this.m.synth.loopBarEnd = -1,
                    this.Ym.setLoopAt(this.m.synth.loopBarStart, this.m.synth.loopBarEnd)),
                    this.m.prefs.autoFollow && this.m.selection.setChannelBar(this.m.channel, Math.floor(this.m.synth.playhead)),
                    t.preventDefault());
                    break;
                case 74:
                    if (i)
                        break;
                    t.shiftKey && t.ctrlKey && t.altKey && (this.m.prefs.autoPlay = !1,
                    this.m.prefs.autoFollow = !1,
                    this.m.prefs.enableNotePreview = !0,
                    this.m.prefs.showFifth = !0,
                    this.m.prefs.notesOutsideScale = !1,
                    this.m.prefs.defaultScale = 0,
                    this.m.prefs.showLetters = !0,
                    this.m.prefs.showChannels = !0,
                    this.m.prefs.showScrollBar = !0,
                    this.m.prefs.alwaysFineNoteVol = !1,
                    this.m.prefs.enableChannelMuting = !0,
                    this.m.prefs.displayBrowserUrl = !0,
                    this.m.prefs.displayVolumeBar = !0,
                    this.m.prefs.layout = "wide",
                    this.m.prefs.visibleOctaves = 5,
                    this.m.prefs.save(),
                    t.preventDefault(),
                    location.reload());
                    break;
                case 76:
                    if (i)
                        break;
                    t.shiftKey ? this.bu("limiterSettings") : this.bu("barCount");
                    break;
                case 77:
                    if (i)
                        break;
                    e == (t.ctrlKey || t.metaKey) && this.m.prefs.enableChannelMuting && (this.m.selection.muteChannels(t.shiftKey),
                    t.preventDefault());
                    break;
                case 78:
                    if (i)
                        break;
                    const n = new Zt;
                    if (t.shiftKey) {
                        const t = this.m.song.channels[this.m.channel].instruments[this.m.getCurrentInstrument()];
                        E(t.effects) && !t.noteFilterType && this.m.channel < this.m.song.pitchChannelCount + this.m.song.noiseChannelCount && this.bu("customNoteFilterSettings");
                        break
                    }
                    if (t.ctrlKey) {
                        let t = 0;
                        for (; t < this.m.song.patternsPerChannel && this.m.song.channels[this.m.channel].patterns[t].notes.length > 0; )
                            t++;
                        t++,
                        t <= p.barCountMax && (t > this.m.song.patternsPerChannel && n.append(new Ki(this.m,t)),
                        n.append(new ve(this.m,t,this.m.bar,this.m.channel,1,1)),
                        this.m.channel >= this.m.song.pitchChannelCount + this.m.song.noiseChannelCount && (this.m.viewedInstrument[this.m.channel] = this.m.recentPatternInstruments[this.m.channel][0]),
                        n.append(new Vi(this.m,this.m.channel,this.m.recentPatternInstruments[this.m.channel],this.m.song.channels[this.m.channel].patterns[t - 1])))
                    } else {
                        let t = 1;
                        for (; -1 != this.m.song.channels[this.m.channel].bars.indexOf(t) && t <= this.m.song.patternsPerChannel; )
                            t++;
                        t <= p.barCountMax && (t > this.m.song.patternsPerChannel && n.append(new Ki(this.m,t)),
                        n.append(new ve(this.m,t,this.m.bar,this.m.channel,1,1)),
                        this.m.channel >= this.m.song.pitchChannelCount + this.m.song.noiseChannelCount && (this.m.viewedInstrument[this.m.channel] = this.m.recentPatternInstruments[this.m.channel][0]),
                        n.append(new Vi(this.m,this.m.channel,this.m.recentPatternInstruments[this.m.channel],this.m.song.channels[this.m.channel].patterns[t - 1])))
                    }
                    this.m.record(n),
                    t.preventDefault();
                    break;
                case 81:
                    if (i)
                        break;
                    if (e == (t.ctrlKey || t.metaKey)) {
                        if (t.shiftKey) {
                            this.bu("addExternal"),
                            t.preventDefault();
                            break
                        }
                        this.bu("channelSettings"),
                        t.preventDefault();
                        break
                    }
                    break;
                case 83:
                    if (i)
                        break;
                    t.ctrlKey || t.metaKey ? (this.bu("export"),
                    t.preventDefault()) : this.m.prefs.enableChannelMuting && (t.shiftKey ? this.m.selection.muteChannels(!1) : this.m.selection.soloChannels(!1),
                    t.preventDefault());
                    break;
                case 79:
                    if (i)
                        break;
                    (t.ctrlKey || t.metaKey) && (this.bu("import"),
                    t.preventDefault());
                    break;
                case 86:
                    if (i)
                        break;
                    (t.ctrlKey || t.metaKey) && t.shiftKey && !e ? this.m.selection.pasteNumbers() : t.shiftKey ? this.fw() : this.m.selection.pasteNotes(),
                    t.preventDefault();
                    break;
                case 87:
                    if (i)
                        break;
                    this.bu("moveNotesSideways");
                    break;
                case 73:
                    if (i)
                        break;
                    if (e == (t.ctrlKey || t.metaKey) && t.shiftKey) {
                        const e = this.m.song.channels[this.m.channel].instruments[this.m.getCurrentInstrument()].toJsonObject();
                        delete e.preset,
                        delete e.volume,
                        delete e.pan;
                        const i = e.effects.indexOf(p.effectNames[2]);
                        -1 != i && e.effects.splice(i, 1);
                        for (let t = 0; t < e.envelopes.length; t++) {
                            const i = e.envelopes[t];
                            "panning" != i.target && "none" != i.target && "none" != i.envelope || (e.envelopes.splice(t, 1),
                            t--)
                        }
                        this.Om(JSON.stringify(e)),
                        t.preventDefault()
                    }
                    break;
                case 82:
                    if (i)
                        break;
                    e == (t.ctrlKey || t.metaKey) && (t.shiftKey ? this.yw() : this.bw(),
                    t.preventDefault());
                    break;
                case 219:
                    if (i)
                        break;
                    e == (t.ctrlKey || t.metaKey) && (this.m.synth.goToPrevBar(),
                    this.m.synth.initModFilters(this.m.song),
                    this.m.synth.computeLatestModValues(),
                    (Math.floor(this.m.synth.playhead) < this.m.synth.loopBarStart || Math.floor(this.m.synth.playhead) > this.m.synth.loopBarEnd) && (this.m.synth.loopBarStart = -1,
                    this.m.synth.loopBarEnd = -1,
                    this.Ym.setLoopAt(this.m.synth.loopBarStart, this.m.synth.loopBarEnd)),
                    this.m.prefs.autoFollow && this.m.selection.setChannelBar(this.m.channel, Math.floor(this.m.synth.playhead)),
                    t.preventDefault());
                    break;
                case 221:
                    if (i)
                        break;
                    e == (t.ctrlKey || t.metaKey) && (this.m.synth.goToNextBar(),
                    this.m.synth.initModFilters(this.m.song),
                    this.m.synth.computeLatestModValues(),
                    (Math.floor(this.m.synth.playhead) < this.m.synth.loopBarStart || Math.floor(this.m.synth.playhead) > this.m.synth.loopBarEnd) && (this.m.synth.loopBarStart = -1,
                    this.m.synth.loopBarEnd = -1,
                    this.Ym.setLoopAt(this.m.synth.loopBarStart, this.m.synth.loopBarEnd)),
                    this.m.prefs.autoFollow && this.m.selection.setChannelBar(this.m.channel, Math.floor(this.m.synth.playhead)),
                    t.preventDefault());
                    break;
                case 189:
                case 173:
                    if (i)
                        break;
                    e == (t.ctrlKey || t.metaKey) && (this.m.selection.transpose(!1, t.shiftKey),
                    t.preventDefault());
                    break;
                case 187:
                case 61:
                case 171:
                    if (i)
                        break;
                    e == (t.ctrlKey || t.metaKey) && (this.m.selection.transpose(!0, t.shiftKey),
                    t.preventDefault());
                    break;
                case 38:
                    t.ctrlKey || t.metaKey ? this.m.selection.swapChannels(-1) : t.shiftKey ? (this.m.selection.boxSelectionY1 = Math.max(0, this.m.selection.boxSelectionY1 - 1),
                    this.m.selection.scrollToEndOfSelection(),
                    this.m.selection.selectionUpdated()) : (this.m.selection.setChannelBar((this.m.channel - 1 + this.m.song.getChannelCount()) % this.m.song.getChannelCount(), this.m.bar),
                    this.m.selection.resetBoxSelection()),
                    t.preventDefault();
                    break;
                case 40:
                    t.ctrlKey || t.metaKey ? this.m.selection.swapChannels(1) : t.shiftKey ? (this.m.selection.boxSelectionY1 = Math.min(this.m.song.getChannelCount() - 1, this.m.selection.boxSelectionY1 + 1),
                    this.m.selection.scrollToEndOfSelection(),
                    this.m.selection.selectionUpdated()) : (this.m.selection.setChannelBar((this.m.channel + 1) % this.m.song.getChannelCount(), this.m.bar),
                    this.m.selection.resetBoxSelection()),
                    t.preventDefault();
                    break;
                case 37:
                    t.shiftKey ? (this.m.selection.boxSelectionX1 = Math.max(0, this.m.selection.boxSelectionX1 - 1),
                    this.m.selection.scrollToEndOfSelection(),
                    this.m.selection.selectionUpdated()) : (this.m.selection.setChannelBar(this.m.channel, (this.m.bar + this.m.song.barCount - 1) % this.m.song.barCount),
                    this.m.selection.resetBoxSelection()),
                    t.preventDefault();
                    break;
                case 39:
                    t.shiftKey ? (this.m.selection.boxSelectionX1 = Math.min(this.m.song.barCount - 1, this.m.selection.boxSelectionX1 + 1),
                    this.m.selection.scrollToEndOfSelection(),
                    this.m.selection.selectionUpdated()) : (this.m.selection.setChannelBar(this.m.channel, (this.m.bar + 1) % this.m.song.barCount),
                    this.m.selection.resetBoxSelection()),
                    t.preventDefault();
                    break;
                case 46:
                    this.m.selection.digits = "",
                    this.m.selection.nextDigit("0", !1, !1);
                    break;
                case 48:
                    if (i)
                        break;
                    this.m.selection.nextDigit("0", e != (t.shiftKey || t.ctrlKey || t.metaKey), t.altKey),
                    this.hw(this.m.song.channels[this.m.channel], this.m.getCurrentInstrument(), nt.getChannelColor(this.m.song, this.m.channel)),
                    t.preventDefault();
                    break;
                case 49:
                    if (i)
                        break;
                    this.m.selection.nextDigit("1", e != (t.shiftKey || t.ctrlKey || t.metaKey), t.altKey),
                    this.hw(this.m.song.channels[this.m.channel], this.m.getCurrentInstrument(), nt.getChannelColor(this.m.song, this.m.channel)),
                    t.preventDefault();
                    break;
                case 50:
                    if (i)
                        break;
                    this.m.selection.nextDigit("2", e != (t.shiftKey || t.ctrlKey || t.metaKey), t.altKey),
                    this.hw(this.m.song.channels[this.m.channel], this.m.getCurrentInstrument(), nt.getChannelColor(this.m.song, this.m.channel)),
                    t.preventDefault();
                    break;
                case 51:
                    if (i)
                        break;
                    this.m.selection.nextDigit("3", e != (t.shiftKey || t.ctrlKey || t.metaKey), t.altKey),
                    this.hw(this.m.song.channels[this.m.channel], this.m.getCurrentInstrument(), nt.getChannelColor(this.m.song, this.m.channel)),
                    t.preventDefault();
                    break;
                case 52:
                    if (i)
                        break;
                    this.m.selection.nextDigit("4", e != (t.shiftKey || t.ctrlKey || t.metaKey), t.altKey),
                    this.hw(this.m.song.channels[this.m.channel], this.m.getCurrentInstrument(), nt.getChannelColor(this.m.song, this.m.channel)),
                    t.preventDefault();
                    break;
                case 53:
                    if (i)
                        break;
                    this.m.selection.nextDigit("5", e != (t.shiftKey || t.ctrlKey || t.metaKey), t.altKey),
                    this.hw(this.m.song.channels[this.m.channel], this.m.getCurrentInstrument(), nt.getChannelColor(this.m.song, this.m.channel)),
                    t.preventDefault();
                    break;
                case 54:
                    if (i)
                        break;
                    this.m.selection.nextDigit("6", e != (t.shiftKey || t.ctrlKey || t.metaKey), t.altKey),
                    this.hw(this.m.song.channels[this.m.channel], this.m.getCurrentInstrument(), nt.getChannelColor(this.m.song, this.m.channel)),
                    t.preventDefault();
                    break;
                case 55:
                    if (i)
                        break;
                    this.m.selection.nextDigit("7", e != (t.shiftKey || t.ctrlKey || t.metaKey), t.altKey),
                    this.hw(this.m.song.channels[this.m.channel], this.m.getCurrentInstrument(), nt.getChannelColor(this.m.song, this.m.channel)),
                    t.preventDefault();
                    break;
                case 56:
                    if (i)
                        break;
                    this.m.selection.nextDigit("8", e != (t.shiftKey || t.ctrlKey || t.metaKey), t.altKey),
                    this.hw(this.m.song.channels[this.m.channel], this.m.getCurrentInstrument(), nt.getChannelColor(this.m.song, this.m.channel)),
                    t.preventDefault();
                    break;
                case 57:
                    if (i)
                        break;
                    this.m.selection.nextDigit("9", e != (t.shiftKey || t.ctrlKey || t.metaKey), t.altKey),
                    this.hw(this.m.song.channels[this.m.channel], this.m.getCurrentInstrument(), nt.getChannelColor(this.m.song, this.m.channel)),
                    t.preventDefault();
                    break;
                default:
                    this.m.selection.digits = "",
                    this.m.selection.instrumentDigits = ""
                }
                i && (this.m.selection.digits = "",
                this.m.selection.instrumentDigits = "")
            }
            ,
            this.gw = t => {
                this.Jm.onKeyUp(t),
                t.ctrlKey || (this.Um.controlMode = !1),
                t.shiftKey || (this.Um.shiftMode = !1),
                this.Ag = t.ctrlKey,
                this.Nh = t.shiftKey,
                this.rc.handleKeyEvent(t, !1)
            }
            ,
            this.ww = () => {
                this.m.synth.goToPrevBar(),
                (Math.floor(this.m.synth.playhead) < this.m.synth.loopBarStart || Math.floor(this.m.synth.playhead) > this.m.synth.loopBarEnd) && (this.m.synth.loopBarStart = -1,
                this.m.synth.loopBarEnd = -1,
                this.Ym.setLoopAt(this.m.synth.loopBarStart, this.m.synth.loopBarEnd)),
                this.nd.animatePlayhead()
            }
            ,
            this.xw = () => {
                this.m.synth.goToNextBar(),
                (Math.floor(this.m.synth.playhead) < this.m.synth.loopBarStart || Math.floor(this.m.synth.playhead) > this.m.synth.loopBarEnd) && (this.m.synth.loopBarStart = -1,
                this.m.synth.loopBarEnd = -1,
                this.Ym.setLoopAt(this.m.synth.loopBarStart, this.m.synth.loopBarEnd)),
                this.nd.animatePlayhead()
            }
            ,
            this.togglePlay = () => {
                this.m.synth.playing ? (this.m.performance.pause(),
                this.outVolumeHistoricCap = 0) : (this.m.synth.snapToBar(),
                this.m.performance.play())
            }
            ,
            this.mw = () => {
                this.m.synth.playing ? this.m.performance.pause() : this.m.performance.record()
            }
            ,
            this.kw = () => {
                this.Mw(),
                this.m.prefs.displayVolumeBar && this.$a(),
                this.nd.animatePlayhead(),
                this.m.synth.isFilterModActive(!1, this.m.channel, this.m.getCurrentInstrument()) && this.Sf.render(!0, this.Ag || this.Nh),
                this.m.synth.isFilterModActive(!0, this.m.channel, this.m.getCurrentInstrument()) && this.zf.render(!0, this.Ag || this.Nh),
                window.requestAnimationFrame(this.kw)
            }
            ,
            this.$a = () => {
                this.outVolumeHistoricTimer--,
                this.outVolumeHistoricTimer <= 0 && (this.outVolumeHistoricCap -= .03),
                this.m.song.outVolumeCap > this.outVolumeHistoricCap && (this.outVolumeHistoricCap = this.m.song.outVolumeCap,
                this.outVolumeHistoricTimer = 50),
                this.m.song.outVolumeCap != this.lastOutVolumeCap && (this.lastOutVolumeCap = this.m.song.outVolumeCap,
                this.Sw(this.m.song.outVolumeCap, this.outVolumeHistoricCap))
            }
            ,
            this.Fw = () => {
                if ((this.Ag || this.Nh) && this.m.synth.playing) {
                    const t = this.m.prefs.volume;
                    this.m.prefs.volume = Math.round(4 * Number(this.nu.input.value) / 3);
                    const e = this.Um.setModSettingsForChange(null, this)
                      , i = this.m.prefs.volume;
                    window.clearTimeout(this.Qg),
                    this.Qg = window.setTimeout(( () => {
                        this.Cw(i)
                    }
                    ), 10),
                    this.m.recordingModulators = !0,
                    this.m.prefs.volume = t,
                    this.nu.updateValue(this.m.prefs.volume),
                    e && this.Ua.render()
                } else
                    this.m.setVolume(Number(this.nu.input.value)),
                    this.m.recordingModulators && (this.m.recordingModulators = !1,
                    this.m.record(new An(this.m,null,null,null)))
            }
            ,
            this.uw = () => {
                const t = this.m.song.channels[this.m.channel].instruments[this.m.getCurrentInstrument()].toJsonObject();
                t.isDrum = this.m.song.getChannelIsNoise(this.m.channel),
                t.isMod = this.m.song.getChannelIsMod(this.m.channel),
                window.localStorage.setItem("instrumentCopy", JSON.stringify(t)),
                this.refocusStage()
            }
            ,
            this.fw = () => {
                const t = this.m.song.channels[this.m.channel].instruments[this.m.getCurrentInstrument()]
                  , e = JSON.parse(String(window.localStorage.getItem("instrumentCopy")));
                null != e && e.isDrum == this.m.song.getChannelIsNoise(this.m.channel) && e.isMod == this.m.song.getChannelIsMod(this.m.channel) && this.m.record(new Hi(this.m,t,e)),
                this.refocusStage()
            }
            ,
            this.Aw = () => {
                this.bu("exportInstrument")
            }
            ,
            this.Ew = () => {
                this.bu("importInstrument")
            }
            ,
            this.Tw = () => {
                this.m.record(new mn(this.m,-1,0 | parseInt(this.uu.value)))
            }
            ,
            this.Pw = () => {
                this.m.record(new pn(this.m,this.m.song.octave,0 | parseInt(this.pu.value))),
                this.Gr.forceRender()
            }
            ,
            this.Bw = () => {
                if (isNaN(this.cu.value)) {
                    switch (this.cu.value) {
                    case "forceScale":
                        this.m.selection.forceScale();
                        break;
                    case "customize":
                        this.bu("customScale")
                    }
                    this.m.notifier.changed()
                } else
                    this.m.record(new nn(this.m,this.cu.selectedIndex))
            }
            ,
            this.Iw = () => {
                if (isNaN(this.du.value)) {
                    if ("detectKey" === this.du.value)
                        this.m.record(new sn(this.m));
                    this.m.notifier.changed()
                } else
                    this.m.record(new zi(this.m,p.keys.length - 1 - this.du.selectedIndex))
            }
            ,
            this.Lw = () => {
                if (isNaN(this.Su.value)) {
                    if ("forceRhythm" === this.Su.value)
                        this.m.selection.forceRhythm();
                    this.m.notifier.changed()
                } else
                    this.m.record(new Ri(this.m,this.Su.selectedIndex))
            }
            ,
            this.Dw = () => {
                var t = this;
                setTimeout((function() {
                    t.mainLayer.focus()
                }
                ), 20)
            }
            ,
            this.zw = () => {
                this.qw($("#pitchPresetSelect").val() + "")
            }
            ,
            this.Nw = () => {
                this.qw($("#drumPresetSelect").val() + "")
            }
            ,
            this.Ow = () => {
                this.m.record(new Mi(this.m,this.hb.selectedIndex))
            }
            ,
            this.Rw = () => {
                this.m.record(new ki(this.m,this.Au.selectedIndex))
            }
            ,
            this.$w = () => {
                this.m.record(new Fi(this.m,this.Eb.selectedIndex)),
                this.Ib.reset()
            }
            ,
            this.Hw = () => {
                this.m.record(new Si(this.m,this.Lb.selectedIndex)),
                this.Ib.reset()
            }
            ,
            this._w = t => {
                if (t.target == this.Pu)
                    this.m.record(new Bi(this.m));
                else if (t.target == this.Bu)
                    this.m.record(new Ii(this.m));
                else {
                    const e = this.Tu.indexOf(t.target);
                    -1 != e && this.m.selection.selectInstrument(e),
                    this.m.channel >= this.m.song.pitchChannelCount + this.m.song.noiseChannelCount && this.Gr.forceRender(),
                    this.hw(this.m.song.channels[this.m.channel], e, nt.getChannelColor(this.m.song, this.m.channel))
                }
                this.refocusStage()
            }
            ,
            this.Vw = t => {
                let e = this.m.song.channels[this.m.channel].instruments[this.m.getCurrentInstrument()]
                  , i = 0 == e.modulators[t] || p.modulators[e.modulators[t]].forSong;
                this.m.selection.setModChannel(t, this.iw[t].selectedIndex);
                const n = Math.max(0, e.modChannels[t]);
                this.m.song.channels[n].instruments.length > 1 && i && this.iw[t].selectedIndex >= 2 && this.m.song.channels[n].bars[this.m.bar] > 0 && this.m.selection.setModInstrument(t, this.m.song.channels[n].patterns[this.m.song.channels[n].bars[this.m.bar] - 1].instruments[0]),
                this.Gr.forceRender()
            }
            ,
            this.Gw = t => {
                this.m.selection.setModInstrument(t, this.nw[t].selectedIndex),
                this.Gr.forceRender()
            }
            ,
            this.ow = (t, e=!1) => {
                let i = "none";
                -1 != this.sw[t].selectedIndex && (i = this.sw[t].children[this.sw[t].selectedIndex].textContent,
                e ? (this.sw[t].selectedOptions.item(0).style.setProperty("color", "red"),
                this.sw[t].classList.add("invalidSetting"),
                this.m.song.channels[this.m.channel].instruments[this.m.getCurrentInstrument()].invalidModulators[t] = !0) : (this.sw[t].classList.remove("invalidSetting"),
                this.m.song.channels[this.m.channel].instruments[this.m.getCurrentInstrument()].invalidModulators[t] = !1)),
                e || this.m.selection.setModSetting(t, i),
                this.Gr.forceRender()
            }
            ,
            this.Ww = t => {
                this.iw[t].selectedIndex >= 2 && this.m.selection.setChannelBar(this.iw[t].selectedIndex - 2, this.m.bar)
            }
            ,
            this.jw = () => {
                const t = this.m.channel
                  , e = this.m.getCurrentInstrument();
                if (t < this.m.song.pitchChannelCount + this.m.song.noiseChannelCount)
                    for (let i = this.m.song.pitchChannelCount + this.m.song.noiseChannelCount; i < this.m.song.channels.length; i++) {
                        const n = this.m.song.channels[i]
                          , s = n.bars[this.m.bar];
                        if (s > 0) {
                            const o = n.patterns[s - 1].instruments[0]
                              , a = n.instruments[o];
                            for (let n = 0; n < p.modCount; n++)
                                if (a.modChannels[n] == t && (a.modInstruments[n] == e || a.modInstruments[n] >= this.m.song.channels[t].instruments.length))
                                    return void this.m.selection.setChannelBar(i, this.m.bar)
                        }
                    }
            }
            ,
            this.Uw = t => {
                this.m.selection.setModFilter(t, this.rw[t].selectedIndex)
            }
            ,
            this.Kw = () => {
                this.m.record(new qn(this.m,this.ju.selectedIndex))
            }
            ,
            this.Jw = () => {
                this.m.record(new Nn(this.m,!!this.Ku.checked))
            }
            ,
            this.Yw = () => {
                this.m.record(new On(this.m,this.Ju.selectedIndex))
            }
            ,
            this.Qw = () => {
                this.m.record(new Rn(this.m,0 | parseInt(this.Yu.value)))
            }
            ,
            this.Zw = () => {
                this.m.record(new $n(this.m,0 | parseInt(this.Qu.value)))
            }
            ,
            this.Xw = () => {
                const t = this.m.song.channels[this.m.channel].instruments[this.m.getCurrentInstrument()]
                  , e = p.rawRawChipWaves[t.chipWave].samples.length;
                this.m.record(new $n(this.m,e - 1))
            }
            ,
            this.tv = () => {
                this.m.record(new Hn(this.m,0 | parseInt(this.Xu.value)))
            }
            ,
            this.ev = () => {
                this.m.record(new _n(this.m,this.tf.checked))
            }
            ,
            this.iv = () => {
                this.m.record(new Vn(this.m,this.Uu.selectedIndex))
            }
            ,
            this.nv = () => {
                this.m.record(new ge(this.m,this.mf.selectedIndex))
            }
            ,
            this.sv = () => {
                const t = this.m.song.channels[this.m.channel].instruments[this.m.getCurrentInstrument()]
                  , e = t.effects
                  , i = p.effectOrder[this.wf.selectedIndex - 1];
                this.m.record(new we(this.m,i,null)),
                this.wf.selectedIndex = 0,
                t.effects > e && (this.m.addedEffect = !0),
                this.m.notifier.changed()
            }
            ,
            this.ov = () => {
                this.m.record(new Oe(this.m,this.Ky.selectedIndex))
            }
            ,
            this.av = () => {
                this.m.record(new Ve(this.m,this.sb.selectedIndex))
            }
            ,
            this.rv = () => {
                this.m.record(new Be(this.m,this.Cy.selectedIndex))
            }
            ,
            this.hv = () => {
                this.m.record(new Ne(this.m,this.Ry.selectedIndex))
            }
            ,
            this.lv = () => {
                this.m.record(new Gn(this.m)),
                this.refocusStage(),
                this.m.addedEnvelope = !0
            }
            ,
            this.cv = () => {
                this.m.prefs.visibleOctaves = Math.max(1, this.m.prefs.visibleOctaves - 1),
                this.m.prefs.save(),
                this.m.notifier.changed(),
                this.refocusStage()
            }
            ,
            this.dv = () => {
                this.m.prefs.visibleOctaves = Math.min(p.pitchOctaves, this.m.prefs.visibleOctaves + 1),
                this.m.prefs.save(),
                this.m.notifier.changed(),
                this.refocusStage()
            }
            ,
            this.pv = t => {
                switch (this.ru.value) {
                case "new":
                    this.m.goBackToStart(),
                    this.m.song.restoreLimiterDefaults();
                    for (const t of this.m.song.channels)
                        t.muted = !1,
                        t.name = "";
                    this.m.record(new rn(this.m,""), !1, !0);
                    break;
                case "export":
                    this.bu("export");
                    break;
                case "import":
                    this.bu("import");
                    break;
                case "copyUrl":
                    this.Om(new URL("#" + this.m.song.toBase64String(),location.href).href);
                    break;
                case "shareUrl":
                    navigator.share({
                        url: new URL("#" + this.m.song.toBase64String(),location.href).href
                    });
                    break;
                case "shortenUrl":
                    let t = "https://tinyurl.com/api-create.php?url=";
                    "isgd" == window.localStorage.getItem("shortenerStrategySelect") && (t = "https://is.gd/create.php?format=simple&url="),
                    window.open(t + encodeURIComponent(new URL("#" + this.m.song.toBase64String(),location.href).href));
                    break;
                case "configureShortener":
                    this.bu("configureShortener");
                    break;
                case "viewPlayer":
                    location.href = "player/#song=" + this.m.song.toBase64String();
                    break;
                case "copyEmbed":
                    this.Om(`<iframe width="384" height="60" style="border: none;" src="${new URL("player/#song=" + this.m.song.toBase64String(),location.href).href}"></iframe>`);
                    break;
                case "songRecovery":
                    this.bu("songRecovery")
                }
                this.ru.selectedIndex = 0
            }
            ,
            this.mv = t => {
                switch (this.hu.value) {
                case "undo":
                    this.m.undo();
                    break;
                case "redo":
                    this.m.redo();
                    break;
                case "copy":
                    this.m.selection.copy();
                    break;
                case "insertBars":
                    this.m.selection.insertBars();
                    break;
                case "deleteBars":
                    this.m.selection.deleteBars();
                    break;
                case "insertChannel":
                    this.m.selection.insertChannel();
                    break;
                case "deleteChannel":
                    this.m.selection.deleteChannel();
                    break;
                case "pasteNotes":
                    this.m.selection.pasteNotes();
                    break;
                case "pasteNumbers":
                    this.m.selection.pasteNumbers();
                    break;
                case "transposeUp":
                    this.m.selection.transpose(!0, !1);
                    break;
                case "transposeDown":
                    this.m.selection.transpose(!1, !1);
                    break;
                case "selectAll":
                    this.m.selection.selectAll();
                    break;
                case "selectChannel":
                    this.m.selection.selectChannel();
                    break;
                case "duplicatePatterns":
                    this.m.selection.duplicatePatterns();
                    break;
                case "barCount":
                    this.bu("barCount");
                    break;
                case "beatsPerBar":
                    this.bu("beatsPerBar");
                    break;
                case "moveNotesSideways":
                    this.bu("moveNotesSideways");
                    break;
                case "channelSettings":
                    this.bu("channelSettings");
                    break;
                case "limiterSettings":
                    this.bu("limiterSettings");
                    break;
                case "generateEuclideanRhythm":
                    this.bu("generateEuclideanRhythm");
                    break;
                case "addExternal":
                    this.bu("addExternal")
                }
                this.hu.selectedIndex = 0
            }
            ,
            this.uv = t => {
                switch (this.lu.value) {
                case "autoPlay":
                    this.m.prefs.autoPlay = !this.m.prefs.autoPlay;
                    break;
                case "autoFollow":
                    this.m.prefs.autoFollow = !this.m.prefs.autoFollow;
                    break;
                case "enableNotePreview":
                    this.m.prefs.enableNotePreview = !this.m.prefs.enableNotePreview;
                    break;
                case "showLetters":
                    this.m.prefs.showLetters = !this.m.prefs.showLetters;
                    break;
                case "showFifth":
                    this.m.prefs.showFifth = !this.m.prefs.showFifth;
                    break;
                case "notesOutsideScale":
                    this.m.prefs.notesOutsideScale = !this.m.prefs.notesOutsideScale;
                    break;
                case "setDefaultScale":
                    this.m.prefs.defaultScale = this.m.song.scale;
                    break;
                case "showChannels":
                    this.m.prefs.showChannels = !this.m.prefs.showChannels;
                    break;
                case "showScrollBar":
                    this.m.prefs.showScrollBar = !this.m.prefs.showScrollBar;
                    break;
                case "alwaysFineNoteVol":
                    this.m.prefs.alwaysFineNoteVol = !this.m.prefs.alwaysFineNoteVol;
                    break;
                case "enableChannelMuting":
                    this.m.prefs.enableChannelMuting = !this.m.prefs.enableChannelMuting;
                    for (const t of this.m.song.channels)
                        t.muted = !1;
                    break;
                case "displayBrowserUrl":
                    this.m.toggleDisplayBrowserUrl();
                    break;
                case "displayVolumeBar":
                    this.m.prefs.displayVolumeBar = !this.m.prefs.displayVolumeBar;
                    break;
                case "notesFlashWhenPlayed":
                    this.m.prefs.notesFlashWhenPlayed = !this.m.prefs.notesFlashWhenPlayed;
                    break;
                case "layout":
                    this.bu("layout");
                    break;
                case "colorTheme":
                    this.bu("theme");
                    break;
                case "customTheme":
                    this.bu("customTheme");
                    break;
                case "recordingSetup":
                    this.bu("recordingSetup");
                    break;
                case "showOscilloscope":
                    this.m.prefs.showOscilloscope = !this.m.prefs.showOscilloscope;
                    break;
                case "showDescription":
                    this.m.prefs.showDescription = !this.m.prefs.showDescription;
                    break;
                case "showInstrumentScrollbars":
                    this.m.prefs.showInstrumentScrollbars = !this.m.prefs.showInstrumentScrollbars;
                    break;
                case "showSampleLoadingStatus":
                    this.m.prefs.showSampleLoadingStatus = !this.m.prefs.showSampleLoadingStatus;
                    break;
                case "closePromptByClickoff":
                    this.m.prefs.closePromptByClickoff = !this.m.prefs.closePromptByClickoff;
                    break;
                case "instrumentCopyPaste":
                    this.m.prefs.instrumentCopyPaste = !this.m.prefs.instrumentCopyPaste;
                    break;
                case "instrumentImportExport":
                    this.m.prefs.instrumentImportExport = !this.m.prefs.instrumentImportExport;
                    break;
                case "instrumentButtonsAtTop":
                    this.m.prefs.instrumentButtonsAtTop = !this.m.prefs.instrumentButtonsAtTop;
                    break;
                case "frostedGlassBackground":
                    this.m.prefs.frostedGlassBackground = !this.m.prefs.frostedGlassBackground
                }
                this.lu.selectedIndex = 0,
                this.m.notifier.changed(),
                this.m.prefs.save()
            }
            ,
            this.fv = t => {
                let e = new Float32Array(64)
                  , i = this._b.selectedIndex - 1
                  , n = Number.MIN_VALUE
                  , s = Number.MAX_VALUE
                  , o = 0
                  , a = (p.chipWaves[i].samples.length - 1) / 64;
                for (let t = 0; t < 64; t++)
                    e[t] = (p.chipWaves[i].samples[Math.floor(o)] - p.chipWaves[i].samples[Math.floor(o) + 1]) / a,
                    e[t] < s && (s = e[t]),
                    e[t] > n && (n = e[t]),
                    o += a;
                for (let t = 0; t < 64; t++)
                    e[t] -= s,
                    e[t] /= n - s,
                    e[t] *= 48,
                    e[t] -= 24,
                    e[t] = Math.ceil(e[t]),
                    this.Hb.newArray[t] = e[t];
                this.m.record(new ue(this.m,e)),
                this.m.record(new Pn(this.m,+this.Du.input.value,-p.volumeRange / 2 + Math.round(Math.sqrt(p.chipWaves[i].expression) * p.volumeRange / 2))),
                this._b.selectedIndex = 0,
                this.m.notifier.changed(),
                this.m.prefs.save()
            }
            ,
            this.m.notifier.watch(this.whenUpdated),
            this.m.modRecordingHandler = () => {
                this.handleModRecording()
            }
            ,
            new na(this.m),
            window.addEventListener("resize", this.whenUpdated),
            window.requestAnimationFrame(this.updatePlayButton),
            window.requestAnimationFrame(this.kw),
            "share"in navigator || this.ru.removeChild(this.ru.querySelector("[value='shareUrl']")),
            this.cu.appendChild(lh({
                label: "Edit"
            }, ch({
                value: "forceScale"
            }, "Snap Notes To Scale"), ch({
                value: "customize"
            }, "Edit Custom Scale"))),
            this.du.appendChild(lh({
                label: "Edit"
            }, ch({
                value: "detectKey"
            }, "Detect Key"))),
            this.Su.appendChild(lh({
                label: "Edit"
            }, ch({
                value: "forceRhythm"
            }, "Snap Notes To Rhythm"))),
            this.Ky.appendChild(ch({
                hidden: !0,
                value: 5
            }, "custom")),
            this.Cy.appendChild(ch({
                hidden: !0,
                value: p.unisons.length
            }, "custom")),
            this.Rg = new Array(p.modulators.length),
            this.Hg = new Array(p.modulators.length),
            this.rb.appendChild(oh({
                class: "selectRow",
                style: `color: ${nt.secondaryText}; height: 1em; margin-top: 0.5em;`
            }, oh({
                style: "margin-right: .1em; visibility: hidden;"
            }, "1."), oh({
                style: "width: 3em; margin-right: .3em;",
                class: "tip",
                onclick: () => this.bu("operatorFrequency")
            }, "Freq:"), oh({
                class: "tip",
                onclick: () => this.bu("operatorVolume")
            }, "Volume:")));
            for (let t = 0; t < p.operatorCount + 2; t++) {
                const e = t
                  , i = oh({
                    style: "margin-right: 0px; color: " + nt.secondaryText + ";"
                }, t + 1 + "")
                  , n = ph(rh({
                    style: "width: 100%;",
                    title: "Frequency"
                }), p.operatorFrequencies.map((t => t.name)))
                  , s = new lo(ah({
                    type: "range",
                    min: "0",
                    max: p.operatorAmplitudeMax,
                    value: "0",
                    step: "1",
                    title: "Volume"
                }),this.m,( (t, i) => new Ti(this.m,e,t,i)),!1)
                  , o = ph(rh({
                    style: "width: 100%;",
                    title: "Waveform"
                }), p.operatorWaves.map((t => t.name)))
                  , a = sh({
                    style: "margin-left:0em; margin-right: 2px; height:1.5em; width: 8px; max-width: 10px; padding: 0px; font-size: 8px;",
                    onclick: () => this.$u(4, t)
                }, "▼")
                  , r = hh({
                    class: "tip",
                    style: "margin-left: 10px;",
                    onclick: () => this.bu("operatorWaveform")
                }, "Wave:")
                  , h = new lo(ah({
                    style: "margin-left: 10px; width: 85%;",
                    type: "range",
                    min: "0",
                    max: p.pwmOperatorWaves.length - 1,
                    value: "0",
                    step: "1",
                    title: "Pulse Width"
                }),this.m,( (t, i) => new Ai(this.m,e,t,i)),!0)
                  , l = oh({
                    class: "selectRow"
                }, r, h.container, oh({
                    class: "selectContainer",
                    style: "width: 6em; margin-left: .3em;"
                }, o))
                  , c = oh({
                    class: "operatorRow"
                }, l)
                  , d = oh({
                    class: "selectRow"
                }, i, a, oh({
                    class: "selectContainer",
                    style: "width: 3em; margin-right: .3em;"
                }, n), s.container);
                this.rb.appendChild(d),
                this.Tg[t] = d,
                this.Pg[t] = s,
                this.Bg[t] = n,
                this.Ig[t] = a,
                this.Dg[t] = r,
                this.Lg[t] = o,
                this.zg[t] = h,
                this.qg[t] = l,
                this.rb.appendChild(c),
                this.Ng[t] = c,
                this.Kg[t] = !1,
                o.addEventListener("change", ( () => {
                    this.m.record(new Ci(this.m,e,o.selectedIndex))
                }
                )),
                n.addEventListener("change", ( () => {
                    this.m.record(new Ei(this.m,e,n.selectedIndex))
                }
                ))
            }
            this.Fb.appendChild(oh({
                class: "selectRow"
            }, hh({
                class: "tip",
                onclick: () => this.bu("drumsetEnvelope")
            }, "Envelope:"), hh({
                class: "tip",
                onclick: () => this.bu("drumsetSpectrum")
            }, "Spectrum:"), this.Cb));
            for (let t = p.drumCount - 1; t >= 0; t--) {
                const e = t
                  , i = new Ya(this.m,e);
                i.container.addEventListener("mousedown", this.refocusStage),
                this.Fc[t] = i;
                const n = ph(rh({
                    style: "width: 100%;",
                    title: "Filter Envelope"
                }), p.envelopes.map((t => t.name)));
                this.Og[t] = n,
                n.addEventListener("change", ( () => {
                    this.m.record(new Qe(this.m,e,n.selectedIndex))
                }
                ));
                const s = oh({
                    class: "selectRow"
                }, oh({
                    class: "selectContainer",
                    style: "width: 5em; margin-right: .3em;"
                }, n), this.Fc[t].container);
                this.Fb.appendChild(s)
            }
            this.yv = [],
            this.iw = [],
            this.nw = [],
            this.bv = [],
            this.sw = [],
            this.gv = [],
            this.rw = [],
            this.aw = [];
            for (let t = 0; t < p.modCount; t++) {
                let e = rh({
                    style: "width: 100%; color: currentColor; text-overflow:ellipsis;"
                })
                  , i = rh({
                    style: "width: 100%; color: currentColor;"
                })
                  , n = oh({
                    class: "operatorRow",
                    style: "height: 1em; margin-bottom: 0.65em;"
                }, oh({
                    class: "tip",
                    style: "width: 10%; max-width: 5.4em;",
                    id: "modChannelText" + t,
                    onclick: () => this.bu("modChannel")
                }, "Ch:"), oh({
                    class: "selectContainer",
                    style: "width: 35%;"
                }, e), oh({
                    class: "tip",
                    style: "width: 1.2em; margin-left: 0.8em;",
                    id: "modInstrumentText" + t,
                    onclick: () => this.bu("modInstrument")
                }, "Ins:"), oh({
                    class: "selectContainer",
                    style: "width: 10%;"
                }, i))
                  , s = rh()
                  , o = rh()
                  , a = oh({
                    class: "selectRow",
                    id: "modSettingText" + t,
                    style: "margin-bottom: 0.9em; color: currentColor;"
                }, hh({
                    class: "tip",
                    onclick: () => this.bu("modSet")
                }, "Setting: "), hh({
                    class: "tip",
                    style: "font-size:x-small;",
                    onclick: () => this.bu("modSetInfo" + t)
                }, "?"), oh({
                    class: "selectContainer"
                }, s))
                  , r = oh({
                    class: "selectRow",
                    id: "modFilterText" + t,
                    style: "margin-bottom: 0.9em; color: currentColor;"
                }, hh({
                    class: "tip",
                    onclick: () => this.bu("modFilter" + t)
                }, "Target: "), oh({
                    class: "selectContainer"
                }, o))
                  , h = Y.svg({
                    style: "transform: translate(0px, 1px);",
                    width: "1.5em",
                    height: "1em",
                    viewBox: "0 0 200 200"
                }, [Y.path({
                    d: "M90 155 l0 -45 -45 0 c-25 0 -45 -4 -45 -10 0 -5 20 -10 45 -10 l45 0 0 -45 c0 -25 5 -45 10 -45 6 0 10 20 10 45 l0 45 45 0 c25 0 45 5 45 10 0 6 -20 10 -45 10 l -45 0 0 45 c0 25 -4 45 -10 45 -5 0 -10 -20 -10 -45z"
                }), Y.path({
                    d: "M42 158 c-15 -15 -16 -38 -2 -38 6 0 10 7 10 15 0 8 7 15 15 15 8 0 15 5 15 10 0 14 -23 13 -38 -2z"
                }), Y.path({
                    d: "M120 160 c0 -5 7 -10 15 -10 8 0 15 -7 15 -15 0 -8 5 -15 10 -15 14 0 13 23 -2 38 -15 15 -38 16 -38 2z"
                }), Y.path({
                    d: "M32 58 c3 -23 48 -40 48 -19 0 6 -7 11 -15 11 -8 0 -15 7 -15 15 0 8 -5 15 -11 15 -6 0 -9 -10 -7 -22z"
                }), Y.path({
                    d: "M150 65 c0 -8 -7 -15 -15 -15 -8 0 -15 -4 -15 -10 0 -14 23 -13 38 2 15 15 16 38 2 38 -5 0 -10 -7 -10 -15z"
                })]);
                this.yv.push(n),
                this.iw.push(e),
                this.nw.push(i),
                this.bv.push(a),
                this.sw.push(s),
                this.gv.push(r),
                this.rw.push(o),
                this.aw.push(h),
                this.Ab.appendChild(oh({
                    style: "margin: 3px 0; font-weight: bold; margin-bottom: 0.7em; text-align: center; color: " + nt.secondaryText + "; background: " + nt.uiWidgetBackground + ";"
                }, ["Modulator " + (t + 1), h])),
                this.Ab.appendChild(n),
                this.Ab.appendChild(a),
                this.Ab.appendChild(r)
            }
            this.ey.container.style.setProperty("transform", "translate(0px, 3px)"),
            this.ey.container.style.setProperty("width", "100%"),
            this.ru.addEventListener("change", this.pv),
            this.hu.addEventListener("change", this.mv),
            this.lu.addEventListener("change", this.uv),
            this._b.addEventListener("change", this.fv),
            this.uu.addEventListener("change", this.Tw),
            this.cu.addEventListener("change", this.Bw),
            this.du.addEventListener("change", this.Iw),
            this.pu.addEventListener("change", this.Pw),
            this.Su.addEventListener("change", this.Lw),
            this.Au.addEventListener("change", this.Rw),
            this.Iu.addEventListener("click", this._w),
            this.hb.addEventListener("change", this.Ow),
            this.Lb.addEventListener("change", this.Hw),
            this.Eb.addEventListener("change", this.$w),
            this.ju.addEventListener("change", this.Kw),
            this.Ku.addEventListener("input", this.Jw),
            this.Ju.addEventListener("change", this.Yw),
            this.Yu.addEventListener("change", this.Qw),
            this.Qu.addEventListener("change", this.Zw),
            this.Zu.addEventListener("click", this.Xw),
            this.Xu.addEventListener("change", this.tv),
            this.tf.addEventListener("input", this.ev),
            this.fg.addEventListener("click", this.Zg),
            this.Uu.addEventListener("change", this.iv),
            this.mf.addEventListener("change", this.nv),
            this.wf.addEventListener("change", this.sv),
            this.Cy.addEventListener("change", this.rv),
            this.Ry.addEventListener("change", this.hv),
            this.Ky.addEventListener("change", this.ov),
            this.sb.addEventListener("change", this.av),
            this.ci.addEventListener("click", this.togglePlay),
            this.Zm.addEventListener("click", this.togglePlay),
            this.Xm.addEventListener("click", this.mw),
            this.tu.addEventListener("click", this.mw),
            this.Xm.addEventListener("contextmenu", (t => {
                t.ctrlKey && (t.preventDefault(),
                this.mw())
            }
            )),
            this.tu.addEventListener("contextmenu", (t => {
                t.ctrlKey && (t.preventDefault(),
                this.mw())
            }
            )),
            this.eu.addEventListener("click", this.ww),
            this.iu.addEventListener("click", this.xw),
            this.nu.input.addEventListener("input", this.Fw),
            this.yp.addEventListener("click", this.cv),
            this.bp.addEventListener("click", this.dv),
            this.rg.addEventListener("mousedown", this.tw),
            this.dg.addEventListener("mousedown", this.refocusStage),
            this.nu.container.style.setProperty("flex-grow", "1"),
            this.nu.container.style.setProperty("display", "flex"),
            this.ou.style.setProperty("flex-grow", "1"),
            this.ou.style.setProperty("display", "flex"),
            this.nu.container.style.setProperty("--mod-color", nt.multiplicativeModSlider),
            this.nu.container.style.setProperty("--mod-border-radius", "50%"),
            this.Du.container.style.setProperty("--mod-color", nt.multiplicativeModSlider),
            this.Du.container.style.setProperty("--mod-border-radius", "50%"),
            this.jb.container.style.setProperty("--mod-color", nt.multiplicativeModSlider),
            this.jb.container.style.setProperty("--mod-border-radius", "50%");
            for (let t = 0; t < p.operatorCount + 2; t++)
                this.Pg[t].container.style.setProperty("--mod-color", nt.multiplicativeModSlider),
                this.Pg[t].container.style.setProperty("--mod-border-radius", "50%");
            let e = this;
            for (let t = 0; t < p.modCount; t++)
                this.iw[t].addEventListener("change", (function() {
                    e.Vw(t)
                }
                )),
                this.nw[t].addEventListener("change", (function() {
                    e.Gw(t)
                }
                )),
                this.sw[t].addEventListener("change", (function() {
                    e.ow(t)
                }
                )),
                this.rw[t].addEventListener("change", (function() {
                    e.Uw(t)
                }
                )),
                this.aw[t].addEventListener("click", (function() {
                    e.Ww(t)
                }
                ));
            if (this.ng.addEventListener("click", (function() {
                e.jw()
            }
            )),
            this.rg.addEventListener("mousedown", this.refocusStage),
            this.df.container.addEventListener("mousedown", this.refocusStage),
            this.cb.container.addEventListener("mousedown", this.refocusStage),
            this.Sf.container.addEventListener("mousedown", this.refocusStage),
            this.zf.container.addEventListener("mousedown", this.refocusStage),
            this.ub.container.addEventListener("mousedown", this.refocusStage),
            this.uu.addEventListener("keydown", this.pw, !1),
            this.Kb.addEventListener("click", this.lv),
            this.rg.addEventListener("contextmenu", this.dw),
            this.dg.addEventListener("contextmenu", this.dw),
            this.mainLayer.addEventListener("keydown", this.Ge),
            this.mainLayer.addEventListener("keyup", this.gw),
            this.mainLayer.addEventListener("focusin", this.Xg),
            this.zb.addEventListener("click", this.uw.bind(this)),
            this.qb.addEventListener("click", this.fw.bind(this)),
            this.Nb.addEventListener("click", this.Aw.bind(this)),
            this.Ob.addEventListener("click", this.Ew.bind(this)),
            r.addEventListener("sampleloaded", this.wv.bind(this)),
            this.zu.addEventListener("input", ( () => {
                this.m.record(new Pn(this.m,this.m.song.channels[this.m.channel].instruments[this.m.getCurrentInstrument()].volume,Math.min(25, Math.max(-25, Math.round(+this.zu.value)))))
            }
            )),
            this.Hu.addEventListener("input", ( () => {
                this.m.record(new Ln(this.m,this.m.song.channels[this.m.channel].instruments[this.m.getCurrentInstrument()].pan,Math.min(100, Math.max(0, Math.round(+this.Hu.value)))))
            }
            )),
            this.Yf.addEventListener("input", ( () => {
                this.m.record(new Xe(this.m,this.m.song.channels[this.m.channel].instruments[this.m.getCurrentInstrument()].pulseWidth,Math.min(p.pulseWidthRange, Math.max(1, Math.round(+this.Yf.value)))))
            }
            )),
            this.ly.addEventListener("input", ( () => {
                this.m.record(new oi(this.m,this.m.song.channels[this.m.channel].instruments[this.m.getCurrentInstrument()].detune,Math.min(p.detuneMax - p.detuneCenter, Math.max(p.detuneMin - p.detuneCenter, Math.round(+this.ly.value)))))
            }
            )),
            this.Ey.addEventListener("input", ( () => {
                this.m.record(new Ie(this.m,this.m.song.channels[this.m.channel].instruments[this.m.getCurrentInstrument()].unisonVoices,Math.min(p.unisonVoicesMax, Math.max(p.unisonVoicesMin, Math.round(+this.Ey.value)))))
            }
            )),
            this.Py.addEventListener("input", ( () => {
                this.m.record(new Le(this.m,this.m.song.channels[this.m.channel].instruments[this.m.getCurrentInstrument()].unisonSpread,Math.min(p.unisonSpreadMax, Math.max(p.unisonSpreadMin, +this.Py.value))))
            }
            )),
            this.Iy.addEventListener("input", ( () => {
                this.m.record(new De(this.m,this.m.song.channels[this.m.channel].instruments[this.m.getCurrentInstrument()].unisonOffset,Math.min(p.unisonOffsetMax, Math.max(p.unisonOffsetMin, +this.Iy.value))))
            }
            )),
            this.Dy.addEventListener("input", ( () => {
                this.m.record(new ze(this.m,this.m.song.channels[this.m.channel].instruments[this.m.getCurrentInstrument()].unisonExpression,Math.min(p.unisonExpressionMax, Math.max(p.unisonExpressionMin, +this.Dy.value))))
            }
            )),
            this.qy.addEventListener("input", ( () => {
                this.m.record(new qe(this.m,this.m.song.channels[this.m.channel].instruments[this.m.getCurrentInstrument()].unisonSign,Math.min(p.unisonSignMax, Math.max(p.unisonSignMin, +this.qy.value))))
            }
            )),
            this.Gb.addEventListener("input", ( () => {
                this.m.record(new ue(this.m,this.Hb.newArray))
            }
            )),
            this.Wy.addEventListener("input", ( () => {
                this.m.record(new We(this.m,this.Wy.checked))
            }
            )),
            this.yf.addEventListener("input", ( () => {
                this.m.record(new je(this.m,this.yf.checked))
            }
            )),
            this.yy.addEventListener("input", ( () => {
                this.m.record(new Ue(this.m,this.yy.checked))
            }
            )),
            this.gb.addEventListener("input", ( () => {
                this.m.record(new Ke(this.m,this.gb.checked))
            }
            )),
            this.sg.addEventListener("click", (t => {
                if (!0 === this.m.prefs.closePromptByClickoff) {
                    if (null != this.prompt && !0 === this.prompt.gotMouseUp)
                        return;
                    t.target == this.sg && this.m.undo()
                }
            }
            )),
            this.cg.addEventListener("scroll", this.cw, {
                capture: !1,
                passive: !0
            }),
            z) {
                const t = this.lu.querySelector("[value=autoPlay]");
                t.disabled = !0,
                t.setAttribute("hidden", "")
            }
            if (window.screen.availWidth < 710) {
                const t = this.lu.querySelector("[value=layout]");
                t.disabled = !0,
                t.setAttribute("hidden", "")
            }
        }
        wv(t) {
            const e = t
              , i = 0 === e.totalSamples ? 0 : Math.floor(e.samplesLoaded / e.totalSamples * 100);
            this.mg.style.width = `${i}%`
        }
        Bb(t) {
            "feedback" != this.Ib.mode ? (this.Ib.mode = "feedback",
            t.target.textContent = "F",
            this.Pb.value = "feedback") : (this.Ib.mode = "algorithm",
            t.target.textContent = "A"),
            this.Ib.redrawCanvas()
        }
        $u(t, e=0) {
            let i = this.Jy
              , n = this.ab;
            switch (t) {
            case 7:
                i = this.Sb,
                this.Wg = !this.Wg,
                n = this.Mb;
                break;
            case 0:
                i = this.Jy,
                this.Gg = !this.Gg,
                n = this.ab;
                break;
            case 1:
                i = this.Ru,
                this.Vg = !this.Vg,
                n = this.Wu;
                break;
            case 2:
                i = this.$y,
                this.jg = !this.jg,
                n = this.Uy;
                break;
            case 3:
                i = this.uf,
                this.Ug = !this.Ug,
                n = this.gf;
                break;
            case 4:
                i = this.Ig[e],
                this.Kg[e] = !this.Kg[e],
                n = this.Ng[e];
                break;
            case 5:
                i = this.Jf,
                this.Jg = !this.Jg,
                n = this.ty;
                break;
            case 6:
                i = this.Fy,
                this.Yg = !this.Yg,
                n = this.Oy
            }
            if ("▼" == i.textContent) {
                let t = this.m.song.channels[this.m.channel].instruments[this.m.getCurrentInstrument()];
                i.textContent = "▲",
                (n != this.Uy || t.chord == p.chords.dictionary.arpeggio.index) && (n.style.display = "");
                for (let t = 0; t < n.children.length; t++)
                    setTimeout(( () => {
                        n.children[t].style.animationDelay = "0.17s",
                        n.children[t].style.opacity = "1"
                    }
                    ))
            } else {
                for (let t = 0; t < n.children.length; t++)
                    n.children[t].style.animationDelay = "0s",
                    n.children[t].style.opacity = "0";
                i.textContent = "▼",
                n.style.display = "none"
            }
        }
        Mw() {
            if (this.m.synth.playing) {
                let t = this.m.getCurrentInstrument();
                const e = this.m.synth.isAnyModActive(this.m.channel, t);
                if (e) {
                    let i = this.m.getCurrentInstrument();
                    function n(t, e, i, n, s) {
                        if (t.m.synth.isModActive(i, n, s)) {
                            let o = (t.m.synth.getModValue(i, n, s, !1) - p.modulators[i].convertRealFactor) / p.modulators[i].maxRawVol;
                            return 1 == p.modulators[i].invertSliderIndicator && (o = 1 - o),
                            o != t.Hg[i] && (t.Hg[i] = o,
                            e.container.style.setProperty("--mod-position", 96 * o + 2 + "%")),
                            !0
                        }
                        return !1
                    }
                    for (let s = 0; s < p.modulators.length; s++) {
                        this.$g[s] = this.Rg[s];
                        let o = this.getSliderForModSetting(s);
                        null != o && (this.$g[s] = n(this, o, s, this.m.channel, i))
                    }
                } else if (this._g)
                    for (let a = 0; a < p.modulators.length; a++)
                        this.$g[a] = !1;
                if (e || this._g) {
                    let r = !1;
                    for (let h = 0; h < p.modulators.length; h++) {
                        if (this.$g[h] != this.Rg[h]) {
                            this.Rg[h] = this.$g[h];
                            let l = this.getSliderForModSetting(h);
                            null != l && (1 == this.Rg[h] ? l.container.classList.add("modSlider") : l.container.classList.remove("modSlider"))
                        }
                        1 == this.$g[h] && (r = !0)
                    }
                    this._g = r
                }
            } else {
                this._g = !1;
                for (let c = 0; c < p.modulators.length; c++)
                    if (1 == this.Rg[c]) {
                        this.Rg[c] = !1,
                        this.$g[c] = !1;
                        let d = this.getSliderForModSetting(c);
                        null != d && d.container.classList.remove("modSlider")
                    }
            }
        }
        getSliderForModSetting(t) {
            switch (t) {
            case p.modulators.dictionary.pan.index:
                return this.Ou;
            case p.modulators.dictionary.detune.index:
                return this.hy;
            case p.modulators.dictionary["fm slider 1"].index:
                return this.Pg[0];
            case p.modulators.dictionary["fm slider 2"].index:
                return this.Pg[1];
            case p.modulators.dictionary["fm slider 3"].index:
                return this.Pg[2];
            case p.modulators.dictionary["fm slider 4"].index:
                return this.Pg[3];
            case p.modulators.dictionary["fm feedback"].index:
                return this.jb;
            case p.modulators.dictionary["pulse width"].index:
                return this.Kf;
            case p.modulators.dictionary["decimal offset"].index:
                return this.Zf;
            case p.modulators.dictionary.reverb.index:
                return this.gu;
            case p.modulators.dictionary.distortion.index:
                return this.my;
            case p.modulators.dictionary["note volume"].index:
                return this.Rg[p.modulators.dictionary["mix volume"].index] ? null : this.Du;
            case p.modulators.dictionary["mix volume"].index:
                return this.Du;
            case p.modulators.dictionary["vibrato depth"].index:
                return this.Qy;
            case p.modulators.dictionary["vibrato speed"].index:
                return this.tb;
            case p.modulators.dictionary["vibrato delay"].index:
                return this.ib;
            case p.modulators.dictionary["arp speed"].index:
                return this.Vy;
            case p.modulators.dictionary["pan delay"].index:
                return this.Vu;
            case p.modulators.dictionary.tempo.index:
                return this.mu;
            case p.modulators.dictionary["song volume"].index:
                return this.nu;
            case p.modulators.dictionary["eq filt cut"].index:
                return this.Af;
            case p.modulators.dictionary["eq filt peak"].index:
                return this.Tf;
            case p.modulators.dictionary["note filt cut"].index:
                return this.Of;
            case p.modulators.dictionary["note filt peak"].index:
                return this.$f;
            case p.modulators.dictionary["bit crush"].index:
                return this.gy;
            case p.modulators.dictionary["freq crush"].index:
                return this.vy;
            case p.modulators.dictionary["pitch shift"].index:
                return this.ey;
            case p.modulators.dictionary.chorus.index:
                return this.fu;
            case p.modulators.dictionary.echo.index:
                return this.vu;
            case p.modulators.dictionary["echo delay"].index:
                return this.ku;
            case p.modulators.dictionary.sustain.index:
                return this.ky;
            case p.modulators.dictionary["fm slider 5"].index:
                return this.Pg[4];
            case p.modulators.dictionary["fm slider 6"].index:
                return this.Pg[5];
            case p.modulators.dictionary["envelope speed"].index:
                return this.xb;
            case p.modulators.dictionary.dynamism.index:
                return this._f;
            case p.modulators.dictionary.spread.index:
                return this.Gf;
            case p.modulators.dictionary["saw shape"].index:
                return this.jf;
            default:
                return null
            }
        }
        bu(t) {
            this.m.openPrompt(t),
            this.lw(t)
        }
        lw(t) {
            if (this.vg != t && (this.vg = t,
            this.prompt && (this.wg && !(this.prompt instanceof gr || this.prompt instanceof qo || this.prompt instanceof _o || this.prompt instanceof us || this.prompt instanceof vs || this.prompt instanceof Pr || this.prompt instanceof Ma || this.prompt instanceof ao || this.prompt instanceof Qa) && this.m.performance.play(),
            this.wg = !1,
            this.og.style.display = "none",
            this.sg.style.display = "none",
            this.sg.removeChild(this.prompt.container),
            this.prompt.cleanUp(),
            this.prompt = null,
            this.refocusStage()),
            t)) {
                switch (t) {
                case "export":
                    this.prompt = new no(this.m);
                    break;
                case "import":
                    this.prompt = new wo(this.m);
                    break;
                case "songRecovery":
                    this.prompt = new Ra(this.m);
                    break;
                case "barCount":
                    this.prompt = new ya(this.m);
                    break;
                case "beatsPerBar":
                    this.prompt = new is(this.m);
                    break;
                case "moveNotesSideways":
                    this.prompt = new Zo(this.m);
                    break;
                case "channelSettings":
                    this.prompt = new ls(this.m);
                    break;
                case "limiterSettings":
                    this.prompt = new qo(this.m,this);
                    break;
                case "customScale":
                    this.prompt = new _o(this.m);
                    break;
                case "customChipSettings":
                    this.prompt = new us(this.m,this);
                    break;
                case "customEQFilterSettings":
                    this.prompt = new vs(this.m,this,!1);
                    break;
                case "customNoteFilterSettings":
                    this.prompt = new vs(this.m,this,!0);
                    break;
                case "harmonicsSettings":
                    this.prompt = new ao(this.m,this);
                    break;
                case "spectrumSettings":
                    this.prompt = new Qa(this.m,this,!1);
                    break;
                case "drumsetSettings":
                    this.prompt = new Qa(this.m,this,!0);
                    break;
                case "theme":
                    this.prompt = new pr(this.m);
                    break;
                case "layout":
                    this.prompt = new Eo(this.m);
                    break;
                case "recordingSetup":
                    this.prompt = new Ja(this.m);
                    break;
                case "exportInstrument":
                    this.prompt = new As(this.m);
                    break;
                case "importInstrument":
                    this.prompt = new zs(this.m);
                    break;
                case "stringSustain":
                    this.prompt = new Ma(this.m);
                    break;
                case "addExternal":
                    this.prompt = new Qr(this.m);
                    break;
                case "generateEuclideanRhythm":
                    this.prompt = new Vs(this.m);
                    break;
                case "customTheme":
                    this.prompt = new or(this.m,this.Um,this.dg,document.getElementById("beepboxEditorContainer"));
                    break;
                case "visualLoopControls":
                    this.prompt = new Pr(this.m,this);
                    break;
                case "sampleLoadingStatus":
                    this.prompt = new qr(this.m);
                    break;
                case "configureShortener":
                    this.prompt = new nh(this.m);
                    break;
                default:
                    this.prompt = new gr(this.m,t)
                }
                this.prompt && (this.prompt instanceof gr || this.prompt instanceof qo || this.prompt instanceof us || this.prompt instanceof vs || this.prompt instanceof Pr || this.prompt instanceof Ma || this.prompt instanceof ao || this.prompt instanceof Qa || (this.wg = this.m.synth.playing,
                this.m.performance.pause()),
                this.sg.style.display = "",
                1 == this.m.prefs.frostedGlassBackground ? (this.og.style.display = "",
                this.og.style.backgroundColor = "rgba(0,0,0, 0)",
                this.og.style.backdropFilter = "brightness(0.9) blur(14px)",
                this.og.style.opacity = "1") : (this.og.style.display = "",
                this.og.style.backgroundColor = "var(--editor-background)",
                this.og.style.backdropFilter = "",
                this.og.style.opacity = "0.5"),
                this.sg.appendChild(this.prompt.container),
                document.body.appendChild(this.og))
            }
        }
        changeBarScrollPos(t) {
            this.nd.changePos(t)
        }
        handleModRecording() {
            window.clearTimeout(this.Qg);
            const t = this.m.checkLastChange();
            if ((this.Ag || this.Nh) && null != t && this.m.synth.playing) {
                const e = this.Um.setModSettingsForChange(t, this);
                null != this.m.continuingModRecordingChange && (this.Qg = window.setTimeout(( () => {
                    this.handleModRecording()
                }
                ), 10),
                this.m.recordingModulators = !0,
                e && this.Ua.render())
            } else
                this.m.recordingModulators && (this.m.recordingModulators = !1,
                this.m.record(new An(this.m,null,null,null)))
        }
        hw(t, e, i) {
            if (this.m.song.layeredInstruments || this.m.song.patternInstruments) {
                this.Lu.style.display = "",
                this.Iu.style.setProperty("--text-color-lit", i.primaryNote),
                this.Iu.style.setProperty("--text-color-dim", i.secondaryNote),
                this.Iu.style.setProperty("--background-color-lit", i.primaryChannel),
                this.Iu.style.setProperty("--background-color-dim", i.secondaryChannel);
                const n = this.m.song.getMaxInstrumentsPerChannel();
                for (; this.Tu.length < t.instruments.length; ) {
                    const t = sh(String(this.Tu.length + 1));
                    this.Tu.push(t),
                    this.Iu.insertBefore(t, this.Bu)
                }
                for (let e = this.kg; e < t.instruments.length; e++)
                    this.Tu[e].style.display = "";
                for (let e = t.instruments.length; e < this.kg; e++)
                    this.Tu[e].style.display = "none";
                for (this.kg = t.instruments.length; this.Tu.length > n; )
                    this.Iu.removeChild(this.Tu.pop());
                if (this.Bu.style.display = t.instruments.length > p.instrumentCountMin ? "" : "none",
                this.Pu.style.display = t.instruments.length < n ? "" : "none",
                t.instruments.length < n ? this.Bu.classList.remove("last-button") : this.Bu.classList.add("last-button"),
                t.instruments.length > 1) {
                    if (this.xg != e) {
                        const t = this.Tu[this.xg];
                        null != t && t.classList.remove("selected-instrument");
                        this.Tu[e].classList.add("selected-instrument"),
                        this.xg = e
                    }
                } else {
                    const t = this.Tu[this.xg];
                    null != t && t.classList.remove("selected-instrument"),
                    this.xg = -1
                }
                if (this.m.song.layeredInstruments && this.m.song.patternInstruments && this.m.channel < this.m.song.pitchChannelCount + this.m.song.noiseChannelCount) {
                    for (let e = 0; e < t.instruments.length; e++)
                        -1 != this.m.recentPatternInstruments[this.m.channel].indexOf(e) ? this.Tu[e].classList.remove("deactivated") : this.Tu[e].classList.add("deactivated");
                    this.Eg = !0
                } else if (this.Eg || this.m.channel >= this.m.song.pitchChannelCount + this.m.song.noiseChannelCount) {
                    for (let e = 0; e < t.instruments.length; e++)
                        this.Tu[e].classList.remove("deactivated");
                    this.Eg = !1
                }
                if (this.m.song.layeredInstruments && this.m.song.patternInstruments && t.instruments.length > 1 && this.m.channel < this.m.song.pitchChannelCount + this.m.song.noiseChannelCount)
                    for (let e = 0; e < t.instruments.length; e++)
                        this.Tu[e].classList.remove("no-underline");
                else
                    for (let e = 0; e < t.instruments.length; e++)
                        this.Tu[e].classList.add("no-underline")
            } else
                this.Lu.style.display = "none"
        }
        ew(t, e) {
            var i = !1
              , n = !1
              , s = !1;
            const o = this.m.song.channels[t];
            if (t < this.m.song.pitchChannelCount + this.m.song.noiseChannelCount)
                for (let i = this.m.song.pitchChannelCount + this.m.song.noiseChannelCount; i < this.m.song.channels.length; i++) {
                    const n = this.m.song.channels[i]
                      , a = n.bars[this.m.bar];
                    if (a > 0) {
                        const i = n.patterns[a - 1].instruments[0]
                          , r = n.instruments[i];
                        for (let i = 0; i < p.modCount; i++)
                            r.modChannels[i] == t && (r.modInstruments[i] == e || r.modInstruments[i] >= o.instruments.length) && (s = !0)
                    }
                }
            let a = Math.min(this.m.selection.boxSelectionX0, this.m.selection.boxSelectionX1)
              , r = Math.max(this.m.selection.boxSelectionX0, this.m.selection.boxSelectionX1)
              , h = Math.min(this.m.selection.boxSelectionY0, this.m.selection.boxSelectionY1)
              , l = Math.max(this.m.selection.boxSelectionY0, this.m.selection.boxSelectionY1);
            if (0 != o.bars[this.m.bar])
                for (let t = 0; t < this.m.song.barCount; t++)
                    o.bars[t] == o.bars[this.m.bar] && t != this.m.bar && (t < a || t > r || this.m.channel < h || this.m.channel > l) && (n = !0,
                    t = this.m.song.barCount);
            for (let t = 0; t < this.m.song.barCount; t++)
                0 != o.bars[t] && o.bars[t] != o.bars[this.m.bar] && o.patterns[o.bars[t] - 1].instruments.includes(e) && t != this.m.bar && (t < a || t > r || this.m.channel < h || this.m.channel > l) && (i = !0,
                t = this.m.song.barCount);
            n ? (this.eg.style.setProperty("fill", nt.indicatorPrimary),
            this.patternUsed = !0) : (this.eg.style.setProperty("fill", nt.indicatorSecondary),
            this.patternUsed = !1),
            i ? this.ig.style.setProperty("fill", nt.indicatorPrimary) : this.ig.style.setProperty("fill", nt.indicatorSecondary),
            s ? (this.ng.style.setProperty("display", ""),
            this.ng.style.setProperty("fill", nt.indicatorPrimary),
            this.ng.classList.add("modTarget")) : t < this.m.song.pitchChannelCount + this.m.song.noiseChannelCount ? (this.ng.style.setProperty("display", ""),
            this.ng.style.setProperty("fill", nt.indicatorSecondary),
            this.ng.classList.remove("modTarget")) : this.ng.style.setProperty("display", "none")
        }
        Om(t) {
            let e;
            if (e = navigator,
            e.clipboard && e.clipboard.writeText)
                return void e.clipboard.writeText(t).catch(( () => {
                    window.prompt("Copy to clipboard:", t)
                }
                ));
            const i = document.createElement("textarea");
            i.textContent = t,
            document.body.appendChild(i),
            i.select();
            const n = document.execCommand("copy");
            i.remove(),
            this.refocusStage(),
            n || window.prompt("Copy this:", t)
        }
        Sw(t, e) {
            this.Ba.setAttribute("width", "" + Math.min(144, 144 * t)),
            this.Ia.setAttribute("x", "" + (8 + Math.min(144, 144 * e)))
        }
        Cw(t) {
            if ((this.Ag || this.Nh) && this.m.synth.playing) {
                const e = this.m.prefs.volume;
                this.m.prefs.volume = t,
                this.Um.setModSettingsForChange(null, this),
                window.clearTimeout(this.Qg),
                this.Qg = window.setTimeout(( () => {
                    this.Cw(t)
                }
                ), 10),
                this.m.recordingModulators = !0,
                this.m.prefs.volume = e,
                this.nu.updateValue(this.m.prefs.volume)
            } else
                this.m.setVolume(Number(this.nu.input.value)),
                this.m.recordingModulators && (this.m.recordingModulators = !1,
                this.m.record(new An(this.m,null,null,null)))
        }
        xf(t) {
            const e = this.m.song.channels[this.m.channel].instruments[this.m.getCurrentInstrument()];
            e.eqFilterType != t && this.m.record(new di(this.m,e,t))
        }
        If(t) {
            const e = this.m.song.channels[this.m.channel].instruments[this.m.getCurrentInstrument()];
            e.noteFilterType != t && this.m.record(new pi(this.m,e,t))
        }
        bw() {
            const t = this.m.song.getChannelIsNoise(this.m.channel);
            this.m.record(new ye(this.m,on(t)))
        }
        yw() {
            this.m.record(new be(this.m))
        }
        qw(t) {
            if (isNaN(t)) {
                switch (t) {
                case "copyInstrument":
                    this.uw();
                    break;
                case "pasteInstrument":
                    this.fw();
                    break;
                case "randomPreset":
                    this.bw();
                    break;
                case "randomGenerated":
                    this.yw()
                }
                this.m.notifier.changed()
            } else
                this.m.record(new ye(this.m,parseInt(t)))
        }
    }
    class gh {
        constructor(t) {
            this.m = t,
            this.vv = !1,
            this.xv = -1,
            this.kv = -1,
            this.Mv = !1,
            this.Sv = !1,
            this.Fv = [],
            this.Cv = [],
            this.Av = -1,
            this.Ev = -1,
            this.Tv = -1,
            this.Pv = null,
            this.Bv = null,
            this.Iv = !1,
            this.Lv = !1,
            this.Dv = null,
            this.zv = null,
            this.qv = null,
            this.Zl = () => {
                if (window.requestAnimationFrame(this.Zl),
                this.m.synth.recording) {
                    let t = this.Nv();
                    t = !!this.Ov() || t,
                    t && this.m.notifier.notifyWatchers()
                }
            }
            ,
            this.gr = () => {
                const t = this.m.song.getChannelIsNoise(this.m.channel)
                  , e = this.m.song.channels[this.m.channel].octave;
                this.m.synth.liveInputChannel == this.m.channel && this.m.synth.liveBassInputChannel == this.Rv() && this.vv == t && this.xv == e && this.kv == this.m.song.key || (this.m.synth.liveInputChannel = this.m.channel,
                this.m.synth.liveBassInputChannel = this.Rv(),
                this.vv = t,
                this.xv = e,
                this.kv = this.m.song.key,
                this.clearAllPitches(),
                this.clearAllBassPitches()),
                this.m.synth.liveInputInstruments = this.m.recentPatternInstruments[this.m.channel],
                this.m.synth.liveBassInputInstruments = this.m.recentPatternInstruments[this.m.synth.liveBassInputChannel]
            }
            ,
            this.m.notifier.watch(this.gr),
            this.gr(),
            window.requestAnimationFrame(this.Zl)
        }
        play() {
            this.m.synth.play(),
            this.m.synth.enableMetronome = !1,
            this.m.synth.countInMetronome = !1,
            this.m.synth.maintainLiveInput()
        }
        pause() {
            this.clearAllPitches(),
            this.clearAllBassPitches(),
            null != this.qv && (this.m.song.barCount > this.Av && !this.$v() && (new Me(this.m,this.m.song.barCount - 1,1),
            new Pe(this.m,this.m.channel,this.m.song.barCount - 1)),
            this.qv.isNoop() || (this.m.record(this.qv),
            this.qv = null),
            this.Dv = null),
            this.m.synth.pause(),
            this.m.synth.resetEffects(),
            this.m.synth.enableMetronome = !1,
            this.m.synth.countInMetronome = !1,
            this.m.prefs.autoFollow && this.m.synth.goToBar(this.m.bar),
            this.m.synth.snapToBar()
        }
        record() {
            this.m.synth.snapToBar();
            const t = Math.floor(this.m.synth.playhead);
            t != this.m.bar && new Pe(this.m,this.m.channel,t),
            this.Mv && (this.clearAllPitches(),
            this.Mv = !1),
            this.Sv && (this.clearAllBassPitches(),
            this.Sv = !1),
            this.m.synth.enableMetronome = this.m.prefs.metronomeWhileRecording,
            this.m.synth.countInMetronome = this.m.prefs.metronomeCountIn,
            this.m.synth.startRecording(),
            this.m.synth.maintainLiveInput(),
            this.Av = this.m.song.barCount,
            this.Ev = this.Hv(),
            this.Tv = this.Hv(),
            this.Pv = null,
            this.Bv = null,
            this.Iv = !1,
            this.Lv = !1,
            this.Dv = null,
            this.zv = null,
            this.Fv.length = 0,
            this.Cv.length = 0,
            this.qv = new Zt,
            this.m.setProspectiveChange(this.qv)
        }
        abortRecording() {
            this.qv = null,
            this.pause()
        }
        pitchesAreTemporary() {
            return this.Mv
        }
        bassPitchesAreTemporary() {
            return this.Sv
        }
        Rv() {
            return this.m.channel >= this.m.song.pitchChannelCount ? this.m.channel : Math.max(0, Math.min(this.m.song.pitchChannelCount - 1, this.m.channel + this.m.prefs.bassOffset))
        }
        vl() {
            return this.m.prefs.snapRecordedNotesToRhythm ? p.partsPerBeat / p.rhythms[this.m.song.rhythm].stepsPerBeat : 1
        }
        Hv() {
            const t = this.m.synth.playhead * this.m.song.beatsPerBar * p.partsPerBeat;
            if (this.m.prefs.snapRecordedNotesToRhythm) {
                const e = this.vl();
                return Math.round(t / e) * e
            }
            return Math.round(t)
        }
        $v() {
            for (let t = 0; t < this.m.song.getChannelCount(); t++)
                if (0 != this.m.song.channels[t].bars[this.m.song.barCount - 1])
                    return !0;
            return !1
        }
        Nv() {
            if (null == this.qv)
                return !1;
            if (!this.m.lastChangeWas(this.qv))
                return this.abortRecording(),
                !1;
            if (this.m.synth.countInMetronome)
                return this.Fv.length = 0,
                this.Iv = !1,
                !1;
            const t = this.m.song.beatsPerBar * p.partsPerBeat
              , e = this.Ev % t
              , i = Math.floor(this.Ev / t)
              , n = this.Ev;
            this.Ev = this.Hv();
            const s = this.Ev % t
              , o = Math.floor(this.Ev / t);
            if (e == s && i == o)
                return !1;
            if (this.Ev < n)
                return this.Dv = null,
                this.Pv = null,
                !1;
            let a = !1;
            for (let n = i; n <= o; n++) {
                n != i && (this.Pv = null);
                const r = n == i ? e : 0
                  , h = n == o ? s : t;
                if (r == h)
                    break;
                if (null != this.Dv && !this.Iv && r > 0 && this.m.synth.liveInputPitches.length > 0)
                    this.qv.append(new Yi(this.m,this.Dv,1,h,this.Dv.continuesLastPattern)),
                    this.m.currentPatternIsDirty = !0;
                else {
                    null != this.Dv && (this.Dv = null);
                    let t = r
                      , e = h;
                    for (; t < h; ) {
                        let i = !1;
                        if (this.Fv.length > 0 || this.m.synth.liveInputPitches.length > 0) {
                            if (null == this.Pv && (this.m.selection.erasePatternInBar(this.qv, this.m.synth.liveInputChannel, n),
                            this.qv.append(new Ji(this.m,this.m.synth.liveInputChannel,n)),
                            this.Pv = this.m.song.getPattern(this.m.synth.liveInputChannel, n)),
                            null == this.Pv)
                                throw new Error;
                            for (this.Dv = new Tt(-1,t,e,p.noteSizeMax,this.m.song.getChannelIsNoise(this.m.synth.liveInputChannel)),
                            this.Dv.continuesLastPattern = 0 == t && !this.Iv,
                            this.Dv.pitches.length = 0; this.Fv.length > 0 && !(this.Dv.pitches.length >= p.maxChordSize); ) {
                                const t = this.Fv.shift();
                                -1 == this.m.synth.liveInputPitches.indexOf(t) && (this.Dv.pitches.push(t),
                                i = !0)
                            }
                            for (let t = 0; t < this.m.synth.liveInputPitches.length && !(this.Dv.pitches.length >= p.maxChordSize); t++)
                                this.Dv.pitches.push(this.m.synth.liveInputPitches[t]);
                            this.qv.append(new gn(this.m,this.Pv,this.Dv,this.Pv.notes.length)),
                            i && (e = t + this.vl(),
                            new wn(this.m,this.Dv,this.Dv.start,e),
                            this.Dv = null),
                            a = !0
                        }
                        this.Iv = i,
                        t = e,
                        e = h
                    }
                }
                n == this.m.song.barCount - 1 && this.$v() && (new ke(this.m,this.m.song.barCount,1),
                this.m.bar--,
                a = !0)
            }
            return a
        }
        Ov() {
            if (null == this.qv)
                return !1;
            if (!this.m.lastChangeWas(this.qv))
                return this.abortRecording(),
                !1;
            if (this.m.synth.countInMetronome)
                return this.Cv.length = 0,
                this.Lv = !1,
                !1;
            const t = this.m.song.beatsPerBar * p.partsPerBeat
              , e = this.Tv % t
              , i = Math.floor(this.Tv / t)
              , n = this.Tv;
            this.Tv = this.Hv();
            const s = this.Tv % t
              , o = Math.floor(this.Tv / t);
            if (e == s && i == o)
                return !1;
            if (this.Tv < n)
                return this.zv = null,
                this.Bv = null,
                !1;
            let a = !1;
            for (let n = i; n <= o; n++) {
                n != i && (this.Bv = null);
                const r = n == i ? e : 0
                  , h = n == o ? s : t;
                if (r == h)
                    break;
                if (null != this.zv && !this.Lv && r > 0 && this.m.synth.liveBassInputPitches.length > 0)
                    this.qv.append(new Yi(this.m,this.zv,1,h,this.zv.continuesLastPattern)),
                    this.m.currentPatternIsDirty = !0;
                else {
                    null != this.zv && (this.zv = null);
                    let t = r
                      , e = h;
                    for (; t < h; ) {
                        let i = !1;
                        if (this.Cv.length > 0 || this.m.synth.liveBassInputPitches.length > 0) {
                            if (null == this.Bv && (this.m.selection.erasePatternInBar(this.qv, this.m.synth.liveBassInputChannel, n),
                            this.qv.append(new Ji(this.m,this.m.synth.liveBassInputChannel,n)),
                            this.Bv = this.m.song.getPattern(this.m.synth.liveBassInputChannel, n)),
                            null == this.Bv)
                                throw new Error;
                            for (this.zv = new Tt(-1,t,e,p.noteSizeMax,this.m.song.getChannelIsNoise(this.m.synth.liveBassInputChannel)),
                            this.zv.continuesLastPattern = 0 == t && !this.Lv,
                            this.zv.pitches.length = 0; this.Cv.length > 0 && !(this.zv.pitches.length >= p.maxChordSize); ) {
                                const t = this.Cv.shift();
                                -1 == this.m.synth.liveBassInputPitches.indexOf(t) && (this.zv.pitches.push(t),
                                i = !0)
                            }
                            for (let t = 0; t < this.m.synth.liveBassInputPitches.length && !(this.zv.pitches.length >= p.maxChordSize); t++)
                                this.zv.pitches.push(this.m.synth.liveBassInputPitches[t]);
                            this.qv.append(new gn(this.m,this.Bv,this.zv,this.Bv.notes.length)),
                            i && (e = t + this.vl(),
                            new wn(this.m,this.zv,this.zv.start,e),
                            this.zv = null),
                            a = !0
                        }
                        this.Lv = i,
                        t = e,
                        e = h
                    }
                }
                n == this.m.song.barCount - 1 && this.$v() && (new ke(this.m,this.m.song.barCount,1),
                this.m.bar--,
                a = !0)
            }
            return a
        }
        setTemporaryPitches(t, e) {
            this.Nv();
            for (let e = 0; e < t.length; e++)
                this.m.synth.liveInputPitches[e] = t[e];
            this.m.synth.liveInputPitches.length = Math.min(t.length, p.maxChordSize),
            this.m.synth.liveInputDuration = e,
            this.m.synth.liveInputStarted = !0,
            this.Mv = !0,
            this.Iv = !0
        }
        setTemporaryBassPitches(t, e) {
            this.Ov();
            for (let e = 0; e < t.length; e++)
                this.m.synth.liveBassInputPitches[e] = t[e];
            this.m.synth.liveBassInputPitches.length = Math.min(t.length, p.maxChordSize),
            this.m.synth.liveBassInputDuration = e,
            this.m.synth.liveBassInputStarted = !0,
            this.Sv = !0,
            this.Lv = !0
        }
        addPerformedPitch(t) {
            if (this.m.synth.maintainLiveInput(),
            t > ra.getBassCutoffPitch(this.m) || this.Rv() == this.m.channel) {
                if (this.Nv(),
                this.Mv && (this.clearAllPitches(),
                this.Mv = !1),
                this.m.prefs.ignorePerformedNotesNotInScale && !p.scales[this.m.song.scale].flags[t % p.pitchesPerOctave])
                    return;
                if (-1 == this.m.synth.liveInputPitches.indexOf(t)) {
                    for (this.m.synth.liveInputPitches.push(t),
                    this.Iv = !0; this.m.synth.liveInputPitches.length > p.maxChordSize; )
                        this.m.synth.liveInputPitches.shift();
                    if (this.m.synth.liveInputDuration = Number.MAX_SAFE_INTEGER,
                    null != this.qv) {
                        const e = this.Fv.indexOf(t);
                        for (-1 != e && this.Fv.splice(e, 1),
                        this.Fv.push(t); this.Fv.length > 4 * p.maxChordSize; )
                            this.Fv.shift()
                    }
                }
            } else {
                if (this.Ov(),
                this.Sv && (this.clearAllBassPitches(),
                this.Sv = !1),
                this.m.prefs.ignorePerformedNotesNotInScale && !p.scales[this.m.song.scale].flags[t % p.pitchesPerOctave])
                    return;
                if (-1 == this.m.synth.liveBassInputPitches.indexOf(t)) {
                    for (this.m.synth.liveBassInputPitches.push(t),
                    this.Lv = !0; this.m.synth.liveBassInputPitches.length > p.maxChordSize; )
                        this.m.synth.liveBassInputPitches.shift();
                    if (this.m.synth.liveBassInputDuration = Number.MAX_SAFE_INTEGER,
                    null != this.qv) {
                        const e = this.Fv.indexOf(t);
                        for (-1 != e && this.Cv.splice(e, 1),
                        this.Cv.push(t); this.Cv.length > 4 * p.maxChordSize; )
                            this.Cv.shift()
                    }
                }
            }
        }
        removePerformedPitch(t) {
            if (t > ra.getBassCutoffPitch(this.m) || this.Rv() == this.m.channel) {
                this.Nv();
                for (let e = 0; e < this.m.synth.liveInputPitches.length; e++)
                    this.m.synth.liveInputPitches[e] == t && (this.m.synth.liveInputPitches.splice(e, 1),
                    this.Iv = !0,
                    e--)
            } else {
                this.Ov();
                for (let e = 0; e < this.m.synth.liveBassInputPitches.length; e++)
                    this.m.synth.liveBassInputPitches[e] == t && (this.m.synth.liveBassInputPitches.splice(e, 1),
                    this.Lv = !0,
                    e--)
            }
        }
        clearAllPitches() {
            this.Nv(),
            this.m.synth.liveInputPitches.length = 0,
            this.Iv = !0
        }
        clearAllBassPitches() {
            this.Ov(),
            this.m.synth.liveBassInputPitches.length = 0,
            this.Lv = !0
        }
    }
    class wh {
        constructor(t) {
            this.m = t,
            this.boxSelectionX0 = 0,
            this.boxSelectionY0 = 0,
            this.boxSelectionX1 = 0,
            this.boxSelectionY1 = 0,
            this.digits = "",
            this.instrumentDigits = "",
            this.patternSelectionStart = 0,
            this.patternSelectionEnd = 0,
            this.patternSelectionActive = !1,
            this._v = null,
            this.Vv = null,
            this.Gv = null,
            this.Wv = null
        }
        toJSON() {
            return {
                x0: this.boxSelectionX0,
                x1: this.boxSelectionX1,
                y0: this.boxSelectionY0,
                y1: this.boxSelectionY1,
                start: this.patternSelectionStart,
                end: this.patternSelectionEnd
            }
        }
        fromJSON(t) {
            null != t && (this.boxSelectionX0 = +t.x0,
            this.boxSelectionX1 = +t.x1,
            this.boxSelectionY0 = +t.y0,
            this.boxSelectionY1 = +t.y1,
            this.patternSelectionStart = +t.start,
            this.patternSelectionEnd = +t.end,
            this.digits = "",
            this.instrumentDigits = "",
            this.patternSelectionActive = this.patternSelectionStart < this.patternSelectionEnd)
        }
        selectionUpdated() {
            this.m.notifier.changed(),
            this.digits = "",
            this.instrumentDigits = ""
        }
        get boxSelectionBar() {
            return Math.min(this.boxSelectionX0, this.boxSelectionX1)
        }
        get boxSelectionChannel() {
            return Math.min(this.boxSelectionY0, this.boxSelectionY1)
        }
        get boxSelectionWidth() {
            return Math.abs(this.boxSelectionX0 - this.boxSelectionX1) + 1
        }
        get boxSelectionHeight() {
            return Math.abs(this.boxSelectionY0 - this.boxSelectionY1) + 1
        }
        get boxSelectionActive() {
            return this.boxSelectionWidth > 1 || this.boxSelectionHeight > 1
        }
        scrollToSelectedPattern() {
            this.m.barScrollPos = Math.min(this.m.bar, Math.max(this.m.bar - (this.m.trackVisibleBars - 1), this.m.barScrollPos)),
            this.m.channelScrollPos = Math.min(this.m.channel, Math.max(this.m.channel - (this.m.trackVisibleChannels - 1), this.m.channelScrollPos))
        }
        scrollToEndOfSelection() {
            this.m.barScrollPos = Math.min(this.boxSelectionX1, Math.max(this.boxSelectionX1 - (this.m.trackVisibleBars - 1), this.m.barScrollPos)),
            this.m.channelScrollPos = Math.min(this.boxSelectionY1, Math.max(this.boxSelectionY1 - (this.m.trackVisibleChannels - 1), this.m.channelScrollPos))
        }
        setChannelBar(t, e) {
            if (t == this.m.channel && e == this.m.bar)
                return;
            const i = this.m.lastChangeWas(this.Vv);
            this.Vv = new Zt,
            this.Vv.append(new Pe(this.m,t,e));
            const n = this.m.getCurrentPattern(0);
            null != n && n.instruments.indexOf(this.m.viewedInstrument[this.m.channel]) < 0 && (this.m.viewedInstrument[this.m.channel] = n.instruments[0]),
            this.m.hasRedoHistory() || this.m.record(this.Vv, i),
            this.selectionUpdated()
        }
        setPattern(t) {
            this.m.record(new ve(this.m,t,this.boxSelectionBar,this.boxSelectionChannel,this.boxSelectionWidth,this.boxSelectionHeight))
        }
        nextDigit(t, e, i) {
            if (i)
                "3" == t ? this.m.record(new Ri(this.m,0)) : "4" == t ? this.m.record(new Ri(this.m,1)) : "6" == t ? this.m.record(new Ri(this.m,2)) : "8" == t ? this.m.record(new Ri(this.m,3)) : "0" != t && "1" != t || this.m.record(new Ri(this.m,4));
            else if (e) {
                "0" == t && (t = "10"),
                this.instrumentDigits += t;
                var n = parseInt(this.instrumentDigits);
                if (0 != n && n <= this.m.song.channels[this.m.channel].instruments.length)
                    return void this.selectInstrument(n - 1);
                if (this.instrumentDigits = t,
                0 != (n = parseInt(this.instrumentDigits)) && n <= this.m.song.channels[this.m.channel].instruments.length)
                    return void this.selectInstrument(n - 1);
                this.instrumentDigits = ""
            } else {
                this.digits += t;
                let e = parseInt(this.digits);
                if (e <= this.m.song.patternsPerChannel)
                    return void this.setPattern(e);
                if (this.digits = t,
                e = parseInt(this.digits),
                e <= this.m.song.patternsPerChannel)
                    return void this.setPattern(e);
                this.digits = ""
            }
        }
        setModChannel(t, e) {
            this.m.record(new Gi(this.m,t,e))
        }
        setModInstrument(t, e) {
            this.m.record(new Wi(this.m,t,e))
        }
        setModSetting(t, e) {
            this.m.record(new ji(this.m,t,e))
        }
        setModFilter(t, e) {
            this.m.record(new Ui(this.m,t,e))
        }
        insertBars() {
            this.m.record(new ke(this.m,this.boxSelectionBar + this.boxSelectionWidth,this.boxSelectionWidth));
            const t = this.boxSelectionWidth;
            this.boxSelectionX0 += t,
            this.boxSelectionX1 += t
        }
        insertChannel() {
            const t = new Zt
              , e = this.boxSelectionChannel + this.boxSelectionHeight
              , i = this.m.song.getChannelIsNoise(e - 1)
              , n = this.m.song.getChannelIsMod(e - 1);
            t.append(new Ee(this.m,e,i,n)),
            t.isNoop() || (this.boxSelectionY0 = this.boxSelectionY1 = e,
            t.append(new Pe(this.m,e,this.m.bar)),
            this.m.record(t))
        }
        deleteBars() {
            const t = new Zt;
            if (this.m.selection.patternSelectionActive) {
                this.boxSelectionActive && t.append(new En(this.m,this.boxSelectionBar,this.boxSelectionWidth,this.boxSelectionChannel,this.boxSelectionHeight));
                for (const e of this.jv())
                    for (const i of this.Uv(e))
                        t.append(new vn(this.m,i,this.m.selection.patternSelectionStart,this.m.selection.patternSelectionEnd));
                t.append(new Fn(this.m,0,0))
            } else {
                t.append(new Me(this.m,this.boxSelectionBar,this.boxSelectionWidth));
                const e = this.boxSelectionWidth;
                this.boxSelectionX0 = Math.max(0, this.boxSelectionX0 - e),
                this.boxSelectionX1 = Math.max(0, this.boxSelectionX1 - e)
            }
            this.m.record(t)
        }
        deleteChannel() {
            this.m.record(new Te(this.m,this.boxSelectionChannel,this.boxSelectionChannel + this.boxSelectionHeight - 1)),
            this.boxSelectionY0 = this.boxSelectionY1 = this.m.channel,
            nt.resetColors()
        }
        *jv() {
            for (let t = this.boxSelectionChannel; t < this.boxSelectionChannel + this.boxSelectionHeight; t++)
                yield t
        }
        *Kv() {
            for (let t = this.boxSelectionBar; t < this.boxSelectionBar + this.boxSelectionWidth; t++)
                yield t
        }
        *Uv(t) {
            const e = {};
            for (const i of this.Kv()) {
                const n = this.m.song.channels[t].bars[i];
                if (0 == n)
                    continue;
                if (e[String(n)])
                    continue;
                e[String(n)] = !0;
                const s = this.m.song.getPattern(t, i);
                if (null == s)
                    throw new Error;
                yield s
            }
        }
        Jv(t, e) {
            const i = Array.from(t.instruments).map((t => t >>> 0));
            return ee(i, this.m.song, e),
            i
        }
        Yv(t, e) {
            for (let i = 0; i < this.m.song.barCount; i++)
                if (this.m.song.channels[t].bars[i] == e)
                    return !1;
            return !0
        }
        copy() {
            const t = [];
            for (const e of this.jv()) {
                const i = {}
                  , n = [];
                for (const t of this.Kv()) {
                    const s = this.m.song.channels[e].bars[t];
                    if (n.push(s),
                    null == i[String(s)]) {
                        const n = this.m.song.getPattern(e, t);
                        let o = this.m.recentPatternInstruments[e]
                          , a = [];
                        if (null != n)
                            if (o = n.instruments.concat(),
                            this.patternSelectionActive)
                                for (const t of n.cloneNotes())
                                    t.end <= this.patternSelectionStart || t.start >= this.patternSelectionEnd || (t.start -= this.patternSelectionStart,
                                    t.end -= this.patternSelectionStart,
                                    (t.start < 0 || t.end > this.patternSelectionEnd - this.patternSelectionStart) && new wn(null,t,Math.max(t.start, 0),Math.min(this.patternSelectionEnd - this.patternSelectionStart, t.end)),
                                    a.push(t));
                            else
                                a = n.notes;
                        i[String(s)] = {
                            instruments: o,
                            notes: a
                        }
                    }
                }
                const s = {
                    isNoise: this.m.song.getChannelIsNoise(e),
                    isMod: this.m.song.getChannelIsMod(e),
                    patterns: i,
                    bars: n
                };
                t.push(s)
            }
            const e = {
                partDuration: this.patternSelectionActive ? this.patternSelectionEnd - this.patternSelectionStart : this.m.song.beatsPerBar * p.partsPerBeat,
                channels: t
            };
            window.localStorage.setItem("selectionCopy", JSON.stringify(e)),
            new Fn(this.m,0,0)
        }
        Qv(t) {
            let e = t.slice();
            e.sort((function(t, e) {
                return t - e
            }
            ));
            let i = e[0] % p.drumCount;
            let n = i + (e.length - 1);
            for (; n >= p.drumCount; )
                i--,
                n--;
            for (let t = 0; t < e.length; t++)
                e[t] = t + i;
            return e
        }
        Zv(t) {
            let e = [];
            for (let i = 0; i < t.length; i++) {
                const n = t[i]
                  , s = this.Qv(n.pitches.slice())
                  , o = n.pins;
                let a = [];
                for (let t = 0; t < o.length; t++) {
                    const e = o[t];
                    a.push({
                        interval: e.interval,
                        time: e.time,
                        size: e.size
                    })
                }
                const r = n.start
                  , h = n.end
                  , l = n.continuesLastPattern
                  , c = new Tt(0,r,h,0,!1);
                c.pitches = s,
                c.pins = a,
                c.continuesLastPattern = l,
                e.push(c)
            }
            return e
        }
        cutNotes() {
            const t = new Zt
              , e = this.boxSelectionChannel
              , i = this.boxSelectionBar
              , n = this.boxSelectionHeight
              , s = this.boxSelectionWidth;
            this.copy();
            for (let o = e; o < e + n; o++)
                for (let e = i; e < i + s; e++) {
                    const i = this.m.song.channels[o].bars[e];
                    if (0 != i) {
                        const e = this.m.song.channels[o].patterns[i - 1];
                        t.append(new vn(this.m,e,0,p.partsPerBeat * this.m.song.beatsPerBar))
                    }
                }
            this.m.record(t)
        }
        pasteNotes() {
            const t = JSON.parse(String(window.localStorage.getItem("selectionCopy")));
            if (null == t)
                return;
            const e = t.channels || []
              , i = t.partDuration >>> 0
              , n = new Zt
              , s = this.boxSelectionWidth > 1 || this.boxSelectionHeight > 1
              , o = s ? this.boxSelectionHeight : Math.min(e.length, this.m.song.getChannelCount() - this.boxSelectionChannel);
            for (let t = 0; t < o; t++) {
                const a = e[t % e.length]
                  , r = this.boxSelectionChannel + t
                  , h = this.m.song.getChannelIsNoise(r)
                  , l = !!a.isNoise
                  , c = !!a.isMod
                  , d = !l && !c
                  , m = a.patterns || {}
                  , u = a.bars || [];
                if (0 == u.length)
                    continue;
                if (l && this.m.song.getChannelIsMod(r))
                    continue;
                if (c != this.m.song.getChannelIsMod(r))
                    continue;
                const f = s ? this.boxSelectionWidth : Math.min(u.length, this.m.song.barCount - this.boxSelectionBar);
                if (s || 1 != u.length || 1 != e.length)
                    if (this.patternSelectionActive) {
                        const t = {}
                          , e = {};
                        n.append(new En(this.m,this.boxSelectionBar,f,this.boxSelectionChannel,o));
                        for (let s = 0; s < f; s++) {
                            const o = this.boxSelectionBar + s
                              , a = u[s % u.length] >>> 0
                              , l = this.m.song.channels[r].bars[o]
                              , c = [a, l].join(",");
                            if (0 == a && 0 == l)
                                continue;
                            if (null != t[c]) {
                                n.append(new ve(this.m,t[c],o,r,1,1));
                                continue
                            }
                            if (0 == l) {
                                n.append(new Ji(this.m,r,o));
                                const t = m[String(a)]
                                  , e = this.Jv(t, r)
                                  , i = this.m.song.getPattern(r, o);
                                n.append(new Vi(this.m,r,e,i))
                            } else {
                                const t = this.m.song.getPattern(r, o);
                                if (null == t)
                                    throw new Error;
                                if (e[String(l)]) {
                                    n.append(new ve(this.m,0,o,r,1,1)),
                                    n.append(new Ji(this.m,r,o));
                                    const e = this.m.song.getPattern(r, o);
                                    if (null == e)
                                        throw new Error;
                                    for (const i of t.cloneNotes())
                                        d && h && (i.pitches = this.Qv(i.pitches)),
                                        n.append(new gn(this.m,e,i,e.notes.length,!1))
                                } else
                                    e[String(l)] = !0
                            }
                            const p = this.m.song.getPattern(r, o);
                            if (null == p)
                                throw new Error;
                            if (0 == a)
                                n.append(new vn(this.m,p,this.patternSelectionStart,this.patternSelectionEnd));
                            else {
                                let t = m[String(a)].notes;
                                d && h && (t = this.Zv(t)),
                                n.append(new $i(this.m,p,t,this.patternSelectionStart,this.patternSelectionEnd,i))
                            }
                            t[c] = this.m.song.channels[r].bars[o]
                        }
                    } else {
                        for (let t = 0; t < f; t++)
                            this.erasePatternInBar(n, r, this.boxSelectionBar + t);
                        const t = {};
                        for (let e = 0; e < f; e++) {
                            const s = this.boxSelectionBar + e
                              , o = u[e % u.length] >>> 0
                              , a = String(o);
                            if (0 == o)
                                continue;
                            if (null != t[a]) {
                                n.append(new ve(this.m,t[a],s,r,1,1));
                                continue
                            }
                            const l = m[String(o)]
                              , c = this.Jv(l, r)
                              , f = this.m.song.channels[r].patterns[o - 1];
                            let y = l.notes;
                            if (d && h && (y = this.Zv(y)),
                            null != f && i == p.partsPerBeat * this.m.song.beatsPerBar && cn(y, f.notes) && te(c, f.instruments))
                                n.append(new ve(this.m,o,s,r,1,1));
                            else {
                                null != f && this.Yv(r, o) ? n.append(new ve(this.m,o,s,r,1,1)) : n.append(new Ji(this.m,r,s));
                                const t = this.m.song.getPattern(r, s);
                                if (null == t)
                                    throw new Error;
                                n.append(new $i(this.m,t,y,this.patternSelectionActive ? this.patternSelectionStart : 0,this.patternSelectionActive ? this.patternSelectionEnd : p.partsPerBeat * this.m.song.beatsPerBar,i)),
                                n.append(new Vi(this.m,r,c,t))
                            }
                            t[a] = this.m.song.channels[r].bars[s]
                        }
                    }
                else {
                    const t = u[0] >>> 0
                      , e = this.boxSelectionBar
                      , s = this.m.song.channels[r].bars[e];
                    if (0 == t && 0 == s)
                        continue;
                    const o = m[String(t)]
                      , a = this.Jv(o, r);
                    let l = o.notes;
                    if (d && h && (l = this.Zv(l)),
                    0 == s) {
                        const i = this.m.song.channels[r].patterns[t - 1];
                        null != i && !this.patternSelectionActive && (cn(l, i.notes) && te(a, i.instruments) || this.Yv(r, t)) ? n.append(new ve(this.m,t,e,r,1,1)) : n.append(new Ji(this.m,r,e))
                    }
                    const c = this.m.song.getPattern(r, e);
                    if (null == c)
                        throw new Error;
                    n.append(new $i(this.m,c,l,this.patternSelectionActive ? this.patternSelectionStart : 0,this.patternSelectionActive ? this.patternSelectionEnd : p.partsPerBeat * this.m.song.beatsPerBar,i)),
                    (0 == s || 0 == o.notes.length || r >= this.m.song.pitchChannelCount + this.m.song.noiseChannelCount) && (this.selectInstrument(a[0]),
                    n.append(new Vi(this.m,r,a,c)))
                }
            }
            this.m.record(n)
        }
        erasePatternInBar(t, e, i) {
            const n = this.m.song.channels[e].bars[i];
            0 != n && (t.append(new ve(this.m,0,i,e,1,1)),
            this.Yv(e, n) && (this.m.song.channels[e].patterns[n - 1].notes.length = 0))
        }
        pasteNumbers() {
            const t = JSON.parse(String(window.localStorage.getItem("selectionCopy")));
            if (null == t)
                return;
            const e = t.channels || []
              , i = new Zt
              , n = this.boxSelectionActive
              , s = n ? this.boxSelectionHeight : Math.min(e.length, this.m.song.getChannelCount() - this.boxSelectionChannel);
            for (let t = 0; t < s; t++) {
                const s = e[t % e.length]
                  , o = this.boxSelectionChannel + t
                  , a = s.bars || [];
                if (0 == a.length)
                    continue;
                const r = n ? this.boxSelectionWidth : Math.min(a.length, this.m.song.barCount - this.boxSelectionBar);
                for (let t = 0; t < r; t++) {
                    const e = a[t % a.length] >>> 0
                      , n = this.boxSelectionBar + t;
                    e > this.m.song.patternsPerChannel && i.append(new Ki(this.m,e)),
                    i.append(new ve(this.m,e,n,o,1,1))
                }
            }
            this.m.record(i)
        }
        selectAll() {
            new Fn(this.m,0,0),
            0 == this.boxSelectionBar && 0 == this.boxSelectionChannel && this.boxSelectionWidth == this.m.song.barCount && this.boxSelectionHeight == this.m.song.getChannelCount() ? this.setTrackSelection(this.m.bar, this.m.bar, this.m.channel, this.m.channel) : this.setTrackSelection(0, this.m.song.barCount - 1, 0, this.m.song.getChannelCount() - 1),
            this.selectionUpdated()
        }
        selectChannel() {
            new Fn(this.m,0,0),
            0 == this.boxSelectionBar && this.boxSelectionWidth == this.m.song.barCount ? this.setTrackSelection(this.m.bar, this.m.bar, this.boxSelectionY0, this.boxSelectionY1) : this.setTrackSelection(0, this.m.song.barCount - 1, this.boxSelectionY0, this.boxSelectionY1),
            this.selectionUpdated()
        }
        duplicatePatterns() {
            this.m.record(new En(this.m,this.boxSelectionBar,this.boxSelectionWidth,this.boxSelectionChannel,this.boxSelectionHeight))
        }
        muteChannels(t) {
            if (t) {
                let t = !1;
                for (let e = 0; e < this.m.song.channels.length; e++)
                    if (this.m.song.channels[e].muted) {
                        t = !0;
                        break
                    }
                for (let e = 0; e < this.m.song.channels.length; e++)
                    this.m.song.channels[e].muted = !t
            } else {
                let t = !1;
                for (const e of this.jv())
                    if (!this.m.song.channels[e].muted) {
                        t = !0;
                        break
                    }
                for (const e of this.jv())
                    this.m.song.channels[e].muted = t
            }
            this.m.notifier.changed()
        }
        soloChannels(t) {
            let e = !0;
            if (this.boxSelectionChannel >= this.m.song.pitchChannelCount + this.m.song.noiseChannelCount) {
                const e = this.m.song.channels[this.boxSelectionChannel]
                  , i = e.bars[this.m.bar] - 1
                  , n = i >= 0 ? e.instruments[e.patterns[i].instruments[0]] : e.instruments[this.m.viewedInstrument[this.boxSelectionChannel]]
                  , s = [];
                let o = !t;
                for (let t = 0; t < this.m.song.pitchChannelCount + this.m.song.noiseChannelCount; t++) {
                    s[t] = !1;
                    for (let e = 0; e < p.modCount; e++)
                        n.modChannels[e] == t && (s[t] = !0)
                }
                for (let e = 0; e < this.m.song.pitchChannelCount + this.m.song.noiseChannelCount; e++)
                    if (this.m.song.channels[e].muted == s[e]) {
                        o = t;
                        break
                    }
                for (let t = 0; t < this.m.song.pitchChannelCount + this.m.song.noiseChannelCount; t++)
                    this.m.song.channels[t].muted = !o && !s[t]
            } else {
                for (let i = 0; i < this.m.song.pitchChannelCount + this.m.song.noiseChannelCount; i++) {
                    const n = i < this.boxSelectionChannel || i >= this.boxSelectionChannel + this.boxSelectionHeight ? !t : t;
                    if (this.m.song.channels[i].muted != n) {
                        e = !1;
                        break
                    }
                }
                if (e)
                    for (let t = 0; t < this.m.song.channels.length; t++)
                        this.m.song.channels[t].muted = !1;
                else
                    for (let e = 0; e < this.m.song.pitchChannelCount + this.m.song.noiseChannelCount; e++)
                        this.m.song.channels[e].muted = e < this.boxSelectionChannel || e >= this.boxSelectionChannel + this.boxSelectionHeight ? !t : t
            }
            this.m.notifier.changed()
        }
        forceRhythm() {
            const t = new Zt;
            this.boxSelectionActive && t.append(new En(this.m,this.boxSelectionBar,this.boxSelectionWidth,this.boxSelectionChannel,this.boxSelectionHeight));
            for (const e of this.jv())
                for (const i of this.Uv(e))
                    t.append(new Zi(this.m,i));
            this.m.record(t)
        }
        forceScale() {
            const t = new Zt;
            this.boxSelectionActive && t.append(new En(this.m,this.boxSelectionBar,this.boxSelectionWidth,this.boxSelectionChannel,this.boxSelectionHeight));
            const e = [!0, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1];
            for (const t of this.jv())
                if (!this.m.song.getChannelIsNoise(t) && !this.m.song.getChannelIsMod(t))
                    for (const i of this.Uv(t))
                        ie(i, e);
            const i = function(t, e, i) {
                const n = e == p.scales.dictionary.Custom.index ? i : p.scales[e].flags
                  , s = []
                  , o = [];
                for (let e = 0; e < 12; e++)
                    t[e] && s.push(e),
                    n[e] && o.push(e);
                const a = s.length > o.length
                  , r = a ? o : s
                  , h = a ? s : o
                  , l = ["root", "second", "second", "third", "third", "fourth", "tritone", "fifth", "sixth", "sixth", "seventh", "seventh", "root"];
                let c = Number.MAX_SAFE_INTEGER
                  , d = [];
                const m = [[0]];
                for (; m.length > 0; ) {
                    const t = m.pop();
                    if (t.length == r.length) {
                        let e = 0;
                        for (let i = 0; i < t.length; i++)
                            e += Math.abs(r[i] - h[t[i]]),
                            l[r[i]] != l[h[t[i]]] && (e += .75);
                        c > e && (c = e,
                        d = t)
                    } else {
                        const e = t[t.length - 1] + 1
                          , i = h.length - r.length + t.length;
                        for (let n = e; n <= i; n++)
                            m.push(t.concat(n))
                    }
                }
                const u = [];
                for (let t = 0; t < d.length; t++) {
                    const e = r[t]
                      , i = h[d[t]];
                    u[t] = a ? [i, e] : [e, i]
                }
                u.push([12, 12]),
                o.push(12);
                let f = 0;
                const y = [];
                for (let t = 0; t < 12; t++) {
                    const e = u[f][0]
                      , i = u[f][1]
                      , n = u[f + 1][0]
                      , s = u[f + 1][1];
                    t == n - 1 && f++;
                    const a = (t - e) * (s - i) / (n - e) + i;
                    let r = 0
                      , h = Number.MAX_SAFE_INTEGER;
                    for (const e of o) {
                        let i = Math.abs(e - a);
                        l[e] != l[t] && (i += .1),
                        h > i && (h = i,
                        r = e)
                    }
                    y[t] = r
                }
                return y
            }(e, this.m.song.scale, this.m.song.scaleCustom);
            for (const e of this.jv())
                if (!this.m.song.getChannelIsNoise(e) && !this.m.song.getChannelIsMod(e))
                    for (const n of this.Uv(e))
                        t.append(new Tn(this.m,n,i));
            this.m.record(t)
        }
        setTrackSelection(t, e, i, n) {
            this.Vv = new Zt,
            this.Vv.append(new Sn(this.m,t,e,i,n)),
            this.m.record(this.Vv, !0)
        }
        transpose(t, e) {
            const i = this.m.lastChangeWas(this._v);
            this._v = new Zt,
            this.boxSelectionActive && this._v.append(new En(this.m,this.boxSelectionBar,this.boxSelectionWidth,this.boxSelectionChannel,this.boxSelectionHeight));
            for (const i of this.jv())
                if (!(i >= this.m.song.pitchChannelCount + this.m.song.noiseChannelCount))
                    for (const n of this.Uv(i))
                        this._v.append(new Mn(this.m,i,n,t,this.m.prefs.notesOutsideScale,e));
            this.m.record(this._v, i)
        }
        swapChannels(t) {
            const e = [this.m.song.pitchChannelCount, this.m.song.pitchChannelCount + this.m.song.noiseChannelCount, this.m.song.pitchChannelCount + this.m.song.noiseChannelCount + this.m.song.modChannelCount, this.m.song.getChannelCount()];
            let i = 0
              , n = 0;
            for (const s of e) {
                if (this.boxSelectionChannel < s && t < 0 || this.boxSelectionChannel + this.boxSelectionHeight <= s) {
                    n = s - 1;
                    break
                }
                i = s
            }
            const s = Math.max(this.boxSelectionChannel, i)
              , o = Math.min(this.boxSelectionChannel + this.boxSelectionHeight - 1, n);
            if (t = Math.max(t, i - s),
            0 != (t = Math.min(t, n - o))) {
                const e = this.m.lastChangeWas(this.Wv);
                this.Wv = new Zt,
                this.boxSelectionY0 = s + t,
                this.boxSelectionY1 = o + t,
                this.Wv.append(new Fe(this.m,s,o,t)),
                this.Wv.append(new Pe(this.m,Math.max(this.boxSelectionY0, Math.min(this.boxSelectionY1, this.m.channel + t)),this.m.bar)),
                this.selectionUpdated(),
                this.m.record(this.Wv, e)
            }
        }
        selectInstrument(t) {
            if (this.m.viewedInstrument[this.m.channel] == t) {
                if (this.m.song.layeredInstruments && this.m.song.patternInstruments && this.m.channel < this.m.song.pitchChannelCount + this.m.song.noiseChannelCount) {
                    const e = this.m.lastChangeWas(this.Gv);
                    this.Gv = new Zt;
                    const i = this.m.recentPatternInstruments[this.m.channel];
                    if (this.m.notifier.changed(),
                    -1 == i.indexOf(t)) {
                        i.push(t);
                        const e = this.m.song.getMaxInstrumentsPerPattern(this.m.channel);
                        i.length > e && i.splice(0, i.length - e)
                    } else
                        i.splice(i.indexOf(t), 1),
                        0 == i.length && (i[0] = 0);
                    this.boxSelectionActive && this.Gv.append(new En(this.m,this.boxSelectionBar,this.boxSelectionWidth,this.boxSelectionChannel,this.boxSelectionHeight));
                    for (const t of this.jv())
                        for (const e of this.Uv(t))
                            this.Gv.append(new Vi(this.m,t,i,e));
                    this.Gv.isNoop() || this.m.record(this.Gv, e)
                }
            } else {
                const e = this.m.lastChangeWas(this.Gv);
                if (this.Gv = new Zt,
                this.Gv.append(new Li(this.m,t)),
                this.m.song.layeredInstruments && this.m.channel < this.m.song.pitchChannelCount + this.m.song.noiseChannelCount || !this.m.song.patternInstruments)
                    this.m.hasRedoHistory() || this.m.record(this.Gv, e);
                else {
                    this.boxSelectionActive && this.Gv.append(new En(this.m,this.boxSelectionBar,this.boxSelectionWidth,this.boxSelectionChannel,this.boxSelectionHeight));
                    const i = [t];
                    for (const t of this.jv())
                        for (const e of this.Uv(t))
                            this.Gv.append(new Vi(this.m,t,i,e));
                    this.m.record(this.Gv, e)
                }
            }
        }
        resetBoxSelection() {
            this.boxSelectionX0 = this.boxSelectionX1 = this.m.bar,
            this.boxSelectionY0 = this.boxSelectionY1 = this.m.channel
        }
    }
    class vh {
        constructor() {
            this.volume = 75,
            this.visibleOctaves = vh.defaultVisibleOctaves,
            this.reload()
        }
        reload() {
            this.autoPlay = "true" == window.localStorage.getItem("autoPlay"),
            this.autoFollow = "false" != window.localStorage.getItem("autoFollow"),
            this.enableNotePreview = "false" != window.localStorage.getItem("enableNotePreview"),
            this.showFifth = "true" == window.localStorage.getItem("showFifth"),
            this.notesOutsideScale = "true" == window.localStorage.getItem("notesOutsideScale"),
            this.showLetters = "true" == window.localStorage.getItem("showLetters"),
            this.showChannels = "true" == window.localStorage.getItem("showChannels"),
            this.showScrollBar = "false" != window.localStorage.getItem("showScrollBar"),
            this.alwaysFineNoteVol = "true" == window.localStorage.getItem("alwaysFineNoteVol"),
            this.displayVolumeBar = "true" == window.localStorage.getItem("displayVolumeBar"),
            this.instrumentCopyPaste = "false" != window.localStorage.getItem("instrumentCopyPaste"),
            this.instrumentImportExport = "true" == window.localStorage.getItem("instrumentImportExport"),
            this.instrumentButtonsAtTop = "true" == window.localStorage.getItem("instrumentButtonsAtTop"),
            this.enableChannelMuting = "true" == window.localStorage.getItem("enableChannelMuting"),
            this.displayBrowserUrl = "false" != window.localStorage.getItem("displayBrowserUrl"),
            this.pressControlForShortcuts = "true" == window.localStorage.getItem("pressControlForShortcuts"),
            this.enableMidi = "false" != window.localStorage.getItem("enableMidi"),
            this.showRecordButton = "true" == window.localStorage.getItem("showRecordButton"),
            this.snapRecordedNotesToRhythm = "true" == window.localStorage.getItem("snapRecordedNotesToRhythm"),
            this.ignorePerformedNotesNotInScale = "true" == window.localStorage.getItem("ignorePerformedNotesNotInScale"),
            this.metronomeCountIn = "false" != window.localStorage.getItem("metronomeCountIn"),
            this.metronomeWhileRecording = "false" != window.localStorage.getItem("metronomeWhileRecording"),
            this.notesFlashWhenPlayed = "true" == window.localStorage.getItem("notesFlashWhenPlayed"),
            this.showOscilloscope = "false" != window.localStorage.getItem("showOscilloscope"),
            this.showSampleLoadingStatus = "false" != window.localStorage.getItem("showSampleLoadingStatus"),
            this.showDescription = "false" != window.localStorage.getItem("showDescription"),
            this.showInstrumentScrollbars = "true" == window.localStorage.getItem("showInstrumentScrollbars"),
            this.closePromptByClickoff = "true" == window.localStorage.getItem("closePromptByClickoff"),
            this.frostedGlassBackground = "true" == window.localStorage.getItem("frostedGlassBackground"),
            this.keyboardLayout = window.localStorage.getItem("keyboardLayout") || "wickiHayden",
            this.bassOffset = +window.localStorage.getItem("bassOffset") || 0,
            this.layout = window.localStorage.getItem("layout") || "small",
            this.colorTheme = window.localStorage.getItem("colorTheme") || nt.defaultTheme,
            this.customTheme = window.localStorage.getItem("customTheme"),
            this.customTheme2 = window.localStorage.getItem("customTheme2"),
            this.visibleOctaves = window.localStorage.getItem("visibleOctaves") >>> 0 || vh.defaultVisibleOctaves;
            const t = p.scales.dictionary[window.localStorage.getItem("defaultScale")];
            this.defaultScale = null != t ? t.index : 0,
            null != window.localStorage.getItem("volume") && (this.volume = Math.min(window.localStorage.getItem("volume") >>> 0, 75)),
            null != window.localStorage.getItem("fullScreen") && ("true" == window.localStorage.getItem("fullScreen") && (this.layout = "long"),
            window.localStorage.removeItem("fullScreen"))
        }
        save() {
            window.localStorage.setItem("autoPlay", this.autoPlay ? "true" : "false"),
            window.localStorage.setItem("autoFollow", this.autoFollow ? "true" : "false"),
            window.localStorage.setItem("enableNotePreview", this.enableNotePreview ? "true" : "false"),
            window.localStorage.setItem("showFifth", this.showFifth ? "true" : "false"),
            window.localStorage.setItem("notesOutsideScale", this.notesOutsideScale ? "true" : "false"),
            window.localStorage.setItem("defaultScale", p.scales[this.defaultScale].name),
            window.localStorage.setItem("showLetters", this.showLetters ? "true" : "false"),
            window.localStorage.setItem("showChannels", this.showChannels ? "true" : "false"),
            window.localStorage.setItem("showScrollBar", this.showScrollBar ? "true" : "false"),
            window.localStorage.setItem("alwaysFineNoteVol", this.alwaysFineNoteVol ? "true" : "false"),
            window.localStorage.setItem("displayVolumeBar", this.displayVolumeBar ? "true" : "false"),
            window.localStorage.setItem("enableChannelMuting", this.enableChannelMuting ? "true" : "false"),
            window.localStorage.setItem("instrumentCopyPaste", this.instrumentCopyPaste ? "true" : "false"),
            window.localStorage.setItem("instrumentImportExport", this.instrumentImportExport ? "true" : "false"),
            window.localStorage.setItem("instrumentButtonsAtTop", this.instrumentButtonsAtTop ? "true" : "false"),
            window.localStorage.setItem("displayBrowserUrl", this.displayBrowserUrl ? "true" : "false"),
            window.localStorage.setItem("pressControlForShortcuts", this.pressControlForShortcuts ? "true" : "false"),
            window.localStorage.setItem("enableMidi", this.enableMidi ? "true" : "false"),
            window.localStorage.setItem("showRecordButton", this.showRecordButton ? "true" : "false"),
            window.localStorage.setItem("snapRecordedNotesToRhythm", this.snapRecordedNotesToRhythm ? "true" : "false"),
            window.localStorage.setItem("ignorePerformedNotesNotInScale", this.ignorePerformedNotesNotInScale ? "true" : "false"),
            window.localStorage.setItem("metronomeCountIn", this.metronomeCountIn ? "true" : "false"),
            window.localStorage.setItem("metronomeWhileRecording", this.metronomeWhileRecording ? "true" : "false"),
            window.localStorage.setItem("notesFlashWhenPlayed", this.notesFlashWhenPlayed ? "true" : "false"),
            window.localStorage.setItem("showOscilloscope", this.showOscilloscope ? "true" : "false"),
            window.localStorage.setItem("showSampleLoadingStatus", this.showSampleLoadingStatus ? "true" : "false"),
            window.localStorage.setItem("showDescription", this.showDescription ? "true" : "false"),
            window.localStorage.setItem("showInstrumentScrollbars", this.showInstrumentScrollbars ? "true" : "false"),
            window.localStorage.setItem("closePromptByClickoff", this.closePromptByClickoff ? "true" : "false"),
            window.localStorage.setItem("frostedGlassBackground", this.frostedGlassBackground ? "true" : "false"),
            window.localStorage.setItem("keyboardLayout", this.keyboardLayout),
            window.localStorage.setItem("bassOffset", String(this.bassOffset)),
            window.localStorage.setItem("layout", this.layout),
            window.localStorage.setItem("colorTheme", this.colorTheme),
            window.localStorage.setItem("customTheme", this.customTheme),
            window.localStorage.setItem("customTheme2", this.customTheme2),
            window.localStorage.setItem("volume", String(this.volume)),
            window.localStorage.setItem("visibleOctaves", String(this.visibleOctaves))
        }
    }
    vh.defaultVisibleOctaves = 3;
    class xh {
        constructor() {
            this.Xv = [],
            this.tx = !1
        }
        watch(t) {
            -1 == this.Xv.indexOf(t) && this.Xv.push(t)
        }
        unwatch(t) {
            const e = this.Xv.indexOf(t);
            -1 != e && this.Xv.splice(e, 1)
        }
        changed() {
            this.tx = !0
        }
        notifyWatchers() {
            if (this.tx) {
                this.tx = !1;
                for (const t of this.Xv.concat())
                    t()
            }
        }
    }
    class kh {
        constructor() {
            this.notifier = new xh,
            this.selection = new wh(this),
            this.prefs = new vh,
            this.channel = 0,
            this.muteEditorChannel = 0,
            this.bar = 0,
            this.recentPatternInstruments = [],
            this.viewedInstrument = [],
            this.recordingModulators = !1,
            this.continuingModRecordingChange = null,
            this.trackVisibleBars = 16,
            this.trackVisibleChannels = 4,
            this.barScrollPos = 0,
            this.channelScrollPos = 0,
            this.prompt = null,
            this.addedEffect = !1,
            this.addedEnvelope = !1,
            this.currentPatternIsDirty = !1,
            this.ix = new Ba,
            this.nx = null,
            this.sx = 0,
            this.ox = 0,
            this.hx = !1,
            this.lx = !1,
            this.mx = !1,
            this.ux = () => {
                if (this.synth.recording && this.performance.abortRecording(),
                null == window.history.state && "" != window.location.hash) {
                    this.sx++,
                    this.yx();
                    const t = {
                        canUndo: !0,
                        sequenceNumber: this.sx,
                        bar: this.bar,
                        channel: this.channel,
                        instrument: this.viewedInstrument[this.channel],
                        recoveryUid: this.bx,
                        prompt: null,
                        selection: this.selection.toJSON()
                    };
                    try {
                        new rn(this,this.gx())
                    } catch (t) {
                        Ta(t)
                    }
                    return this.prompt = t.prompt,
                    this.prefs.displayBrowserUrl ? this.wx(t, this.song.toBase64String()) : this.vx(t, this.song.toBase64String()),
                    this.forgetLastChange(),
                    this.notifier.notifyWatchers(),
                    this.synth.pause(),
                    void this.synth.goToBar(0)
                }
                const t = this.xx();
                if (null == t)
                    throw new Error("History state is null.");
                if (t.sequenceNumber != this.sx) {
                    this.bar = t.bar,
                    this.channel = t.channel,
                    this.viewedInstrument[this.channel] = t.instrument,
                    this.sx = t.sequenceNumber,
                    this.prompt = t.prompt;
                    try {
                        new rn(this,this.gx())
                    } catch (t) {
                        Ta(t)
                    }
                    this.bx = t.recoveryUid,
                    this.selection.fromJSON(t.selection),
                    this.forgetLastChange(),
                    this.notifier.notifyWatchers()
                }
            }
            ,
            this.kx = () => {
                this.notifier.notifyWatchers()
            }
            ,
            this.Mx = () => {
                this.recordingModulators ? this.modRecordingHandler() : this.notifier.notifyWatchers()
            }
            ,
            this.Sx = () => {
                const t = this.song.getChannelCount();
                for (let e = this.recentPatternInstruments.length; e < t; e++)
                    this.recentPatternInstruments[e] = [0];
                this.recentPatternInstruments.length = t;
                for (let e = 0; e < t; e++) {
                    if (e == this.channel)
                        if (this.song.patternInstruments) {
                            const t = this.song.getPattern(this.channel, this.bar);
                            null != t && (this.recentPatternInstruments[e] = t.instruments.concat())
                        } else {
                            const t = this.song.channels[this.channel];
                            for (let i = 0; i < t.instruments.length; i++)
                                this.recentPatternInstruments[e][i] = i;
                            this.recentPatternInstruments[e].length = t.instruments.length
                        }
                    ee(this.recentPatternInstruments[e], this.song, e)
                }
                for (let e = this.viewedInstrument.length; e < t; e++)
                    this.viewedInstrument[e] = 0;
                this.viewedInstrument.length = t;
                for (let e = 0; e < t; e++) {
                    if (this.song.patternInstruments && !this.song.layeredInstruments && e == this.channel) {
                        const t = this.song.getPattern(this.channel, this.bar);
                        null != t && (this.viewedInstrument[e] = t.instruments[0])
                    }
                    this.viewedInstrument[e] = Math.min(0 | this.viewedInstrument[e], this.song.channels[e].instruments.length - 1)
                }
                const e = this.getCurrentPattern();
                null != e && this.song.patternInstruments && (this.recentPatternInstruments[this.channel] = e.instruments.concat()),
                (!this.synth.playing && (this.bar < this.selection.boxSelectionBar || this.selection.boxSelectionBar + this.selection.boxSelectionWidth <= this.bar) || this.channel < this.selection.boxSelectionChannel || this.selection.boxSelectionChannel + this.selection.boxSelectionHeight <= this.channel || this.song.barCount < this.selection.boxSelectionBar + this.selection.boxSelectionWidth || t < this.selection.boxSelectionChannel + this.selection.boxSelectionHeight || 1 == this.selection.boxSelectionWidth && 1 == this.selection.boxSelectionHeight) && this.selection.resetBoxSelection(),
                this.barScrollPos = Math.max(0, Math.min(this.song.barCount - this.trackVisibleBars, this.barScrollPos)),
                this.channelScrollPos = Math.max(0, Math.min(this.song.getChannelCount() - this.trackVisibleChannels, this.channelScrollPos))
            }
            ,
            this.Fx = () => {
                let t;
                this.mx = !1;
                try {
                    t = this.song.toBase64String()
                } catch (t) {
                    return void Ta(t)
                }
                this.hx && this.sx++,
                this.lx ? this.yx() : this.ix.saveVersion(this.bx, this.song.title, t);
                let e = {
                    canUndo: !0,
                    sequenceNumber: this.sx,
                    bar: this.bar,
                    channel: this.channel,
                    instrument: this.viewedInstrument[this.channel],
                    recoveryUid: this.bx,
                    prompt: this.prompt,
                    selection: this.selection.toJSON()
                };
                this.hx ? this.vx(e, t) : this.wx(e, t),
                this.hx = !1,
                this.lx = !1
            }
            ,
            this.notifier.watch(this.Sx),
            nt.setTheme(this.prefs.colorTheme),
            so.setLayout(this.prefs.layout),
            null == window.sessionStorage.getItem("currentUndoIndex") && (window.sessionStorage.setItem("currentUndoIndex", "0"),
            window.sessionStorage.setItem("oldestUndoIndex", "0"),
            window.sessionStorage.setItem("newestUndoIndex", "0"));
            let t = window.location.hash;
            "" == t && (t = this.gx());
            try {
                this.song = new Vt(t),
                "" != t && null != t || (an(this.song),
                this.song.scale = this.prefs.defaultScale)
            } catch (t) {
                Ta(t)
            }
            t = this.song.toBase64String(),
            this.synth = new Jt(this.song),
            this.synth.volume = this.Cx(),
            this.synth.anticipatePoorPerformance = z;
            let e = this.xx();
            null == e && (e = {
                canUndo: !1,
                sequenceNumber: 0,
                bar: 0,
                channel: 0,
                instrument: 0,
                recoveryUid: Aa(),
                prompt: null,
                selection: this.selection.toJSON()
            }),
            null == e.recoveryUid && (e.recoveryUid = Aa()),
            this.wx(e, t),
            window.addEventListener("hashchange", this.ux),
            window.addEventListener("popstate", this.ux),
            this.bar = 0 | e.bar,
            this.channel = 0 | e.channel;
            for (let t = 0; t <= this.channel; t++)
                this.viewedInstrument[t] = 0;
            this.viewedInstrument[this.channel] = 0 | e.instrument,
            this.bx = e.recoveryUid,
            this.prompt = e.prompt,
            this.selection.fromJSON(e.selection),
            this.selection.scrollToSelectedPattern();
            for (const t of ["change", "click", "keyup", "mousedown", "mouseup", "touchstart", "touchmove", "touchend", "touchcancel"])
                window.addEventListener(t, this.kx);
            for (const t of ["keydown", "input", "mousemove"])
                window.addEventListener(t, this.Mx);
            this.Sx(),
            this.performance = new gh(this)
        }
        toggleDisplayBrowserUrl() {
            const t = this.xx();
            if (null == t)
                throw new Error("History state is null.");
            this.prefs.displayBrowserUrl = !this.prefs.displayBrowserUrl,
            this.wx(t, this.song.toBase64String())
        }
        xx() {
            if (this.prefs.displayBrowserUrl)
                return window.history.state;
            {
                const t = JSON.parse(window.sessionStorage.getItem(window.sessionStorage.getItem("currentUndoIndex")));
                return null == t ? null : t.state
            }
        }
        gx() {
            if (this.prefs.displayBrowserUrl)
                return window.location.hash;
            {
                const t = JSON.parse(window.sessionStorage.getItem(window.sessionStorage.getItem("currentUndoIndex")));
                return null == t ? "" : t.hash
            }
        }
        wx(t, e) {
            this.prefs.displayBrowserUrl ? window.history.replaceState(t, "", "#" + e) : (window.sessionStorage.setItem(window.sessionStorage.getItem("currentUndoIndex") || "0", JSON.stringify({
                state: t,
                hash: e
            })),
            window.history.replaceState(null, "", location.pathname))
        }
        vx(t, e) {
            if (this.prefs.displayBrowserUrl)
                window.history.pushState(t, "", "#" + e);
            else {
                let i = Number(window.sessionStorage.getItem("currentUndoIndex"))
                  , n = Number(window.sessionStorage.getItem("oldestUndoIndex"));
                i = (i + 1) % kh.Ax,
                window.sessionStorage.setItem("currentUndoIndex", String(i)),
                window.sessionStorage.setItem("newestUndoIndex", String(i)),
                i == n && (n = (n + 1) % kh.Ax,
                window.sessionStorage.setItem("oldestUndoIndex", String(n))),
                window.sessionStorage.setItem(String(i), JSON.stringify({
                    state: t,
                    hash: e
                })),
                window.history.replaceState(null, "", location.pathname)
            }
            this.ox = t.sequenceNumber
        }
        hasRedoHistory() {
            return this.ox > this.sx
        }
        Ex() {
            if (this.prefs.displayBrowserUrl)
                window.history.forward();
            else {
                let t = Number(window.sessionStorage.getItem("currentUndoIndex"));
                t != Number(window.sessionStorage.getItem("newestUndoIndex")) && (t = (t + 1) % kh.Ax,
                window.sessionStorage.setItem("currentUndoIndex", String(t)),
                setTimeout(this.ux))
            }
        }
        Tx() {
            if (this.prefs.displayBrowserUrl)
                window.history.back();
            else {
                let t = Number(window.sessionStorage.getItem("currentUndoIndex"));
                t != Number(window.sessionStorage.getItem("oldestUndoIndex")) && (t = (t + kh.Ax - 1) % kh.Ax,
                window.sessionStorage.setItem("currentUndoIndex", String(t)),
                setTimeout(this.ux))
            }
        }
        record(t, e=!1, i=!1) {
            t.isNoop() ? (this.nx = null,
            e && this.Tx()) : (t.commit(),
            this.nx = t,
            this.hx = this.hx || !e,
            this.lx = this.lx || i,
            this.mx || (window.requestAnimationFrame(this.Fx),
            this.mx = !0))
        }
        yx() {
            this.bx = Aa()
        }
        openPrompt(t) {
            this.prompt = t;
            const e = this.song.toBase64String();
            this.sx++;
            const i = {
                canUndo: !0,
                sequenceNumber: this.sx,
                bar: this.bar,
                channel: this.channel,
                instrument: this.viewedInstrument[this.channel],
                recoveryUid: this.bx,
                prompt: this.prompt,
                selection: this.selection.toJSON()
            };
            this.vx(i, e)
        }
        undo() {
            const t = this.xx();
            (null == t || t.canUndo) && this.Tx()
        }
        redo() {
            this.Ex()
        }
        setProspectiveChange(t) {
            this.nx = t
        }
        forgetLastChange() {
            this.nx = null
        }
        checkLastChange() {
            return this.nx
        }
        lastChangeWas(t) {
            return null != t && t == this.nx
        }
        goBackToStart() {
            this.bar = 0,
            this.channel = 0,
            this.barScrollPos = 0,
            this.channelScrollPos = 0,
            this.synth.snapToStart(),
            this.notifier.changed()
        }
        setVolume(t) {
            this.prefs.volume = t,
            this.prefs.save(),
            this.synth.volume = this.Cx()
        }
        Cx() {
            return Math.min(1, Math.pow(this.prefs.volume / 50, .5)) * Math.pow(2, (this.prefs.volume - 75) / 25)
        }
        getCurrentPattern(t=0) {
            return this.song.getPattern(this.channel, this.bar + t)
        }
        getCurrentInstrument(t=0) {
            if (0 == t)
                return this.viewedInstrument[this.channel];
            {
                const e = this.getCurrentPattern(t);
                return null == e ? 0 : e.instruments[0]
            }
        }
        getMobileLayout() {
            return "wide" == this.prefs.layout ? window.innerWidth <= 1e3 : window.innerWidth <= 710
        }
        getBarWidth() {
            return this.getMobileLayout() || !this.prefs.enableChannelMuting || this.getFullScreen() && "wide" != this.prefs.layout ? 32 : 30
        }
        getChannelHeight() {
            const t = this.getMobileLayout() || this.song.getChannelCount() > 4 || this.song.barCount > this.trackVisibleBars && this.song.getChannelCount() > 3;
            return !this.getMobileLayout() && ("wide" != this.prefs.layout && this.song.getChannelCount() > 11 || this.song.getChannelCount() > 22) ? 23 : t ? 27 : 32
        }
        getFullScreen() {
            return !this.getMobileLayout() && "small" != this.prefs.layout
        }
        getVisibleOctaveCount() {
            return this.getFullScreen() ? this.prefs.visibleOctaves : vh.defaultVisibleOctaves
        }
        getVisiblePitchCount() {
            return this.getVisibleOctaveCount() * p.pitchesPerOctave + 1
        }
        getBaseVisibleOctave(t) {
            const e = this.getVisibleOctaveCount();
            return Math.max(0, Math.min(p.pitchOctaves - e, Math.ceil(this.song.channels[t].octave - .5 * e)))
        }
    }
    kh.Ax = 300;
    const Mh = new kh
      , Sh = new bh(Mh);
    if (document.getElementById("beepboxEditorContainer").appendChild(Sh.mainLayer),
    Sh.whenUpdated(),
    Sh.mainLayer.className += " load",
    Sh.mainLayer.getElementsByClassName("pattern-area")[0].className += " load",
    Sh.mainLayer.getElementsByClassName("settings-area")[0].className += " load",
    Sh.mainLayer.getElementsByClassName("editor-song-settings")[0].className += " load",
    Sh.mainLayer.getElementsByClassName("instrument-settings-area")[0].className += " load",
    Sh.mainLayer.getElementsByClassName("trackAndMuteContainer")[0].className += " load",
    Sh.mainLayer.getElementsByClassName("barScrollBar")[0].className += " load",
    $("#pitchPresetSelect").select2({
        dropdownAutoWidth: !0
    }),
    $("#drumPresetSelect").select2({
        dropdownAutoWidth: !0
    }),
    $("body").on("click", ".select2-container--open .select2-results__group", (function() {
        $(this).siblings().toggle()
    }
    )),
    $("#pitchPresetSelect").on("select2:open", (function() {
        $(".select2-dropdown--below").css("opacity", 0),
        $(".select2-dropdown").css("opacity", 1),
        $("#pitchPresetSelect"),
        setTimeout(( () => {
            let t = $(".select2-container--open .select2-results__group")
              , e = $(".select2-container--open .select2-results__option");
            $.each(t, ( (t, e) => {
                $(e).siblings().hide(),
                $(e)[0].setAttribute("style", "color: " + nt.getChannelColor(Mh.song, Mh.channel).primaryNote + ";")
            }
            )),
            $.each(e, ( (t, e) => {
                $(e)[0].setAttribute("style", "color: " + nt.getChannelColor(Mh.song, Mh.channel).primaryNote + ";")
            }
            )),
            $(".select2-dropdown--below").css("opacity", 1)
        }
        ), 0)
    }
    )),
    $("#drumPresetSelect").on("select2:open", (function() {
        $(".select2-dropdown--below").css("opacity", 0),
        $(".select2-dropdown").css("opacity", 1),
        $("#drumPresetSelect"),
        setTimeout(( () => {
            let t = $(".select2-container--open .select2-results__group")
              , e = $(".select2-container--open .select2-results__option");
            $.each(t, ( (t, e) => {
                $(e).siblings().hide(),
                $(e)[0].setAttribute("style", "color: " + nt.getChannelColor(Mh.song, Mh.channel).primaryNote + ";")
            }
            )),
            $.each(e, ( (t, e) => {
                $(e)[0].setAttribute("style", "color: " + nt.getChannelColor(Mh.song, Mh.channel).primaryNote + ";")
            }
            )),
            $(".select2-dropdown--below").css("opacity", 1)
        }
        ), 0)
    }
    )),
    $("#pitchPresetSelect").on("change", Sh.zw),
    $("#pitchPresetSelect").on("select2:close", Sh.Dw),
    $("#drumPresetSelect").on("change", Sh.Nw),
    $("#drumPresetSelect").on("select2:close", Sh.Dw),
    Sh.mainLayer.focus(),
    !z && Mh.prefs.autoPlay) {
        function Ah() {
            document.hidden || (Mh.synth.play(),
            Sh.updatePlayButton(),
            window.removeEventListener("visibilitychange", Ah))
        }
        document.hidden ? window.addEventListener("visibilitychange", Ah) : window.setTimeout(Ah)
    }
    return "scrollRestoration"in history && (history.scrollRestoration = "manual"),
    Sh.updatePlayButton(),
    "serviceWorker"in navigator && navigator.serviceWorker.register("/service_worker.js", {
        updateViaCache: "all",
        scope: "/"
    }).catch(( () => {}
    )),
    t.ChangePreset = ye,
    t.Channel = _t,
    t.ColorConfig = nt,
    t.Config = p,
    t.EditorConfig = N,
    t.ExportPrompt = no,
    t.Instrument = Ht,
    t.Note = Tt,
    t.Pattern = Pt,
    t.Song = Vt,
    t.SongDocument = kh,
    t.SongEditor = bh,
    t.Synth = Jt,
    Object.defineProperty(t, "Px", {
        value: !0
    }),
    t
}({});
//# sourceMappingURL=beepbox_editor.min.js.map
//# sourceMappingURL=beepbox_editor.min.js.map
